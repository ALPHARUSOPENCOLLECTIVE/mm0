import "x86.mm1";

theorem s2n_A (h1: $ s = a $) (h2: $ t = b $): $ s '+ t = a ++ b $ =
'(eqtr s2nsadd @ appendeq h1 h2);
theorem s2n_1 (h: $ c = a $): $ s1 c = a : 0 $ = '(eqtr s2ns1 @ conseq1 h);
theorem s2n_S (h1: $ c = a $) (h2: $ s = b $): $ c ': s = a : b $ =
'(eqtr (s2n_A (s2n_1 h1) h2) append1);
theorem s2n_SE (h: $ s = a $): $ c ': s = c : a $ = '(s2n_S eqid h);
theorem s2n_SAE (h: $ s = a ++ b $): $ c ': s = c : a ++ b $ =
'(eqtr4 (s2n_SE h) appendS);
theorem append01i (h: $ a = b $): $ a = 0 ++ b $ = '(eqtr4 h append0);
theorem s2n_R0: $ s0 = repeat a 0 $ = '(eqtr4 s2ns0 repeat0);
theorem s2n_R1 (h: $ c = a $): $ s1 c = repeat a 1 $ =
'(eqtr4 (s2n_1 h) repeat1);
theorem s2n_RA (h1: $ s = repeat a m $) (h2: $ t = repeat a n $):
  $ s '+ t = repeat a (m + n) $ = '(eqtr4 (s2n_A h1 h2) repeatadd);
theorem s2n_RS (h1: $ c = a $) (h2: $ s = repeat a n $):
  $ c ': s = repeat a (suc n) $ = '(eqtr4 (s2n_S h1 h2) repeatS);
theorem saddS: $ c ': s '+ t = c ': (s '+ t) $ =
'(eqtr4 (s2n_A s2nscons eqid) @ s2n_SAE s2nsadd);

theorem s2n_toBytesS0 (h: $ c = a $) (h2: $ s = repeat 0 k $):
  $ c ': s = toBytes (suc k) a $ =
'(eqtr (s2n_S (eqcom @ modltid @ mpbi elu8_2 c2nT) @
    eqtr4 h2 @ eqtr (toByteseq2 @ divlteq0 @ mpbi elu8_2 c2nT) toBytes02) @
  eqtr3 toBytesS @ toByteseq2 h);

theorem xtoBytes0: $ s0 = toBytes 0 a $ = '(eqtr4 s2ns0 toBytes0);
theorem xtoBytesS (h: $ s = toBytes k n $): $ ch a1 a0 ': s = toBytes (suc k) (n :x a1 :x a0) $ =
'(eqtr4 (s2n_S (eqtr4 c2nhex @ anr hex_divmod256) @
    eqtr4 h @ toByteseq2 @ anl hex_divmod256) toBytesS);
theorem xtoBytesS2 (h: $ s = toBytes k x0 $): $ ch a1 a0 ': s = toBytes (suc k) (a1 :x a0) $ =
'(eqtr (xtoBytesS h) @ toByteseq2 @ hexeq1 hex01);
theorem xtoBytesS1 (h: $ s = toBytes k x0 $): $ ch x0 a0 ': s = toBytes (suc k) a0 $ =
'(eqtr (xtoBytesS2 h) @ toByteseq2 hex01);
theorem xtoBytes1S: $ s1 (ch a1 a0) = toBytes (suc 0) (n :x a1 :x a0) $ =
'(eqtr3 s2nscons0 @ xtoBytesS xtoBytes0);
theorem xtoBytes12: $ s1 (ch a1 a0) = toBytes (suc 0) (a1 :x a0) $ =
'(eqtr3 s2nscons0 @ xtoBytesS2 xtoBytes0);
theorem xtoBytes11: $ s1 (ch x0 a0) = toBytes (suc 0) a0 $ =
'(eqtr xtoBytes12 @ toByteseq2 hex01);

theorem xbitNotS (h0: $ a + b = xf $) (h1: $ c = bitsNot k n $):
  $ c :x b = bitsNot (k + 4) (n :x a) $ = '(eqtr4 (hexeq1 h1) (bitsNot_hex h0));
theorem xbitNot1 (h0: $ a + h2n b = xf $): $ b = bitsNot 4 (n :x a) $ =
'(eqtr3 hex01_ @ eqtr (xbitNotS h0 @ eqcom bitsNot01) @ bitsNoteq1 add01);
theorem xbitNot_ch (h0: $ a0 + c0 = xf $) (h1: $ a1 + c1 = xf $):
  $ c2n (ch c1 c0) = bitsNot 8 (n :x a1 :x a0) $ =
'(eqtr c2nch @ eqtr (xbitNotS h0 @ xbitNot1 h1) @ bitsNoteq1 d4add4);

theorem xtoIBytes0: $ s0 = toIBytes 0 a $ = 'xtoBytes0;
theorem xtoIBytesSb0_ (h: $ s = toBytes k n $): $ s = toIBytes k (b0 n) $ = '(eqtr4 h toIBytes_b0);
theorem xtoIBytesSb0 (h: $ s = toIBytes k (b0 n) $):
  $ ch a1 a0 ': s = toIBytes (suc k) (b0 (n :x a1 :x a0)) $ =
'(xtoIBytesSb0_ @ xtoBytesS @ eqtr h toIBytes_b0);
theorem xtoIBytes02 (h: $ s = toBytes k x0 $): $ s2n s = toIBytes k 0 $ =
'(eqtr (xtoIBytesSb0_ h) @ toIByteseq2 @ eqtr (b0eq h2n0) b00);
theorem xtoIBytesSb1S (h0: $ a0 + c0 = xf $) (h1: $ a1 + c1 = xf $) (h: $ s = toIBytes k (b1 n) $):
  $ ch c1 c0 ': s = toIBytes (suc k) (b1 (n :x a1 :x a0)) $ =
'(eqtr s2nscons @ eqtr4 (conseq (xbitNot_ch h0 h1) @
  eqtr4 h @ toIByteseq2 @ b1eq @ anli xchopshr8) toIBytesS_b1);
theorem xtoIBytesSb12 (h0: $ a0 + c0 = xf $) (h1: $ a1 + c1 = xf $) (h: $ s = toIBytes k (b1 x0) $):
  $ ch c1 c0 ': s = toIBytes (suc k) (b1 (h2n a1 :x a0)) $ =
'(eqtr (xtoIBytesSb1S h0 h1 h) @ toIByteseq2 @ b1eq @ hexeq1 hex01);
theorem xtoIBytesSb11 (h0: $ a0 + c0 = xf $) (h: $ s = toIBytes k (b1 x0) $):
  $ ch xf c0 ': s = toIBytes (suc k) (b1 (h2n a0)) $ =
'(eqtr (xtoIBytesSb12 h0 addx01 h) @ toIByteseq2 @ b1eq hex01);
theorem xtoIBytesSb10 (h: $ s = toIBytes k (b1 x0) $):
  $ ch xf xf ': s = toIBytes (suc k) (b1 x0) $ = '(xtoIBytesSb11 addx01 h);

theorem xu16Bytes (h: $ s2n s = toBytes ,(sucs 2) n $): $ s = u16Bytes n $ = 'h;
theorem xu32Bytes (h: $ s2n s = toBytes ,(sucs 4) n $): $ s = u32Bytes n $ = 'h;
theorem xu64Bytes (h: $ s2n s = toBytes ,(sucs 8) n $): $ s = u64Bytes n $ = 'h;
theorem xi8Bytes (h: $ s2n s = toIBytes ,(sucs 1) n $): $ s = i8Bytes n $ = 'h;
theorem xi16Bytes (h: $ s2n s = toIBytes ,(sucs 2) n $): $ s = i16Bytes n $ = 'h;
theorem xi32Bytes (h: $ s2n s = toIBytes ,(sucs 4) n $): $ s = i32Bytes n $ = 'h;
theorem xi64Bytes (h: $ s2n s = toIBytes ,(sucs 8) n $): $ s = i64Bytes n $ = 'h;

theorem xu8Byte_2 (a0 a1: hex): $ ch a1 a0 = a1 :x a0 $ = 'c2nhex;
theorem xu8Byte_1 (a0: hex): $ ch x0 a0 = a0 $ = 'c2nh2n;
theorem xelu8_1 (a0: hex): $ a0 e. u8 $ = '(mpbi (eleq1 xu8Byte_1) c2nT);
theorem xelu8_2 (a0 a1: hex): $ a1 :x a0 e. u8 $ = '(mpbi (eleq1 xu8Byte_2) c2nT);

theorem xelBits4S (h: $ n e. Bits (4 * k) $): $ n :x a e. Bits (4 * suc k) $ =
'(mpbir (elneq2 @ Bitseq mulS) (hexT h));
theorem xelBits41: $ h2n a e. Bits (4 * suc k) $ =
'(mpbi (eleq1 hex01_) @ xelBits4S elBits01);
theorem xelBits8S (h: $ n e. Bits (8 * k) $): $ n :x a1 :x a0 e. Bits (8 * suc k) $ =
'(mpbir (elneq2 @ Bitseq mulS) (hex2T h));
theorem xelBits82: $ h2n a1 :x a0 e. Bits (8 * suc k) $ =
'(mpbi (eleq1 @ hexeq1 hex01_) @ xelBits8S elBits01);
theorem xelBits81: $ h2n a0 e. Bits (8 * suc k) $ =
'(mpbi (eleq1 hex01) xelBits82);
theorem xelBits7S (h: $ n e. Bits (8 * k + 7) $): $ n :x a1 :x a0 e. Bits (8 * suc k + 7) $ =
'(mpbir (elneq2 @ Bitseq @ eqtr (addeq1 mulS) addrass) (hex2T h));
theorem xelBits72S: $ h2n a1 :x a0 e. Bits (8 * suc k + 7) $ =
'(mpbi (elneq (hexeq1 hex01_) @ Bitseq @ eqtr4 addrass @ addeq1 mulS) (hex2T elBits01));
theorem xelBits720 (h: $ a1 < x8 $): $ h2n a1 :x a0 e. Bits (8 * 0 + 7) $ =
'(mpbi (elneq2 @ Bitseq {,norm_num : $ 3 + 4 = _ $})
  (hexT @ mpbir elBits2 @ mpbir (lteq2 @ eqtr d2pow3 dec8) h));
theorem xelBits71: $ h2n a0 e. Bits (8 * k + 7) $ =
'(Bitsle (letr {,norm_num : $ 4 <= 7 $} leaddid2) h2nT);

theorem xeluNlem (e: $ 8 * k = n $) (h: $ a e. Bits (8 * k) $): $ a e. Bits n $ =
'(mpbi (elneq2 @ Bitseq e) h);
theorem xelu8i (h: $ a e. Bits (8 * suc 0) $): $ a e. u8 $ = '(xeluNlem mul12 h);
theorem xelu16i (h: $ a e. Bits (8 * ,(sucs 2)) $): $ a e. u16 $ = '(xeluNlem d8mul2 h);
theorem xelu32i (h: $ a e. Bits (8 * ,(sucs 4)) $): $ a e. u32 $ = '(xeluNlem d8mul4 h);
theorem xelu64i (h: $ a e. Bits (8 * ,(sucs 8)) $): $ a e. u64 $ = '(xeluNlem d8mul8 h);
theorem xelBits7b0 (h: $ a e. Bits (8 * k + 7) $): $ b0 a e. Bits (8 * suc k) $ =
'(mpbir (elneq2 @ Bitseq @ eqtr mulS addS2) @ mpbi b0Bits h);
theorem xelBits7b1 (h: $ a e. Bits (8 * k + 7) $): $ b1 a e. Bits (8 * suc k) $ =
'(mpbir (elneq2 @ Bitseq @ eqtr mulS addS2) @ mpbi b1Bits h);
theorem xelu8b0i (h: $ a e. Bits (8 * 0 + 7) $): $ b0 a e. u8 $ = '(xelu8i @ xelBits7b0 h);
theorem xelu8b1i (h: $ a e. Bits (8 * 0 + 7) $): $ b1 a e. u8 $ = '(xelu8i @ xelBits7b1 h);
theorem xelu16b0i (h: $ a e. Bits (8 * ,(sucs 1) + 7) $): $ b0 a e. u16 $ = '(xelu16i @ xelBits7b0 h);
theorem xelu16b1i (h: $ a e. Bits (8 * ,(sucs 1) + 7) $): $ b1 a e. u16 $ = '(xelu16i @ xelBits7b1 h);
theorem xelu32b0i (h: $ a e. Bits (8 * ,(sucs 3) + 7) $): $ b0 a e. u32 $ = '(xelu32i @ xelBits7b0 h);
theorem xelu32b1i (h: $ a e. Bits (8 * ,(sucs 3) + 7) $): $ b1 a e. u32 $ = '(xelu32i @ xelBits7b1 h);
theorem xelu64b0i (h: $ a e. Bits (8 * ,(sucs 7) + 7) $): $ b0 a e. u64 $ = '(xelu64i @ xelBits7b0 h);
theorem xelu64b1i (h: $ a e. Bits (8 * ,(sucs 7) + 7) $): $ b1 a e. u64 $ = '(xelu64i @ xelBits7b1 h);

do {
  --| `(to-u8-ch a)` returns a pair `(c p)` where `p: c2n c = a`
  (def to-u8-ch @ match-fn
    [('hex ('h2n a) b) '((ch ,a ,b) (c2nhex ,a ,b))]
    [('h2n a) '((ch (x0) ,a) (c2nh2n ,a))])

  --| `(to-toBytes k n)` returns `(s p)` where `p: s2n s = toBytes k n`.
  --| Note that `k` should be a unary numeral constructed by `(sucs)`
  (def (to-toBytes k n) @ match k
    [$suc ,k$ @ match k
      [$0$ @ match n
        [$,n :x ,a1 :x ,a0$ '($s1 (ch ,a1 ,a0)$ (xtoBytes1S ,a0 ,a1 ,n))]
        [$h2n ,a1 :x ,a0$ '($s1 (ch ,a1 ,a0)$ (xtoBytes12 ,a0 ,a1))]
        [$h2n ,a0$ '($s1 (ch ,'(x0) ,a0)$ (xtoBytes11 ,a0))]]
      [_ @ match n
        [$,n :x ,a1 :x ,a0$ @ match (to-toBytes k n) @ (s p)
          '($ch ,a1 ,a0 ': ,s$ (xtoBytesS ,a0 ,a1 ,k ,n ,s ,p))]
        [$h2n ,a1 :x ,a0$ @ match (to-toBytes k '(h2n @ x0)) @ (s p)
          '($ch ,a1 ,a0 ': ,s$ (xtoBytesS2 ,a0 ,a1 ,k ,s ,p))]
        [$h2n ,a0$ @ match (to-toBytes k '(h2n @ x0)) @ (s p)
          '($ch ,'(x0) ,a0 ': ,s$ (xtoBytesS1 ,a0 ,k ,s ,p))]]]
    [$0$ '($s0$ (xtoBytesS1 ,n))])

  --| `(to-uNBytes N a)` returns a pair `(s p)` where `p: s2n s = uNBytes a`
  --| assuming `N = 16,32,64`
  (def (to-uNBytes n a)
    (def k (sucs {n // 8}))
    @ match (to-toBytes k a) @ (s p)
    '(,s (,(atom-app 'xu n 'Bytes) ,a ,s ,p)))

  --| `(decnot a) = (b p)` where `p: a + b = xf`
  (def decnot @ match-fn @ (a)
    @ let ([n (hexdigit->number a)] [m {15 - n}])
    '((,(hexdigit m)) ,(nth 1 @ decaddn n m)))

  --| `(to-toIBytesb1 k n) = (s p)` where `p: s2n s = toIBytes k (b1 n)`
  (def (to-toIBytesb1 k n) @ match k
    [$0$ '(s0 (xtoIBytes0 (b1 ,n)))]
    [$suc ,k$ @ match n
      ['(h2n @ x0) @ match (to-toIBytesb1 k '(h2n @ x0)) @ (s p)
        '($ ch xf xf ': ,s$ (xtoIBytesSb10 ,k ,s ,p))]
      [$,n :x ,a1 :x ,a0$ @ match (to-toIBytesb1 k n) @ (s p)
        @ match (decnot a0) @ (c0 p0) @ match (decnot a1) @ (c1 p1)
        '($ch ,c1 ,c0 ': ,s$ (xtoIBytesSb1S ,a0 ,a1 ,c0 ,c1 ,k ,n ,s ,p0 ,p1 ,p))]
      [$h2n ,a1 :x ,a0$ @ match (to-toIBytesb1 k '(h2n @ x0)) @ (s p)
        @ match (decnot a0) @ (c0 p0) @ match (decnot a1) @ (c1 p1)
        '($ch ,c1 ,c0 ': ,s$ (xtoIBytesSb12 ,a0 ,a1 ,c0 ,c1 ,k ,n ,s ,p0 ,p1 ,p))]
      [$h2n ,a0$ @ match (to-toIBytesb1 k '(h2n @ x0)) @ (s p)
        @ match (decnot a0) @ (c0 p0)
        '($ch ,'(xf) ,c0 ': ,s$ (xtoIBytesSb11 ,a0 ,c0 ,k ,s ,p0 ,p))]])

  --| `(to-iNBytes N a)` returns a pair `(s p)` where `p: s2n s = iNBytes a`
  --| assuming `N = 8,16,32,64`
  (def (to-iNBytes n a)
    (def k (sucs {n // 8}))
    @ match (match a
      [$0$ @ match (to-toBytes k '(h2n @ x0)) @ (s p) '(,s (xtoIBytes02 ,k ,s ,p))]
      [$b0 ,a$ @ match (to-toBytes k a) @ (s p) '(,s (xtoIBytesSb0_ ,k ,a (s2n ,s) ,p))]
      [$b1 ,a$ (to-toIBytesb1 k a)])
    [(s p) '(,s (,(atom-app 'xi n 'Bytes) ,a ,s ,p))])

  --| `(to-elBits4 k n)` proves `n e. Bits (4 * k)`
  (def (to-elBits4 k n) @ match k
    [$suc ,k$ @ match n
      [$,n :x ,a$ '(xelBits4S ,a ,k ,n ,(to-elBits4 k n))]
      [$h2n ,a$ '(xelBits41 ,a ,k)]])

  --| `(to-elBits8 k n)` proves `n e. Bits (8 * k)`
  (def (to-elBits8 k n) @ match k
    [$suc ,k$ @ match n
      [$,n :x ,a1 :x ,a0$ '(xelBits8S ,a0 ,a1 ,k ,n ,(to-elBits8 k n))]
      [$h2n ,a1 :x ,a0$ '(xelBits82 ,a0 ,a1 ,k)]
      [$h2n ,a0$ '(xelBits81 ,a0 ,k)]])

  --| `(to-elBits7 k n)` proves `n e. Bits (8 * k + 7)`
  (def (to-elBits7 k n) @ match n
    [$,n :x ,a1 :x ,a0$ @ match k
      [$suc ,k$ '(xelBits7S ,a0 ,a1 ,k ,n ,(to-elBits7 k n))]]
    [$h2n ,a1 :x ,a0$ @ match k
      [$suc ,k$ '(xelBits72S ,a0 ,a1 ,k)]
      [$0$ '(xelBits720 ,a0 ,a1 ,(atom-app 'declt (hexstring (hex->number a1)) 8))]]
    [$h2n ,a0$ '(xelBits71 ,a0 ,k)])

  --| `(to-elu N a)` returns a proof that `a` is a hex literal in uN: `a e. uN`
  --| assuming `N = 8,16,32,64`
  (def (to-elu n a)
    '(,(atom-app 'xelu n 'i) ,a ,(to-elBits8 (sucs {n // 8}) a)))

  --| `(to-eli N a)` returns a proof that `a` is a signed hex literal in uN: `a e. uN`
  --| assuming `N = 8,16,32,64`
  (def (to-eli n a) @ match a
    [$0$ '(,(atom-app 'd0elu n))]
    [$b0 ,a$ '(,(atom-app 'xelu n 'b0i) ,a ,(to-elBits7 (sucs {{n // 8} - 1}) a))]
    [$b1 ,a$ '(,(atom-app 'xelu n 'b1i) ,a ,(to-elBits7 (sucs {{n // 8} - 1}) a))])
};

----------------
-- ELF header --
----------------

local def _x00: char = 0;
local def _x01: char = 1;
local def _x02: char = 2;
local def _x00x2: string = $ _x00 ': _x00 ': s0 $;
local def _x00x4: string = $ _x00x2 '+ _x00x2 $;
local def _x00x8: string = $ _x00x4 '+ _x00x4 $;

theorem _x00_eq: $ _x00 = 0 $ = '{,norm_num : $ ch = _ $};
theorem _x01_eq: $ _x01 = 1 $ = '{,norm_num : $ ch = _ $};
theorem _x02_eq: $ _x02 = 2 $ = '{,norm_num : $ ch = _ $};

theorem _x00x2_eq: $ _x00x2 = repeat 0 2 $ =
'(s2n_RS _x00_eq @ s2n_RS _x00_eq @ s2n_R0);
theorem _x00x4_eq: $ _x00x4 = repeat 0 4 $ =
'(eqtr (s2n_RA _x00x2_eq _x00x2_eq) @ repeateq2 ,norm_num);
theorem _x00x8_eq: $ _x00x8 = repeat 0 8 $ =
'(eqtr (s2n_RA _x00x4_eq _x00x4_eq) @ repeateq2 ,norm_num);

local def ELF_IDENT_s: string =
$ ,0x7f ': ,"E" ': ,"L" ': ,"F" ':
  _x02 ': _x01 ': _x01 ': _x00 ': _x00x8 $;

theorem ELF_IDENT_eq: $ ELF_IDENT_s = ELF_IDENT $ =
'(s2n_SAE @ s2n_SAE @ s2n_SAE @ s2n_SAE @ append01i @
  s2n_S _x02_eq @ s2n_S _x01_eq @ s2n_S _x01_eq @
  s2n_RS _x00_eq _x00x8_eq);

local def _ch16 (c: char): string = $ c ': _x00 ': s0 $;
local def _ch32 (c: char): string = $ c ': _x00 ': _x00x2 $;
local def _ch64 (c: char): string = $ _ch32 c '+ _x00x4 $;

theorem _ch16_eq (h: $ c = a $): $ _ch16 c = u16Bytes a $ =
'(s2n_toBytesS0 h @ s2n_RS _x00_eq @ s2n_R0);
theorem _ch32_eq (h: $ c = a $): $ _ch32 c = u32Bytes a $ =
'(s2n_toBytesS0 h @ s2n_RS _x00_eq @ _x00x2_eq);
theorem _ch64_eq (h: $ c = a $): $ _ch64 c = u64Bytes a $ =
'(eqtr saddS @ s2n_toBytesS0 h @
  eqtr (s2n_RA (s2n_RS _x00_eq _x00x2_eq) @ _x00x4_eq) @
  repeateq2 ,norm_num);

--| `0x400000` as u64, the hard coded file start point
local def load_start_s (c: char): string = $ c ': _x00 ': ,0x40 ': _x00 ': _x00x4 $;
local def load_start (x y): nat = $ ,0x4000 :x x :x y $;
--| `0x400078`, the hard coded entry point
local def text_start: nat = $ load_start x7 x8 $;

theorem load_start_eq2: $ load_start x0 x0 + x :x y = load_start x y $ =
'(add_xx0 (add_x00 addx01) addx01);
theorem load_start_pow2: $ load_start x0 x0 = 2 ^ ,22 $ =
'(eqtr (x2powS @ x2powS @ x2powS @ x2powS @ x2powS @ eqtr2 d2pow2 dec4) @
  poweq2 ,norm_num);

theorem load_start_T: $ load_start x y e. u64 $ =
'(ssel u32ss64 @ xelu32i @ xelBits8S @ xelBits8S xelBits82);
theorem load_start_eq: $ load_start_s (ch x y) = u64Bytes (load_start x y) $ =
(focus
  '(xtoBytesS @ xtoBytesS @ eqtr _ @ toByteseq2 @ hexeq1 hex01_)
  '(xtoBytesS @ eqtr4 (s2n_RS _x00_eq _x00x4_eq) toBytes02));

local def ELF_header_s (e: string): string =
$ ELF_IDENT_s '+ _ch16 _x02 '+ _ch16 ,0x3e '+ _ch32 _x01 '+
  e '+ _ch64 ,64 '+ _x00x8 '+
  _x00x4 '+ _ch16 ,64 '+ _ch16 ,0x38 '+ _ch16 _x01 '+
  _ch16 ,64 '+ _x00x4 $;

theorem ELF_header_ok (he: $ e = u64Bytes entry $) (he2: $ entry e. u64 $):
  $ elfHeader (ELF_header_s e) entry 64 0 1 0 $ =
(focus
  (for 0 7 @ fn (_) (refine '(ian _ _)))
  (def h0 '(mpbir (eleq1 ,to_hex) xelu8_1))
  (def h1 '(mpbir (eleq1 ,to_hex) xelu8_2))
  (def h2 '(mpbir (lteq2 @ eqtr bitsNeg1 upto16) ,norm_num))
  (refine 'he2 '(ssel u8ss64 ,h1) 'elBits01
    '(ssel u8ss16 ,h0) h2 'elBits01 h2) (swap)
  '(ax_mp (iexe ,eqtac) @ ian elBits01 _)
  '(s2n_A ELF_IDENT_eq @ s2n_A (_ch16_eq _x02_eq) @
    s2n_A (_ch16_eq eqid) @ s2n_A (_ch32_eq _x01_eq) @
    s2n_A he @ s2n_A (_ch64_eq ,norm_num) @
    s2n_A (eqtr4 _x00x8_eq toBytes02) @ s2n_A (eqtr4 _x00x4_eq toBytes02) @
    s2n_A (! _ch16_eq $64$ _ ,norm_num) @ s2n_A (_ch16_eq eqid) @
    s2n_A (_ch16_eq _x01_eq) @ s2n_A (! _ch16_eq $64$ _ ,norm_num) @
    s2n_A (eqtr4 _x00x2_eq toBytes02) (eqtr4 _x00x2_eq toBytes02)));

local def PAGE_SIZE_s: string = $ _x00 ': _x00 ': ,0x20 ': _x00 ': _x00x4 $;
local def PAGE_SIZE: nat = $ 2 ^ ,21 $;
theorem PAGE_SIZE_val: $ PAGE_SIZE = ,0x200000 $ =
'(eqtr2 (x2powS @ x2powS @ x2powS @ x2powS @ x2powS @ eqtr2 pow12 dec2) @
  poweq2 ,norm_num);
theorem PAGE_SIZE_eq: $ PAGE_SIZE_s = u64Bytes PAGE_SIZE $ =
(focus
  '(eqtr4 _ @ u64Byteseq PAGE_SIZE_val)
  '(xtoBytesS @ xtoBytesS @ eqtr _ @ toByteseq2 @ hexeq1 hex01_)
  '(xtoBytesS @ eqtr4 (s2n_RS _x00_eq _x00x4_eq) toBytes02));

local def basic_pHeader_s (filesz memsz: string): string =
$ _ch32 _x01 '+ _ch32 ,7 '+
  _ch64 ,0x78 '+ load_start_s ,0x78 '+ _x00x8 '+
  filesz '+ memsz '+ PAGE_SIZE_s $;

local def PROT_RWX = $ 7 $;
theorem PROT_RWX_val: $ PROT_RWX = upto 3 $ =
'(mpbi addcan1 @ eqtr4 (eqtr4 add12 d2pow3) uptoadd1);
theorem ss_PROT_RWX: $ p e. Prot <-> p C_ PROT_RWX $ =
'(bitr4 elBits @ sseq2 @ nseq PROT_RWX_val);
theorem PROT_RWX_T: $ PROT_RWX e. Prot $ = '(mpbir ss_PROT_RWX ssid);
theorem PROT_RWX_R: $ PROT_READ C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_READ_T);
theorem PROT_RWX_W: $ PROT_WRITE C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_WRITE_T);
theorem PROT_RWX_X: $ PROT_EXEC C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_EXEC_T);
theorem PROT_RWX_flags: $ protToFlags PROT_RWX = 7 $ =
(focus
  '(eqtr (ifpos PROT_RWX_X) @ eqtr4 (b1eq _) d7half)
  '(eqtr (ifpos PROT_RWX_W) @ eqtr4 (b1eq _) d3half)
  '(ifpos PROT_RWX_R));

theorem basic_pHeader_ok
  (hfs: $ fs = u64Bytes filesz $)
  (hms: $ ms = u64Bytes memsz $)
  (hle: $ filesz <= memsz $)
  (hms2: $ memsz e. u64 $):
  $ pHeader (basic_pHeader_s fs ms) PT_LOAD PROT_RWX
      (ch x7 x8) text_start filesz memsz $ =
(focus
  (for 0 7 @ fn (_) (refine '(ian _ _)))
  (def h0 '(mpbir (eleq1 ,to_hex) xelu8_1))
  (def h1 '(mpbir (eleq1 ,to_hex) xelu8_2))
  (refine '(ssel u8ss32 {,h0 : $ 1 e. _ $}) 'PROT_RWX_T
    '(ssel u8ss64 ,h1) 'load_start_T '(Bitsle1 hle hms2) 'hms2 'hle)
  (have 'hM '(eqtr3 load_start_eq2 @ addeq load_start_pow2 @ eqcom c2nhex))
  '(ax_mp (iexe ,eqtac) @ ian
    (ian _ @ mpbir (dvdeq2 @
      eqtr (bitsSub_eq_sub (mpbir (leeq2 hM) leaddid2) load_start_T) @
      eqtr (subeq1 hM) pncan) @ powdvd _)
    (s2n_A (_ch32_eq _x01_eq) @
      s2n_A (_ch32_eq @ eqcom @ eqtr PROT_RWX_flags ,norm_num) @
      s2n_A (_ch64_eq eqid) @ s2n_A load_start_eq @
      s2n_A (eqtr4 _x00x8_eq toBytes02) @
      s2n_A hfs @ s2n_A hms PAGE_SIZE_eq))
  norm_num
  norm_num);

local def ELF_lit (e fs ms c: string): string =
$ ELF_header_s e '+ basic_pHeader_s fs ms '+ c $;

local def ELF_parse (entry bss: nat) (c: string): nat =
$ entry <> PROT_RWX <> text_start <> c ++ repeat 0 bss $;

local def ELF_lit_ok (elf: string) (entry bss: nat) (c: string) =
$ parseBasicElf elf entry PROT_RWX text_start (c ++ repeat 0 bss) $;

theorem ELF_lit_ok_isBasicElf (s entry bss c)
  (h: $ ELF_lit_ok s entry bss c $): $ isBasicElf s $ =
'(iexie @ iexde @ iexde @ iexde @ mpbiri h ,eqtac);

theorem basicElf_ok
  (he: $ e = u64Bytes entry $)
  (hfs: $ fs = u64Bytes filesz $)
  (hms: $ ms = u64Bytes memsz $)
  (hbss: $ filesz + bss = memsz $)
  (hlen: $ len c = filesz $)
  (hend: $ ,0x400078 + memsz = end $)
  (hea: $ text_start <= entry /\ entry < text_start + len c $)
  (hbd: $ end e. u64 $):
  $ ELF_lit_ok (ELF_lit e fs ms c) entry bss c $ =
(focus
  '(ian s2nT @ iexie ,(iterate 5 (fn (x) '(iexde ,x)) '(mpbiri _ ,eqtac)))
  (have 'h1 '(eqtr s2nsadd @ appendeq2 s2nsadd))
  (have 'he2 $ entry < end $
    '(ltletr (anr hea) @ mpbi (leeq2 hend) @ mpbi leadd2 @
      mpbir (leeq1 hlen) @ mpbi (leeq2 hbss) leaddid1))
  (have 'ehok '(ELF_header_ok he @ Bitsle1 (ltle he2) hbd))
  (have 'hl1 '(elArraylen @ an5l @ elfHeaderT ehok))
  (have 'phok '(basic_pHeader_ok
    (eqtr4 hfs @ u64Byteseq hlen)
    (eqtr4 hms @ u64Byteseq hbss)
    (mpbir (leeq1 hlen) leaddid1)
    (mpbir (eleq1 hbss) @ Bitsle1 (mpbi (leeq2 hend) leaddid2) hbd))) (swap)
  (have 'hl2 '(elArraylen @ an6l @ pHeaderT phok))
  (for 0 8 @ fn (_) (refine '(ian _ _)))
  (focus
    '(mpbir (sublistAteq2 h1) @ sublistAt_left sublistAt_id))
  (focus 'ehok)
  (focus
    '(mpbir (sublistAteq (eqtr2 add02 hl1) h1 eqid) @
      sublistAt_right @ sublistAt_left sublistAt_id))
  (focus 'phok)
  (focus
    '(mpbir (sublistAteq (eqtr2 (addeq hl1 @ eqtr add02 hl2)
        {,norm_num : $ 64 + ch x3 x8 = ch x7 x8 $}) h1 eqid) @
      sublistAt_right @ sublistAt_right sublistAt_id))
  (focus '(mpbir (eleq1 @ eqtr (addeq2 hbss) hend) hbd))
  (focus '(anl hea))
  (focus '(mpbir (lteq2 @ eqtr (addeq2 hbss) hend) he2))
  (focus '(appendeq2 @ repeateq2 @ eqtr2 (subeq2 hlen) pncan2)));

---------------
-- Assembler --
---------------

theorem splitBitsx0i: $ splitBits 0 x0 $ =
'(mpbir splitBits0 @ eqcom dec0);

theorem splitBitsSi
  (h1: $ a e. Bits k $) (h2: $ shl m k + a = n $) (h3: $ splitBits bs m $):
  $ splitBits ((k <> a) : bs) n $ =
'(mpbir splitBitsS @ iani h1 @ ax_mp (iexe ,eqtac) @ iani h2 h3);

theorem splitBits14i (a: hex): $ splitBits ((4 <> a) : 0) a $ = '(splitBits1i h2nT);
theorem splitBits14ie (x: hex) (h: $ a = x $): $ splitBits ((4 <> a) : 0) x $ =
'(mpbir (splitBitseq1 @ conseq1 @ preq2 h) splitBits14i);
theorem splitBitsS4i (h: $ splitBits bs n $): $ splitBits ((4 <> a) : bs) (n :x a) $ =
'(mpbir splitBitsS4 @ ax_mp (iexe ,eqtac) @ iani eqid h);

theorem splitBitsA4i
  (he: $ bs1 ++ bs2 = bs $) (hs: $ bvSize bs1 = 4 $)
  (h1: $ splitBits bs1 a $) (h2: $ splitBits bs2 n $):
  $ splitBits bs (n :x a) $ =
'(mpbi (splitBitseq1 he) @ mpbir (splitBitsA hs) @
  iexie @ mpbiri (ian h1 @ splitBitsS4i h2) ,eqtac);

theorem splitBitsA4ic
  (he: $ bs1 ++ bs2 = bs $) (hs: $ bvSize bs1 = 4 $)
  (h1: $ splitBits bs1 b $) (h2: $ splitBits bs2 a $):
  $ splitBits bs (ch a b) $ =
'(mpbir (splitBitseq2 c2nch) @ splitBitsA4i he hs h1 h2);

theorem splitBitsS1i (h0: $ bool x $)
  (hn: $ b0 n2 + x = n $) (h: $ splitBits bs n2 $):
  $ splitBits ((1 <> x) : bs) n $ =
'(splitBitsSi (mpbir elBits1 h0) (eqtr (addeq1 shl12) hn) h);

theorem splitBitsS1i0 (h1: $ n = b0 n2 $) (h2: $ splitBits bs n2 $):
  $ splitBits ((1 <> 0) : bs) n $ = '(splitBitsS1i bool0 (eqtr4 add0 h1) h2);
theorem splitBitsS1i1 (h1: $ n = b1 n2 $) (h2: $ splitBits bs n2 $):
  $ splitBits ((1 <> 1) : bs) n $ = '(splitBitsS1i bool1 (eqtr4 add12 h1) h2);

theorem splitBitsSSi (h0: $ bool x $)
  (ha: $ b0 a2 + x = a $) (hn: $ b0 n2 + x = n $)
  (h2: $ splitBits ((k <> a2) : bs) n2 $):
  $ splitBits ((suc k <> a) : bs) n $ =
(focus
  '(mpbi (splitBitseq1 @ conseq1 @ preq1 add11) @ mpbir splitBits_split @
    iexie @ iexde @ mpbiri _ ,eqtac)
  '(ian (eqtr (addeq1 shl12) ha) @ splitBitsS1i h0 hn h2));

theorem splitBitsSSi0 (ha: $ a = b0 a2 $) (hn: $ n = b0 n2 $)
  (h2: $ splitBits ((k <> a2) : bs) n2 $): $ splitBits ((suc k <> a) : bs) n $ =
'(splitBitsSSi bool0 (eqtr4 add0 ha) (eqtr4 add0 hn) h2);
theorem splitBitsSSi1 (ha: $ a = b1 a2 $) (hn: $ n = b1 n2 $)
  (h2: $ splitBits ((k <> a2) : bs) n2 $): $ splitBits ((suc k <> a) : bs) n $ =
'(splitBitsSSi bool1 (eqtr4 add12 ha) (eqtr4 add12 hn) h2);

theorem b0Bitsi (h1: $ a = b0 a2 $) (h2: $ a2 e. Bits n $): $ a e. Bits (suc n) $ =
'(mpbir (eleq1 h1) @ mpbi b0Bits h2);
theorem b1Bitsi (h1: $ a = b1 a2 $) (h2: $ a2 e. Bits n $): $ a e. Bits (suc n) $ =
'(mpbir (eleq1 h1) @ mpbi b1Bits h2);

do {
  (def (xsplitBits l i) (apply atom-app "xsplitBits_" (hexstring i) l))

  -- Adds theorems such as
  -- theorem xsplitBits_a121:
  --   $ splitBits ((1 <> 0) : (2 <> 1) : (1 <> 1) : 0) xa $;
  -- which decompose hex values into bits in different groupings.
  -- The naming system is 'xsplitBits_' + hex digit + partition,
  -- where partition is one of 13, 22, 31, 121, 1111 representing a partition of 4
  (scan '((1 3) (2 2) (3 1) (1 2 1) (1 1 1 1)) @ fn (l)
    @ for 0 16 @ fn (i)
      (def name (xsplitBits l i))
      @ letrec (
        [lhs @ match-fn*
          [(() _) $0$]
          [((k . xs) n)
            '(cons (pr (,(dn k)) (,(dn {n % {2 ^ k}})))
              ,(lhs xs {n shr k}))]]
        [f @ match-fn*
          [(() n) 'splitBitsx0i]
          [((k . xs) n)
            @ if {k = 1}
            '(,(atom-app 'splitBitsS1i {n % 2})
              ,(hexnhalf n) ,(f xs {n // 2}))
            '(,(atom-app 'splitBitsSSi {n % 2})
              ,(decnhalf {n % {2 ^ k}}) ,(hexnhalf n) ,(f (cons {k - 1} xs) {n // 2}))]])
      (add-tac-thm! name () ()
        '(splitBits ,(lhs l i) (,(hexdigit i))) () @ fn () (f l i)))

  --| `(mk-splitBits (x_1 ... x_k) i)` returns `(n_1 ... n_k p)` where
  --| `p: splitBits ((x_1 <> n_1) : ... : (x_k <> n_k) : 0) i`.
  --|
  --| Here the `x_i` are numbers (a partition of 4),
  --| the `n_i` are decimal numerals, and `i` is a number
  (def (mk-splitBits l i)
    @ letrec ([(f n xs) @ match xs
      [() '((,(xsplitBits l i)))]
      [(k . xs) '((,(dn {n % {2 ^ k}})) . ,(f {n // {2 ^ k}} xs))]])
    (f i l))

  --| `(merge-bits (x_1 ... x_k) n_1 ... n_k)` returns `(i p)` where
  --| `p: splitBits ((x_1 <> n_1) : ... : (x_k <> n_k) : 0) i`.
  --|
  --| Here the `x_i` are numbers (a partition of 4),
  --| the `n_i` are decimal numerals, and `i` is a number
  (def (merge-bits l . is)
    @ letrec ([f @ match-fn*
      [(() () i _) '(,i (,(xsplitBits l i)))]
      [((k . xs) ((a) . is) i m)
        @ f xs is {i + {(decdigit->number a) shl m}} {m + k}]])
    (f l is 0 0))
};

theorem bitb00i (h: $ a = b0 b $): $ bit a 0 = 0 $ = '(eqtr (biteq1 h) bitb00);
theorem bitb10i (h: $ a = b1 b $): $ bit a 0 = 1 $ = '(eqtr (biteq1 h) bitb10);
theorem bitb0Si (h: $ a = b0 b $) (h2: $ bit b n = c $): $ bit a (suc n) = c $ =
'(eqtr (biteq1 h) @ eqtr bitb0S h2);
theorem bitb1Si (h: $ a = b1 b $) (h2: $ bit b n = c $): $ bit a (suc n) = c $ =
'(eqtr (biteq1 h) @ eqtr bitb1S h2);

-- Adds theorems such as
-- theorem xbita3: $ bit xa 3 = 0 $;
-- which evaluate the bits of an individual hex digit.
-- Naming system is "xbit" + hex digit + index
do {
  (def (xbit n i) @ atom-app "xbit" (hexstring n) (hexstring i))
  (for 0 16 @ fn (n) @ for 0 4 @ fn (i)
    @ letrec ([(f n i)
      @ if {i = 0}
      '(,(atom-app "bitb" {n % 2} "0i") ,(hexnhalf n))
      '(,(atom-app "bitb" {n % 2} "Si")
        ,(hexnhalf n) ,(f {n // 2} {i - 1}))])
    (add-tac-thm! (xbit n i) () ()
      '(eq (bit (h2n (,(hexdigit n))) (,(dn i))) (,(dn {{n shr i} band 1}))) ()
      @ fn () (f n i)))
};

theorem REX_W_Si (h: $ bit rex 3 = a $): $ REX_W (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);
theorem REX_R_Si (h: $ bit rex 2 = a $): $ REX_R (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);
theorem REX_X_Si (h: $ bit rex 1 = a $): $ REX_X (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);
theorem REX_B_Si (h: $ bit rex 0 = a $): $ REX_B (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);

theorem rex_reg_i (h: $ splitBits ((3 <> r) : (1 <> b) : 0) n $):
  $ rex_reg b r = n $ =
'(eqtr3 (addeq1 @ shleq1 ofBits1) @ anri @ mpbi splitBitsS2 h);

theorem splitBits_332
  (h1: $ splitBits ((3 <> a) : (1 <> bl) : 0) y $)
  (h2: $ splitBits ((2 <> bh) : (2 <> c) : 0) x $):
  $ splitBits ((3 <> a) : (3 <> shl bh 1 + bl) : (2 <> c) : 0) (ch x y) $ =
(focus
  '(mpbi (splitBitseq1 @ eqtr append1 @ conseq2 @ conseq1 @ preq1 add11) @
    mpbir splitBits_mid @ iexie @ iexde @ mpbiri (ian eqid _) ,eqtac)
  '(splitBitsA4ic (eqtr4 (appendSi append1) append1) ,bvSizeSi h1 h2));

theorem splitBits_121_rex_reg
  (h1: $ splitBits ((1 <> bl) : (2 <> bh) : (1 <> r) : 0) rn $)
  (h2: $ rex = r $): $ rn = rex_reg rex (shl bh 1 + bl) $ =
(focus '(eqcom @ rex_reg_i @
  mpbi (splitBitseq1 @ conseq (preq1 add11) @ conseq1 @ preq2 @ eqcom h2) @
  mpbir splitBits_split @ iexie @ iexde @ mpbiri (ian eqid h1) ,eqtac));

theorem opSize_64: $ opSize r 1 1 = wSz64 $ = '(eqtr (ifpos true1) (ifpos true1));
theorem opSize_32: $ opSize r 0 1 = wSz32 $ = '(eqtr (ifpos true1) (ifneg true0));
theorem opSize_8: $ opSize r w 0 = wSz8 r $ = '(ifneg true0);

theorem opSizeW_0 (h: $ opSize F. 0 v = a $): $ opSizeW 0 v = a $ =
'(eqtr (opSizeeq (mpbir neqfal eqid) REX_W_0 eqid) h);
theorem opSizeW_S (h1: $ bit rex 3 = w $)
  (h2: $ opSize T. w v = a $): $ opSizeW (suc rex) v = a $ =
'(eqtr (opSizeeq (mpbir eqtru peano1) (eqtr (biteq1 sucsub1) h1) eqid) h2);

theorem readSIBDisplacement_0
  (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readSIBDisplacement 0 x5 (chopZ 64 a) 0 l $ =
(focus
  '(mpbir (ifppos @ ian h2n5 eqid) _)
  '(iexie @ mpbiri (iani (iani _ eqid) (eqtr h2 i32Bytes_val)) ,eqtac)
  '(iani chopZT @ eqcom @ sExt_chopZ @ iani d32le64 h1));

theorem readDisplacement_0: $ readDisplacement 0 0 s0 $ =
(named '(orl @ orl @ ian (ian eqid eqid) s2ns0));
theorem readDisplacement_8
  (h1: $ a e. u8 $) (h2: $ l = i8Bytes a $):
  $ readDisplacement 1 (chopZ 64 a) l $ =
(named @ focus
  '(orl @ orr @ iexie @ mpbiri (ian _ @ eqtr h2 i8Bytes_val) ,eqtac)
  '(ian (ian chopZT eqid) @ eqcom @ sExt_chopZ @ iani d8le64 h1));
theorem readDisplacement_32
  (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readDisplacement 2 (chopZ 64 a) l $ =
(named @ focus
  '(orr @ iexie @ mpbiri (ian _ @ eqtr h2 i32Bytes_val) ,eqtac)
  '(ian (ian chopZT eqid) @ eqcom @ sExt_chopZ @ iani d32le64 h1));

theorem readSIBDisplacement_reg
  (h1: $ bbase != x5 \/ 0 < md $)
  (h2: $ readDisplacement md q l $):
  $ readSIBDisplacement md bbase q (base_reg bbase) l $ =
(named '(mpbir (ifpneg @ mpbir notan @ mpbi (oreq (neeq2 h2n5) lt01) h1) @ ian h2 eqid));

theorem readModRM2_reg (h1: $ REX_B rex = b $) (h2: $ rex_reg b rm2 = r $):
  $ readModRM2 rex (RM_reg r) rm2 3 s0 $ =
(named '(mpbir (ifppos eqid) @ ian (RM_regeq @ eqtr2 (rex_regeq1 h1) h2) s2ns0));
theorem readModRM2_rip
  (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readModRM2 rex (RM_mem 0 base_RIP (chopZ 64 a)) 5 0 l $ =
(named '(mpbir (ifpneg @ ltne d0lt3) @ mpbir (ifppos @ ian eqid eqid) @
  iexie @ mpbiri (ian (ian chopZT @ RM_memeq3 @
    eqcom @ sExt_chopZ @ iani d32le64 h1) @ eqtr h2 i32Bytes_val) ,eqtac));
theorem readModRM2_sib (h: $ readSIB rex md rm l $):
  $ readModRM2 rex rm 4 md l $ =
(named '(mpbir (ifpneg @ anllr @ readSIB_T h) @
  mpbir (ifpneg @ mt anl {,norm_num : $ 4 != 5 $}) @ mpbir (ifppos eqid) h));
theorem readModRM2_mem
  (h1: $ REX_B rex = b $) (h2: $ rex_reg b rm2 = r $)
  (h3: $ rm2 != x4 $)
  (h4: $ rm2 != x5 \/ 0 < md $)
  (h5: $ readDisplacement md disp l $):
  $ readModRM2 rex (RM_mem 0 (base_reg r) disp) rm2 md l $ =
(named '(mpbir (ifpneg @ anllr @ readDisplacementT h5) @
  mpbir (ifpneg @ mpbir notan @ mpbi (oreq (neeq2 h2n5) lt01) h4) @
  mpbir (ifpneg @ mpbi (neeq2 h2n4) h3) @
  iexie @ mpbiri (ian h5 @ RM_memeq2 @ base_regeq @ eqtr2 (rex_regeq1 h1) h2) ,eqtac));

theorem readSIB_I
  (h1: $ splitBits ((3 <> bs) : (1 <> ixl) : 0) y $)
  (h2: $ splitBits ((2 <> ixh) : (2 <> sc) : 0) x $)
  (h3: $ REX_X rex = rx $)
  (h4: $ splitBits ((1 <> ixl) : (2 <> ixh) : (1 <> rx) : 0) index $)
  (h5: $ REX_B rex = rb $)
  (h6: $ splitBits ((3 <> bs) : (1 <> rb) : 0) bbase $)
  (h7: $ readSIBDisplacement md bbase disp base l $)
  (h8: $ if (index = RSP) 0 (suc (sc <> index)) = osi $):
  $ readModRM2 rex (RM_mem osi base disp) 4 md (ch x y ': l) $ =
(focus
  '(readModRM2_sib @ iexie ,(iterate 7 (fn (x) '(iexde ,x)) '(mpbiri _ ,eqtac)))
  '(iani (iani (iani _ _) _) s2nscons)
  '(iani (splitBits_332 h1 h2) (splitBits_121_rex_reg h4 h3))
  '(mpbir (readSIBDisplacementeq2 @ eqtr (rex_regeq1 h5) @ rex_reg_i h6) h7)
  '(RM_memeq1 @ eqcom h8));

theorem readSIB_0
  (h1: $ splitBits ((3 <> bs) : (1 <> 0) : 0) y $)
  (h2: $ splitBits ((2 <> 2) : (2 <> sc) : 0) x $)
  (h3: $ REX_X rex = 0 $)
  (h5: $ REX_B rex = rb $)
  (h6: $ splitBits ((3 <> bs) : (1 <> rb) : 0) bbase $)
  (h7: $ readSIBDisplacement md bbase disp base l $):
  $ readModRM2 rex (RM_mem 0 base disp) 4 md (ch x y ': l) $ =
'(readSIB_I h1 h2 h3 xsplitBits_4121 h5 h6 h7 @ ifpos h2n4);

theorem readSIB_S
  (h1: $ splitBits ((3 <> bs) : (1 <> ixl) : 0) y $)
  (h2: $ splitBits ((2 <> ixh) : (2 <> sc) : 0) x $)
  (h3: $ REX_X rex = rx $)
  (h4: $ splitBits ((1 <> ixl) : (2 <> ixh) : (1 <> rx) : 0) index $)
  (h5: $ REX_B rex = rb $)
  (h6: $ splitBits ((3 <> bs) : (1 <> rb) : 0) bbase $)
  (h7: $ readSIBDisplacement md bbase disp base l $)
  (h8: $ index != x4 $):
  $ readModRM2 rex (RM_mem (suc (sc <> index)) base disp) 4 md (ch x y ': l) $ =
'(readSIB_I h1 h2 h3 h4 h5 h6 h7 @ ifneg @ mpbi (neeq2 h2n4) h8);

theorem readModRM_I
  (h1: $ splitBits ((3 <> rm2) : (1 <> o) : 0) y $)
  (h2: $ splitBits ((2 <> pc) : (2 <> md) : 0) x $)
  (h3: $ REX_R rex = r $)
  (h4: $ splitBits ((1 <> o) : (2 <> pc) : (1 <> r) : 0) rn $)
  (h5: $ readModRM2 rex rm rm2 md l $):
  $ readModRM rex rn rm (ch x y ': l) $ =
(focus
  '(mpbir readModRM_val @ iexie @ iexde @ iexde @ iexde @
    mpbiri (ian (ian (splitBits_332 h1 h2) (splitBits_121_rex_reg h4 h3)) _) ,eqtac)
  '(iexie @ mpbiri (ian s2nscons h5) ,eqtac));

theorem readOpcodeModRM_I
  (h1: $ splitBits ((3 <> rm2) : (1 <> o) : 0) y $)
  (h2: $ splitBits ((2 <> pc) : (2 <> md) : 0) x $)
  (h3: $ splitBits ((1 <> o) : (2 <> pc) : (1 <> 0) : 0) opc $)
  (h4: $ readModRM2 rex r rm2 md l $):
  $ readOpcodeModRM rex opc r (ch x y ': l) $ =
(focus
  (suffices 'h '{_ :
    $ splitBits ((1 <> o) : (2 <> pc) : (1 <> REX_R rex) : 0) (shl (REX_R rex) 3 + opc) /\
      opc = chop 3 (shl (REX_R rex) 3 + opc) $})
  '(iexie @ mpbiri (iani (readModRM_I h1 h2 eqid (anl h) h4) (anr h)) ,eqtac)
  (have 'sp $ E. a (
      splitBits ((1 <> o) : (2 <> pc) : 0) a /\
      splitBits ((3 <> a) : (1 <> 0) : 0) opc) $
   '(mpbi (splitBitsA @ eqtr4 ,bvSizeSi dec3) @
    mpbir (splitBitseq1 @ appendSi append1) h3))
  '(eex (imp @ syl5bi splitBitsS @ impd @ exp @ !! eexd z @ syl5 _ _) sp)
  '(impcom @ bi2d @ eqeq1d @ syl5eqr add01 @ addeq1d @
    syl5eqr shl01 @ shleq1d @ sylbi splitBits1 anr)
  '(syl5ibrcom (rsyl eqcom ,eqtac) @
    mpand (sylibr splitBitsS @ iand anr @ iexde @
      mpbird ,eqtac @ a1i @ ian eqid @ splitBits1i @ mpbir elBits1 REX_R_T) @
    iand _ @ eqcomd @ anld @ sylib splitBitsS_uniq anr)
  '(sylib (splitBitseq1 @ appendSi append1) @
    sylibr (splitBitsA @ eqtr4 ,bvSizeSi dec3) @
    iexde @ mpbird ,eqtac @ iand an3l anlr));

theorem readImmN_I (h1: $ 8 * i = k $) (h2: $ k <= 64 $)
  (h3: $ a e. Bits k $) (h4: $ s2n l = toIBytes i a $):
  $ readImmN k (chopZ 64 a) l $ =
(focus
  '(iexie @ mpbiri (ian _ _) ,eqtac)
  '(ian chopZT @ eqcom @ sExt_chopZ @ iani h2 h3)
  '(eqtr h4 @ toByteseq (eqtr3 (muldiv2 peano1) (diveq1 h1)) (chopZeq1 h1)));

theorem readFullImmI (h1: $ 8 * i = k $)
  (hs: $ sz e. WSize $) (h2: $ wsizeBits sz = k $)
  (h3: $ a e. Bits k $) (h4: $ s2n l = toIBytes i a $):
  $ readFullImm sz (chopZ 64 a) l $ =
'(mpbir (readImmNeq1 h2) @ readImmN_I h1
  (mpbi (leeq1 h2) @ wsizeBitsle64 hs) h3 h4);

theorem readFullImm32I (h1: $ a e. u32 $) (h2: $ s2n l = i32Bytes a $):
  $ readFullImm wSz32 (chopZ 64 a) l $ =
'(readFullImmI d8mul4 wSz32T wSz32Bits h1 h2);

theorem readFullImm64I (h1: $ a e. u64 $) (h2: $ s2n l = i64Bytes a $):
  $ readFullImm wSz64 (chopZ 64 a) l $ =
'(readFullImmI d8mul8 wSz64T wSz64Bits h1 h2);

theorem decodeI
  (h1: $ readPrefixes rex l1 $)
  (h2: $ decodeAux rex ast opc l2 $)
  (he: $ l1 ++ opc : l2 = l $):
  $ decode ast l $ =
'(iexie @ iexde @ iexde @ iexde @
  mpbiri (iani (iani (eqcom he) h1) h2) ,eqtac);

theorem decode0I (h: $ decodeAux 0 ast opc s $): $ decode ast (opc ': s) $ =
(named '(decodeI (orl @ ian eqid eqid) h @ eqtr4 append0 s2nscons));

theorem decode1I
  (h: $ decodeAux (suc rex) ast opc s $):
  $ decode ast (ch x4 rex ': opc ': s) $ =
'(decodeI (orr @ iexie @ iexde @
  mpbiri (ian (ian (splitBitsS4i @ splitBits14ie dec4) eqid) eqid) ,eqtac) h @
  eqtr4 append1 @ eqtr s2nscons @ conseq c2nhex s2nscons);

theorem decodeAux_s1
  (h: $ decodeAux rex ast opc (c ': s0) $):
  $ decodeAux rex ast opc (s1 c) $ = '(mpbi (decodeAuxeq4 s2nscons0) h);

theorem decodeBinopI (h: $ decodeBinop rex ast b l $): $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orl @ orl @ orl h);
theorem decodeMovI   (h: $ decodeMov rex ast b l $):   $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orl @ orl @ orr h);
theorem decodePushI  (h: $ decodePush rex ast b l $):  $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orl @ orr h);
theorem decodePopI   (h: $ decodePop rex ast b l $):   $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orr h);
theorem decodeFlowI  (h: $ decodeFlow rex ast b l $):  $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orr h);
theorem decodeMiscI  (h: $ decodeMisc rex ast b l $):  $ decodeAux rex ast b l $ = '(orl @ orl @ orr h);
theorem decodeHiI    (h: $ decodeHi rex ast b l $):    $ decodeAux rex ast b l $ = '(orl @ orr h);

theorem decodeMovRegI
  (h1: $ splitBits ((1 <> v) : (1 <> d) : (2 <> 2) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readModRM rex reg r (s2n l) $)
  (h4: $ if (true d) (R_rm reg r) (Rm_r r reg) = ds $):
  $ decodeAux rex (xastMov sz ds) (ch x8 a) l $ =
(focus
  '(decodeMovI @ orl @ orl @ orr @ iexie @ iexde @ iexde @ iexde @
    mpbiri (iani (iani _ h3) @ eqcom @ xastMoveq h2 h4) ,eqtac)
  '(splitBitsA4ic (appendSi @ appendSi append1) ,bvSizeSi h1 @ splitBits14ie dec8));

theorem decodeMovRMI
  (h1: $ splitBits ((1 <> v) : (1 <> 1) : (2 <> 2) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readModRM rex reg r (s2n l) $):
  $ decodeAux rex (xastMov sz (R_rm reg r)) (ch x8 a) l $ =
'(decodeMovRegI h1 h2 h3 @ ifpos true1);

theorem decodeMovMRI
  (h1: $ splitBits ((1 <> v) : (1 <> 0) : (2 <> 2) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readModRM rex reg r (s2n l) $):
  $ decodeAux rex (xastMov sz (Rm_r r reg)) (ch x8 a) l $ =
'(decodeMovRegI h1 h2 h3 @ ifneg true0);

theorem decodeMov64I
  (h1: $ splitBits ((3 <> r) : (1 <> v) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readFullImm sz (chopZ 64 imm) (s2n l) $)
  (h4: $ REX_B rex = rb $)
  (h5: $ splitBits ((3 <> r) : (1 <> rb) : 0) (h2n r2) $):
  $ decodeAux rex (xastMov sz (Rm_i (RM_reg r2) (chopZ 64 imm))) (ch xb a) l $ =
(focus
  '(decodeMovI @ orl @ orr @ iexie @ iexde @ iexde @
    mpbiri (iani (iani _ _) _) ,eqtac)
  '(splitBitsA4ic (appendSi append1) ,bvSizeSi h1 @ splitBits14ie decb)
  '(mpbir (readFullImmeq1 h2) h3)
  '(eqcom @ xastMoveq h2 @ Rm_ieq1 @ RM_regeq @
    eqtr (rex_regeq1 h4) @ rex_reg_i h5));

theorem decodeMovImmI
  (h1: $ splitBits ((1 <> v) : (3 <> 3) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readOpcodeModRM rex opc r l1 $)
  (h4: $ readImm sz imm l2 $):
  $ decodeAux rex (xastMov sz (Rm_i r imm)) (ch xc a) (l1 '+ l2) $ =
(focus
  '(decodeMovI @ orr @ iexie ,(iterate 5 (fn (x) '(iexde ,x))
    '(mpbiri (iani (iani (iani (iani s2nsadd _) h3) _) _) ,eqtac)))
  '(splitBitsA4ic (appendSi append1) ,bvSizeSi h1 @ splitBits14ie decc)
  '(mpbir (readImmeq1 h2) h4)
  '(eqcom @ xastMoveq1 h2));

theorem decodeTwoI (h: $ ,(foldr '(2 2 2 2 6) (get-decl 'decodeTwo) nth) $):
  $ decodeAux rex ast (ch x0 xf) (b2 ': l2) $ =
'(orr @ iani eqid @ iexie @ iexde @ mpbiri (iani s2nscons h) ,eqtac);

theorem decodeSysCallI: $ decode xastSysCall (ch x0 xf ': s1 (ch x0 x5)) $ =
'(decode0I @ decodeAux_s1 @ decodeTwoI @ orr @ iani (iani eqid s2ns0) eqid);

------------
-- Linker --
------------

local def assembled (c s: string) (start end: nat): wff =
$ end = start + len s /\ E. n (start = text_start + n /\ sublistAt n c s) $;

theorem assembled_start (h: $ assembled c s x y $): $ text_start <= x $ =
(named '(eex (anwl @ mpbiri leaddid1 leeq2) @ anr h));

theorem assembled_end (h: $ assembled c s x y $): $ y <= text_start + len c $ =
(named @ focus
  '(mpbir (leeq1 @ anl h) @ eex _ @ anr h)
  '(mpbird (leeq1d @ syl6eq addass @ addeq1d anl) @
    sylib leadd2 @ anwr sublistAt_len_le));

local def assembled_func (c s: string) (start end: nat): wff =
$ assembled c s start end /\ start < end $;

theorem assembled_func_lt (h: $ assembled_func c s x y $): $ x < text_start + len c $ =
'(ltletr (anr h) (assembled_end @ anl h));

theorem assembled_func_bound (h: $ assembled_func c s x y $):
  $ text_start <= x /\ x < text_start + len c $ =
'(ian (assembled_start @ anl h) @ assembled_func_lt h);

local def assembles (c s: string) (start end: nat) (p q: wff): wff =
$ E. n (start = text_start + n /\ sublistAt n c s) /\ p -> end = start + len s /\ q $;

theorem assembles_trul (h: $ assembles c s x y p (T. /\ q) $):
  $ assembles c s x y p q $ = (named '(sylib (aneq2i @ bian1 itru) h));
theorem assembles_assoc (h: $ assembles c s x y p (q1 /\ q2 /\ q3) $):
  $ assembles c s x y p (q1 /\ (q2 /\ q3)) $ = (named '(sylib (aneq2i anass) h));

local def assemble1 (s: string) (start end: nat): wff =
$ end = start + len s $;

theorem assemble1_0: $ assemble1 s0 x x $ =
'(eqtr2 (addeq2 @ eqtr (leneq s2ns0) len0) add02);
theorem assemble1_1 (h1: $ suc x = y $): $ assemble1 (s1 c) x y $ =
'(eqtr2 (addeq2 @ eqtr (leneq s2ns1) len1) @ eqtr add12 h1);
theorem assemble1_A_lem: $ y = x + len s -> z = y + len t -> u = s ++ t -> z = x + len u $ =
'(exp @ exp @ eqtrd anlr @ eqtr4d (anwll addeq1) @
  syl6eqr addass @ addeq2d @ syl6eq appendlen @ leneqd anr);
theorem assemble1_A (h1: $ assemble1 s x y $) (h2: $ assemble1 t y z $): $ assemble1 (s '+ t) x z $ =
'(assemble1_A_lem h1 h2 s2nsadd);
theorem assemble1_S (h1: $ suc x = y $) (h2: $ assemble1 s y z $): $ assemble1 (c ': s) x z $ =
'(assemble1_A (assemble1_1 h1) h2);

--| `(mk-asm1 x s)` returns a pair `(y p)` where `p: assemble1 s x y`
do (def (mk-asm1 x s) @ match s
  [('scons c s)
    @ match (mksuc x) @ (y p)
    @ match (mk-asm1 y s) @ (z p2)
    '(,z (assemble1_S ,c ,s ,x ,y ,z ,p ,p2))]
  [('sadd s t)
    @ match (mk-asm1 x s) @ (y p)
    @ match (mk-asm1 y t) @ (z p2)
    '(,z (assemble1_A ,s ,t ,x ,y ,z ,p ,p2))]
  [('s1 c) @ match (mksuc x) @ (y p) '(,y (assemble1_1 ,c ,x ,y ,p))]
  ['(s0) '(,x (assemble1_0 ,x))]);

local def assembles_func (s: string) (start end: nat): wff =
$ assemble1 s start end /\ start < end $;

theorem assembles_func_I (h: $ assemble1 (c ': s '+ t) x y $):
  $ assembles_func (c ': s '+ t) x y $ =
'(iani h @ mpbir (lteq (eqcom add0) h) @ mpbi ltadd2 @ mpbir (lteq2 @
    eqtr (leneq @ eqtr s2nsadd @ eqtr (appendeq1 s2nscons) appendS) lenS) lt01S);

theorem assemble_1 (h: $ assemble1 s x y $): $ assembles c s x y p (p /\ assembled c s x y) $ =
(named '(iand (a1i h) @ iand anr (iand (a1i h) anl)));

theorem assemble_func (h: $ assembles_func s x y $):
  $ assembles c s x y p (p /\ assembled_func c s x y) $ =
(named '(sylibr (aneq2i @ aneq2i @ bian2 @ anr h) @ assemble_1 @ anl h));

theorem assemblesA
  (h1: $ assembles c s x y p q $)
  (h2: $ assembles c t y z q r $):
  $ assembles c (s '+ t) x z p r $ =
(named @ focus
  (have 'h3 '(bitr (sublistAteq3 s2nsadd) sublistAt_append))
  '(mpand (syl h1 @ anim1 @ eximi @ anim2 @ sylbi h3 anl) @
    mpand (syl h2 @ sylbir anass @ anim1 @ impcom @ syl5 anl @
      eexda @ iexde @ mpbird ,eqtac @ anwl @
      iand (syl6eq addass @ addeq1d anrl) @ rsyl anrr @ sylbi h3 anr) @
    iand (eqtrd anrl @ syl6eqr (addeq2 @ eqtr (leneq s2nsadd) appendlen) @
      syl6eq addass @ addeq1d @ anwl anrl) anrr));

theorem assembles0: $ assembles c s0 x x p p $ =
(named '(anim1 @ a1i assemble1_0));

theorem assembles_finish
  (h1: $ assembles c c ,0x400078 end T. p $)
  (h2: $ ,0x400078 + n = end $):
  $ len c = n /\ p $ =
(focus
  '(anim1 (eqcomd @ sylib addcan2 @ eqtrd (a1i h2) id) @ h1 @
    ian (iexe _ @ ian (eqcom add02) sublistAt_id) itru)
  eqtac);

-------------------------------
-- Control flow graph layout --
-------------------------------

@_ local def CFG_ok: set = $ S\ s, S\ l, S\ x, {y | y = x + len s} $;

theorem CFG_ok_i: $ A C_ CFG_ok -> s <> l <> x <> y e. A -> y = x + len s $ =
(focus '(syl6ib _ ssel) '(elsabe @ elsabed @ elsabed @ elabed ,eqtac));

theorem mk_CFG_ok (p: wff s l x y) (h: $ p -> y = x + len s $):
  $ S\ s, S\ l, S\ x, {y | p} C_ CFG_ok $ =
'(sabssi @ sabssi @ sabssi @ mpbi ssab @ ax_gen h);

local def sat_CFG (s t: string) (l x y: nat) (A: set): wff =
$ A C_ CFG_ok /\ E. u (s = u ++ t /\ u <> l <> x <> y e. A) $;

theorem sat_CFG_i (p: wff s l x y) (x2)
  (h1: $ p -> y = x + len s $) (h2: $ s2 = u2 ++ t2 $)
  (h3: $ s = u2 /\ l = l2 /\ x = x2 /\ y = y2 -> (p <-> q) $) (h4: $ q $):
  $ sat_CFG s2 t2 l2 x2 y2 (S\ s, S\ l, S\ x, {y | p}) $ =
'(iani (mk_CFG_ok h1) @ iexie @
  mpbiri (iani h2 @ mpbir (elsabe @ elsabed @ elsabed @ elabed h3) h4) ,eqtac);

local def sat_CFG_func (s: string) (x: nat) (A: set): wff =
$ E. y sat_CFG s s0 0 x y A $;
theorem sat_CFG_func_i (h: $ sat_CFG s s0 0 x y A $):
  $ sat_CFG_func s x A $ = (named '(iexie @ mpbiri h @ aneq2d ,eqtac));
theorem sat_CFG_func_iff (h: $ assemble1 s x y $):
  $ sat_CFG_func s x A <-> A C_ CFG_ok /\ s <> 0 <> x <> y e. A $ =
'(bitr exan1 @ aneq2a @
  syl5bb (exeqi @
    bitr (exeqi @ aneq1i @ bitr eqcomb @ eqeq1 @ eqtr (appendeq2 s2ns0) append02) @
    exeqe ,eqtac) @
  bitr3d (exeqd @ syl bian1a @ syl6ibr (eqeq2 h) CFG_ok_i) @
  a1i @ exeqe ,eqtac);

@_ local def CFG0: set = $ S\ s, S\ l, S\ x, {y | s = 0 /\ y = x} $;
theorem sat_CFG0: $ sat_CFG s s l x x CFG0 $ =
'(sat_CFG_i
  (eqtr4d anr @ syl6eq add0 @ addeq2d @ syl6eq len0 @ leneqd anl)
  (eqcom append0) ,eqtac @ iani eqid eqid);

@_ local def CFG1 (ast: nat): set =
$ S\ s, S\ l, S\ x, {y | decode ast s /\ y = x + len s} $;
theorem CFG1_ok: $ CFG1 ast C_ CFG_ok $ = (named '(mk_CFG_ok anr));
theorem sat_CFG1 (h1: $ assemble1 s x y $) (h2: $ decode ast s $):
  $ sat_CFG (s '+ t) t l x y (CFG1 ast) $ =
'(sat_CFG_i anr s2nsadd ,eqtac @ iani h2 h1);

@_ local def CFG_seq (A B: set): set =
$ S\ s, S\ l, S\ x, {y | E. t1 E. t2 E. z (s = t1 ++ t2 /\
  t1 <> l <> x <> z e. A /\ t2 <> l <> z <> y e. B)} $;
theorem sat_CFG_seq (h1: $ sat_CFG s t l x y A $) (h2: $ sat_CFG t u l y z B $):
  $ sat_CFG s u l x z (CFG_seq A B) $ =
(named @ focus
  '(iani (mk_CFG_ok _) @ eex (mpi (anri h2) @ eexda _) @ anri h1)
  '(eex @ eex @ eex @ mpd anll @ sylc assemble1_A_lem
    (rsyl anlr @ CFG_ok_i @ anli h1) (anwr @ CFG_ok_i @ anli h2))
  '(sylan (iexe ,eqtac) (syl6eqr appendass @ eqtrd anll @ appendeq2d anrl) @
    sylibr (elsabe @ elsabed @ elsabed @ elabed ,eqtac) @
    syl (trud @ iexdde @ iexdde @ iexdde @ bi2d ,eqtac) @
    iand (iand eqidd anlr) anrr));

@_ local def CFG_S (ast: nat) (A: set): set = $ CFG_seq (CFG1 ast) A $;
theorem sat_CFG_S (h1: $ assemble1 s x y $) (h2: $ decode ast s $)
  (h3: $ sat_CFG t u l y z A $): $ sat_CFG (s '+ t) u l x z (CFG_S ast A) $ =
'(sat_CFG_seq (sat_CFG1 h1 h2) h3);

@_ local def CFG_scope (A: set): set =
$ S\ s, S\ l, S\ x, {y | E. a (s <> (a : l) <> x <> y e. A)} $;
theorem sat_CFG_scope (h: $ sat_CFG s t (a : l) x y A $):
  $ sat_CFG s t l x y (CFG_scope A) $ =
(named @ focus
  '(iani (mk_CFG_ok @ eex @ CFG_ok_i @ anli h) @ eex _ @ anri h)
  '(syl (iexe ,eqtac) @ anim2 @
    sylibr (elsabe @ elsabed @ elsabed @ elabed ,eqtac) @
    iexe ,eqtac));

@_ local def CFG_label: set =
$ S\ s, S\ l, S\ x, {y | s = 0 /\ y = x /\ E. l2 l = x : l2} $;
theorem sat_CFG_label: $ sat_CFG s s (x : l) x x CFG_label $ =
(named '(sat_CFG_i
  (eqtr4d anlr @ syl6eq add0 @ addeq2d @ syl6eq len0 @ leneqd anll)
  (eqcom append0) ,eqtac @ iani (iani eqid eqid) @ iexie @ eqcomd conseq2));

@_ local def CFG_lift (A: set): set =
$ S\ s, S\ l, S\ x, {y | E. a E. l2 (l = a : l2 /\ s <> l2 <> x <> y e. A)} $;
theorem sat_CFG_lift (h: $ sat_CFG s t l x y A $):
  $ sat_CFG s t (a : l) x y (CFG_lift A) $ =
(named @ focus
  '(iani (mk_CFG_ok @ eex @ eex @ anwr @ CFG_ok_i @ anli h) @ eex _ @ anri h)
  '(syl (iexe ,eqtac) @ anim2 @
    sylibr (elsabe @ elsabed @ elsabed @ elabed ,eqtac) @
    iexde @ iexde @ mpbird ,eqtac @ iand eqidd anll));

@_ local def CFG_block (A B: set): set =
$ CFG_seq (CFG_scope (CFG_seq A CFG_label)) B $;
theorem sat_CFG_block (h1: $ sat_CFG s t (y : l) x y A $) (h2: $ sat_CFG t u l y z B $):
  $ sat_CFG s u l x z (CFG_block A B) $ =
'(sat_CFG_seq (sat_CFG_scope @ sat_CFG_seq h1 sat_CFG_label) h2);

@_ local def CFG_loop (A B: set): set =
$ CFG_seq (CFG_scope (CFG_seq CFG_label A)) B $;
theorem sat_CFG_loop (h1: $ sat_CFG s t (x : l) x y A $) (h2: $ sat_CFG t u l y z B $):
  $ sat_CFG s u l x z (CFG_loop A B) $ =
'(sat_CFG_seq (sat_CFG_scope @ sat_CFG_seq sat_CFG_label h1) h2);

@_ local def CFG_ex (p: wff x) (A: set x): set = $ {z | E. x (p /\ z e. A)} $;
theorem sat_CFG_ex (p: wff a) (A: set a)
  (e1: $ a = b -> (p <-> q) $) (e2: $ a = b -> A == B $)
  (h1: $ q $) (h2: $ A C_ CFG_ok $) (h3: $ sat_CFG s t l x y B $):
  $ sat_CFG s t l x y (CFG_ex a p A) $ =
(named '(iani (mpbi ssab1 @ ax_gen @ eex @ anwr @ ssel h2) @
  eximi (anim2 @ ssel @ mpbi ssab2 @
    ax_gen @ exp (iexe @ aneqd e1 @ eleq2d e2) h1) (anri h3)));

-- @_ local def CFG_mov (sz dest src: nat) (A: set): set =
-- $ CFG_seq (CFG_ex ds (destsrcIRM ds = dest <> src) (CFG1 (xastMov sz ds))) A $;
-- theorem sat_CFG_mov (e: $ destsrcIRM ds = dest <> src $)
--   (h1: $ assemble1 s x y $) (h2: $ decode (xastMov sz ds) s $)
--   (h3: $ sat_CFG t u l y z A $): $ sat_CFG (s '+ t) u l x z (CFG_mov sz dest src A) $ =
-- '(sat_CFG_seq (sat_CFG_ex ,eqtac ,eqtac e CFG1_ok @ sat_CFG1 h1 h2) h3);

do {
  --| Builds a sequence of applications of `push` and `reassoc` to `x1` that
  --| would construct a balanced binary tree with `n > 0` nodes assuming
  --| `x1 = ()`, `(push 'x) = '(x ())` and `(reassoc '((a b) c)) = '(a (b c))`.
  --| (However since the actual data is simply threaded through, the functions
  --| may have additional side state, or may not be tree operations at all.)
  --|
  --| Ex:
  --| ```
  --| do {
  --|   (def (push x) '(,x a))
  --|   (def reassoc @ match-fn ['((,x ,y) ,z) '(,x (,y ,z)])
  --|   (ra-list 'a push reassoc 8)
  --|     -- (((a a) (a a)) ((a a) (a a)))
  --| };
  --| ```
  (def (ra-list x1 push reassoc n)
    @ letrec (
      [(right n x) @ if {n = 1} (push x) @ let ([m {n // 2}])
        @ reassoc @ right m @ right {n - m} x]
      [(left n) @ if {n = 1} x1 @ let ([m {n // 2}])
        @ right m @ left {n - m}])
    (left n))

  --| Like `(ra-list)`, but supports additionally the `n = 0` case. Here the base case
  --| for n = 0 is `x0`, `push` and `reassoc` have the same behavior, and `merge1`
  --| is called on the n = 1 case on `push x0`, for instance if `x0 = 0` then
  --| `merge1` might be defined such that `(merge1 '(0 ())) = ()`.
  (def (ra-list0 x0 push merge1 reassoc n)
    @ if {n = 0} x0 (ra-list (merge1 @ push x0) push reassoc n))

  --| `(reg-idx)` converts atoms denoting x86 registers
  --| like 'rax, 'rcx, and 'r14 into their indexes.
  (def reg-idx @ lookup-fn @ append
    '([rax 0] [rcx 1] [rdx 2] [rbx 3] [rsp 4] [rbp 5] [rsi 6] [rdi 7])
    (rmap (range 0 15) @ fn (i) '[,(atom-app 'r i) i]))

  --| `(asm1-len inst)` gets the projected byte length of an instruction.
  (def asm1-len @ match-fn
    ['(mov.32 (reg ,_) ,_) 5]
    ['(syscall) 2])

  --| `(assemble-rex x1 ... xn)` takes a list of specifications `xi = (bit val)`
  --| where bit is `'B`, `'X`, `'R`, `'W` or a number 0-3 and `val` is `$0$` or `$1$`,
  --| and produces `(rex p1 ... pn)` where
  --| * if `xi = (R val)` then `pi` proves `REX_R rex = val`, and
  --| * if `xi = (n val)` then `pi` proves `bit rex n = val`.
  (def (assemble-rex . xs)
    (def idx @ match-fn ['B 0] ['X 1] ['R 2] ['W 3] [n n])
    (def i @ foldl xs 0 @ match-fn*
      ['(,i (,bit (d1))) {i + {2 ^ (idx bit)}}]
      [(i _) i])
    @ if {i = 0}
      (cons $0$
        @ rmap xs @ match-fn @ (bit _)
        @ if (number? bit) '(,(xbit i bit)) '(,(atom-app 'REX_ bit '_0)))
      (cons (def rex '(h2n @ ,(hexdigit i))) '(suc ,rex)
        @ rmap xs @ match-fn @ (bit a)
        (def p '(,(xbit i (idx bit))))
        @ if (number? bit) p '(,(atom-app 'REX_ bit '_Si) ,a ,rex ,p)))

  --| `(assemble-inst inst)` assembles the instruction `inst`, and
  --| returns `(ast s p)` where `p` proves `decode ast s`.
  (def assemble-inst
    (def (asm-aux rex ast opc s p) @ match rex
      [$0$ '(,ast $,opc ': ,s$ (decode0I ,ast ,opc ,s ,p))]
      [$suc (h2n ,rex)$
        '(,ast $ch ,'(x4) ,rex ': ,opc ': ,s$ (decode1I ,ast ,opc ,rex ,s ,p))])
    @ match-fn
      ['(mov.32 (reg ,r2) ,(? number? imm))
        @ match (mk-splitBits '(3 1) r2) @ (r rb hr2)
        (def v $1$) (def sz '(wSz32))
        @ match (merge-bits '(3 1) r v) @ (a ha)
        (def r2 '(,(hexdigit r2))) (def a '(,(hexdigit a)))
        @ match (assemble-rex '(B ,rb) '(3 $0$)) @ (rex hrb hsz)
        (def hsz @ match rex
          [$0$ '(opSizeW_0 ,sz ,v (opSize_32 $F.$))]
          [$suc ,rex$ '(opSizeW_S ,sz ,rex ,v $0$ ,hsz (opSize_32 $F.$))])
        (def imm (->zhex imm))
        @ match (to-iNBytes 32 imm) @ (l heq)
        (def himm '(readFullImm32I ,imm ,l ,(to-eli 32 imm) ,heq))
        @ asm-aux rex
          $ xastMov ,sz (Rm_i (RM_reg (h2n ,r2)) (chopZ 64 ,imm)) $
          '(ch (xb) ,a) l
        @ list 'decodeMov64I a imm l r r2 rb rex sz v ha hsz himm hrb hr2]
      ['(syscall)
        '((xastSysCall) (scons (ch (x0) (xf)) @ s1 @ ch (x0) (x5)) (decodeSysCallI))])

  (def (assemble-desugar fwd-ref)
    @ letrec (
      [desugar-si @ match-fn ['{,k * ,x} '{,k * ,(desugar x)}] [x x]]
      [desugar @ match-fn
        ['(M {,si + ,x + ,n}) '(M ,(desugar-si si) ,(desugar x) ,(desugar n))]
        ['(M {,si + ,n}) @ match (desugar n)
          ['(reg ,x) '(M ,(desugar-si si) (reg ,x) 0)]
          [n '(M ,(desugar-si si) 0 ,n)]]
        ['(M ,si) '(M ,(desugar-si si) 0 0)]
        ['(M ,si ,x ,n) '(M ,(desugar-si si) ,(desugar x) ,(desugar n))]
        [((? atom? x)) (fwd-ref x)]
        [(? number? n) n]
        [(? atom? x) '(reg ,(reg-idx x))]])
    @ match-fn @ (asm . args) (cons asm @ map desugar args))

  --| `(assemble-measure xs)` does the first assembly pass, calculating the length of
  --| all instructions and assigning positions to the symbols.
  --| It returns `(entry_idx entry xs')` where `entry` is the entry address and
  --| `entry_idx` is the index of the entry function in the `xs` list, and `xs'` is
  --| the same as `xs` but with symbol references replaced by their locations.
  --|
  --| See `(assemble)` for the input grammar of `xs`.
  (def (assemble-measure xs)
    (def fwd-ref
      (def refs (atom-map!))
      @ fn (x) @ match (lookup refs x)
        [#undef (def r (ref! '(,x))) (insert refs x r) r]
        [r r])

    (def xs @ rmap xs @ match-fn
      [('func name data) @ list 'func name
        @ rmap data (assemble-desugar fwd-ref)]
      [e e])

    (def entry-idx (ref!))
    (foldl xs '(0 0x400078) @ match-fn* @ ((idx pos) (ty name data))
      (set! (fwd-ref name) pos)
      (if {name == 'main} (set! entry-idx idx))
      @ list {idx + 1} {pos + (match ty
        ['func @ apply + @ map asm1-len data]
        ['string (string-len data)])})
    @ list (get! entry-idx) (get! @ fwd-ref 'main) xs)

  --| `(assemble-core base main bss pub entry_idx entry xs')`
  --| assembles an ELF file, producing the file and a correctness theorem.
  --| See `(assemble)` for the meaning of the `base main bss pub` arguments,
  --| and `(assemble-measure)` for the `entry_idx entry xs'` arguments.
  (def (assemble-core base main bss pub entry_idx entry xs)
    (def start 0x400078)
    (def start_x (->hex start))
    (def pfx (atom-app base _))
    (def content (atom-app pfx 'content))
    (def pos_x (ref! start_x))

    -- items: list (pfx_name, assembled_prop, assembled_proof,
    --   option (list (inst_ast, inst_byte_str, decode_proof)))
    (def items @ rmap xs @ match-fn @ (ty name data)
      (def name_asm (atom-app pfx name '_asm))
      @ match (match ty
        ['func
          (def asm @ map assemble-inst data)
          (def str @ foldr asm '(s0) @ fn (asm s) '(sadd ,(nth 1 asm) ,s))
          '(,str assembled_func (assemble_func @ assembles_func_I ,name_asm) ,asm)]
        ['string '(,(string->hex data) assembled (assemble_1 ,name_asm) #undef)])
        @ (str kind asf asm)
      @ match (mk-asm1 (get! pos_x) str) @ (pos2_x pf)
      (def name2 (atom-app pfx name))
      (add-term! name2 () '(string ()) 'local () str)
      (add-tac-thm! name_asm () ()
        '(assemble1 (,name2) ,(get! pos_x) ,pos2_x) ()
        (fn () (verb pf)))
      (def prop '(,kind (,content) (,name2) ,(get! pos_x) ,pos2_x))
      (set! pos_x pos2_x)
      (list name2 prop asf asm))

    (def content_s
      @ foldl items '(s0) (fn (x y) '(sadd ,x (,(nth 0 y)))))
    (add-term! content () '(string ()) 'local () content_s)

    (def pos (hex->number pos_x))
    (def filesz {pos - start})
    (def filesz_x (->hex filesz))
    @ match (to-uNBytes 64 filesz_x) @ (filesz_s filesz_p)

    (def asmd (atom-app pfx 'assembled))
    (def asmd-pf
      (def n (len items))
      @ match (ra-list0
        '((tru) assembles0 ,items)
        (match-fn @ (t p ((_ prop asf _) . its))
          '((an ,t ,prop) (assemblesA ,p ,asf) ,its))
        (match-fn @ ($ T. /\ ,t $ p its)
          '(,t (assembles_trul ,p) ,its))
        (match-fn @ ($ ,q1 /\ ,q2 /\ ,q3 $ p its)
          '($ ,q1 /\ (,q2 /\ ,q3) $ (assembles_assoc ,p) ,its))
        n) @ (prop pf _)
      (add-tac-thm! asmd () ()
        '(an (eq (len (,content)) ,filesz_x) ,prop) ()
        @ fn () '(assembles_finish ,pf ,(verb @ nth 1 @ mkadd start_x filesz_x)))
      @ fn (i x)
      @ letrec ([(f i n) @ if {n = 1} x
        @ let ([m {n // 2}] [m2 {n - m}])
        @ if {i < m2} '(anli ,(f i m2)) '(anri ,(f {i - m2} m))])
      (f i n))

    (def entry_x (->hex entry))
    @ match (to-uNBytes 64 entry_x) @ (entry_s entry_p)

    (def bss_x (->hex bss))
    (def memsz {filesz + bss})
    (def memsz_x (->hex memsz))
    @ match (to-uNBytes 64 memsz_x) @ (memsz_s memsz_p)

    (add-term! base () '(string ()) (if pub () 'local) ()
      '(ELF_lit ,entry_s ,filesz_s ,memsz_s (,content)))

    @ match (mkadd start_x memsz_x) @ (end_x end_p)
    (def parseElf (atom-app pfx 'parseElf))
    (add-tac-thm! parseElf () ()
      '(ELF_lit_ok (,base) ,entry_x ,bss_x (,content)) () @ fn () @ focus
      '(basicElf_ok
        ,(verb entry_p)
        ,(verb filesz_p)
        ,(verb memsz_p)
        ,(verb @ nth 1 @ mkadd filesz_x bss_x)
        (anli ,asmd)
        ,(verb end_p)
        (assembled_func_bound ,(asmd-pf entry_idx '(anri ,asmd)))
        ,(verb @ to-elu 64 end_x)))

    (add-thm! (atom-app pfx 'basicElf) () ()
      '(isBasicElf (,base)) (if pub 'pub ())
      '(() (ELF_lit_ok_isBasicElf (,base) ,entry_x ,bss_x (,content)
        (,parseElf)))))

  --| `(assemble base main bss pub xs)` assembles an ELF file, producing the file
  --| and a correctness theorem. `base` is the base name for all declarations,
  --| `main` is the name of the main function, `bss` is the number of bytes in the
  --| zeroed section, `pub` is the target visibility of the main theorems
  --| (either `#t` public or `#f` local), and `xs` is the list of functions and data
  --| elements to assemble.
  --|
  --| The xs argument is a list, where the arguments can have the form:
  --| * `('func name data)` where `name` is the name of the function and `data`
  --|   is a list of assembly instructions
  --| * `('data name str)` where `name` is the name of the data element
  --|   and `str` is a string literal with the target bytes
  --|
  --| The assembly instructions in `data` are similar to those in a traditional
  --| assembler, but written as s-expressions. Most source/destination arguments
  --| can have the form:
  --| * `37`, etc: an immediate argument
  --| * `rax`, `r14`, etc: a register
  --| * `(reg 2)`: a register referenced by index
  --| * `(sym)`, where `sym` is a symbol: a symbol address
  --|   (these are elaborated by (assemble-measure))
  --| * `(M 42)`, `(M rax)`, `(M {{4 * rax} + rsi + 14})`: memory reference
  --|
  --| Available instructions:
  --| * `(mov.32 dst src)`: 32 bit move dst <- src
  --| * `(syscall)`: syscall instruction
  --|
  --| The result of the program is a number of new definitions starting with `base`.
  --|
  --| * ```
  --|   def (base)_(name): string;
  --|   ```
  --|   This defines the strings in `xs`, the individual items that were declared
  --|   with their given names
  --| * ```
  --|   theorem (base)_(name)_asm: $ assemble1 base_name start end $;
  --|   ```
  --|   The proof that base_name assembles from `start` to `end`
  --| * ```
  --|   def (base)_content: string;
  --|   ```
  --|   This is the "content" part of the ELF file, after the header. It is the
  --|   concatenation of all the items
  --| * ```
  --|   theorem (base)_assembled:
  --|     $ len content = n /\ (/\_i assembled content name_i x_i x_i+1) $;
  --|   ```
  --|   The result of assembly, which asserts the total length of the content
  --|   as well as a conjunction asserting that every name_i assembles to its
  --|   final location.
  --| * ```
  --|   (pub) def (base): string;
  --|   ```
  --|   This is the complete ELF file string, with visibility `pub`.
  --| * ```
  --|   theorem (base)_parseElf: $ ELF_lit_ok base entry bss base_content $;
  --|   ```
  --|   The proof that `base` is an ELF file that parses to `base_content`.
  --| * ```
  --|   (pub) def (base)_basicElf: $ isBasicElf base $;
  --|   ```
  --|   The proof that `base` is an ELF file.
  (def (assemble base main bss pub xs)
    @ match (assemble-measure xs) @ (entry_idx entry xs)
    (assemble-core base main bss pub entry_idx entry xs))
};

------------------------------------
-- Separation logic preliminaries --
------------------------------------

@_ local def Heap_join (H1 H2 H: set): wff =
$ isfun H1 /\ isfun H2 /\ Dom H1 i^i Dom H2 == 0 /\ H1 u. H2 == H $;

theorem Heap_join_un: $ Heap_join H1 H2 H -> H1 u. H2 == H $ = 'anr;
theorem Heap_join_dmun: $ Heap_join H1 H2 H -> Dom H1 u. Dom H2 == Dom H $ =
'(syl5eqsr dmun @ dmeqd Heap_join_un);
theorem Heap_join_dmin: $ Heap_join H1 H2 H -> Dom H1 i^i Dom H2 == 0 $ = 'anlr;
theorem Heap_join_com: $ Heap_join H1 H2 H <-> Heap_join H2 H1 H $ =
'(aneq (aneq ancomb @ eqseq1 incom) (eqseq1 uncom));
theorem Heap_join_dmdif1: $ Heap_join H1 H2 H -> Dom H i^i Compl (Dom H1) == Dom H2 $ =
'(eqstr3d (ineq1d Heap_join_dmun) @ syl5eqs indir @ syl6eqs un01 @
  uneqd (a1i incpl2) @ sylib eqin1 @ sylib ineq0r Heap_join_dmin);
theorem Heap_join_dmdif2: $ Heap_join H1 H2 H -> Dom H i^i Compl (Dom H2) == Dom H1 $ =
'(sylbi Heap_join_com Heap_join_dmdif1);
theorem Heap_join_ss: $ Heap_join H1 H2 H -> H1 C_ H /\ H2 C_ H $ =
'(anwr @ iand (mpbii ssun1 sseq2) (mpbii ssun2 sseq2));
theorem Heap_join_res2: $ Heap_join H1 H2 H -> H |` Dom H2 == H2 $ =
'(eqstr3d (reseq1d Heap_join_un) @ syl5eqs unres @ syl6eqs un01 @
  uneqd (sylib reseq0 Heap_join_dmin) (a1i resdm));
theorem Heap_join_res1: $ Heap_join H1 H2 H -> H |` Dom H1 == H1 $ =
'(sylbi Heap_join_com Heap_join_res2);
theorem Heap_join_inj1: $ Heap_join H1 H2 H /\ Heap_join H3 H2 H -> H1 = H3 $ =
'(syl axext @ eqstr3d (anwl Heap_join_res1) @
  eqstrd (reseq2d @ eqstr3d (anwl Heap_join_dmdif2) (anwr Heap_join_dmdif2)) @
  anwr Heap_join_res1);
theorem Heap_join_inj2: $ Heap_join H1 H2 H /\ Heap_join H1 H3 H -> H2 = H3 $ =
'(sylbi (aneq Heap_join_com Heap_join_com) Heap_join_inj1);
theorem Heap_join_isf1: $ Heap_join H1 H2 H -> isfun H1 $ = 'an3l;
theorem Heap_join_isf2: $ Heap_join H1 H2 H -> isfun H2 $ = 'anllr;
theorem Heap_join_isf3: $ Heap_join H1 H2 H -> isfun H $ =
'(mpbid (isfeqd anr) @ mpbird (syl unisf anlr) anll);

theorem heap_join_res: $ A u. B == Dom H ->
  (Heap_join (H |` A) (H |` B) H <-> isfun H /\ A i^i B == 0) $ =
(focus (def (f x) '(syl5eqs dmres @ sylib eqin2 @ mpbii ,x @ sseq2d anl))
  '(syl5bbr (bian1a Heap_join_isf3) @ syl aneq2a @ exp @
    bitrd (syl bian2 @ syl5eqsr resun @ sylib eqres @ anwl eqssr) @
    bitrd (syl bian1 @ anwr @ iand resisf resisf) @
    eqseq1d @ ineqd ,(f 'ssun1) ,(f 'ssun2)));

theorem Heap_join_rlam (v: nat x):
  $ Heap_join (\. x e. A, v) (\. x e. B, v) (\. x e. C, v) <->
    A i^i B == 0 /\ A u. B == C $ =
'(aneq (bitr (bian1 @ iani rlamisf rlamisf) @ eqseq1 @ ineq dmrlam dmrlam) unrlam);
theorem Heap_join_rlam2 (v: nat x):
  $ A == a /\ B == b /\ C == c ->
    (Heap_join (\. x e. a, v) (\. x e. b, v) (\. x e. c, v) <->
    A i^i B == 0 /\ A u. B == C) $ =
'(syl5bb Heap_join_rlam @ bicomd @
  aneqd (eqseq1d @ ineqd anll anlr) (eqseqd (uneqd anll anlr) anr));

theorem Heap_join_02: $ Heap_join H 0 H <-> isfun H $ =
'(bitr (bian2 un02) @ bitr (bian2 @ eqstr (ineq2 dm0) in02) @ bian2 isf0);
theorem Heap_join_01: $ Heap_join 0 H H <-> isfun H $ =
'(bitr Heap_join_com Heap_join_02);

@_ local def heap_join (h1 h2: nat): nat =
$ if (isfun h1 /\ isfun h2 /\ Dom h1 i^i Dom h2 == 0) (suc (lower (h1 u. h2))) 0 $;

theorem heap_join_S2: $ heap_join h1 h2 = suc h <->
  isfun h1 /\ isfun h2 /\ Dom h1 i^i Dom h2 == 0 /\ lower (h1 u. h2) = h $ =
'(cases (bitr4d (eqeq1d ifpos) @ syl6bbr peano2 bian1) @
  binthd (syl (con2 sucne0) ifneg) @ con3 anl);

theorem heap_join_n0: $ heap_join h1 h2 != 0 <->
  isfun h1 /\ isfun h2 /\ Dom h1 i^i Dom h2 == 0 $ =
(named '(bitr exsuc @
  bitr (exeqi @ bitr heap_join_S2 @ bitr ancomb @ aneq1i eqcomb) @ exeqe biidd));

theorem heap_join_S: $ heap_join h1 h2 = suc h <-> Heap_join h1 h2 h $ =
'(bitr4 heap_join_S2 @ aneq2i @ eqlower1 @ unfin finns finns);

theorem heap_join_com: $ heap_join h1 h2 = heap_join h2 h1 $ =
'(ifeq (aneq ancomb @ eqseq1 incom) (suceq @ lowereq uncom) eqid);

theorem heap_join_un: $ heap_join h1 h2 = suc h -> h1 u. h2 == h $ =
'(sylbi heap_join_S Heap_join_un);
theorem heap_join_dmun: $ heap_join h1 h2 = suc h -> Dom h1 u. Dom h2 == Dom h $ =
'(syl5eqsr dmun @ dmeqd heap_join_un);
theorem heap_join_dmin: $ heap_join h1 h2 = suc h -> Dom h1 i^i Dom h2 == 0 $ =
'(sylbi heap_join_S Heap_join_dmin);
theorem heap_join_dmdif1: $ heap_join h1 h2 = suc h -> Dom h i^i Compl (Dom h1) == Dom h2 $ =
'(sylbi heap_join_S Heap_join_dmdif1);
theorem heap_join_dmdif2: $ heap_join h1 h2 = suc h -> Dom h i^i Compl (Dom h2) == Dom h1 $ =
'(sylbi heap_join_S Heap_join_dmdif2);
theorem heap_join_ss: $ heap_join h1 h2 = suc h -> h1 C_ h /\ h2 C_ h $ =
'(sylbi heap_join_S Heap_join_ss);
theorem heap_join_res2: $ heap_join h1 h2 = suc h -> h |` Dom h2 == h2 $ =
'(sylbi heap_join_S Heap_join_res2);
theorem heap_join_res1: $ heap_join h1 h2 = suc h -> h |` Dom h1 == h1 $ =
'(sylbi heap_join_S Heap_join_res1);
theorem heap_join_inj1: $ heap_join h1 h2 = suc h /\ heap_join h3 h2 = suc h -> h1 = h3 $ =
'(sylbi (aneq heap_join_S heap_join_S) Heap_join_inj1);
theorem heap_join_inj2: $ heap_join h1 h2 = suc h /\ heap_join h1 h3 = suc h -> h2 = h3 $ =
'(sylbi (aneq heap_join_S heap_join_S) Heap_join_inj2);
theorem heap_join_isf1: $ heap_join h1 h2 = suc h -> isfun h1 $ = '(sylbi heap_join_S Heap_join_isf1);
theorem heap_join_isf2: $ heap_join h1 h2 = suc h -> isfun h2 $ = '(sylbi heap_join_S Heap_join_isf2);
theorem heap_join_isf3: $ heap_join h1 h2 = suc h -> isfun h $ = '(sylbi heap_join_S Heap_join_isf3);
theorem heap_join_02: $ heap_join h 0 = suc h <-> isfun h $ = '(bitr heap_join_S Heap_join_02);
theorem heap_join_01: $ heap_join 0 h = suc h <-> isfun h $ = '(bitr heap_join_S Heap_join_01);

theorem heap_join_rlam (v: nat x):
  $ heap_join (\. x e. A, v) (\. x e. B, v) = suc (\. x e. C, v) <->
    A i^i B == 0 /\ A u. B == C $ =
'(bitr heap_join_S Heap_join_rlam);
theorem heap_join_rlam2 (v: nat x):
  $ A == a /\ B == b /\ C == c ->
    (heap_join (\. x e. a, v) (\. x e. b, v) = suc (\. x e. c, v) <->
    A i^i B == 0 /\ A u. B == C) $ =
'(syl5bb heap_join_rlam @ bicomd @
  aneqd (eqseq1d @ ineqd anll anlr) (eqseqd (uneqd anll anlr) anr));

theorem heap_join_ass:
  $ E. h23 (heap_join h2 h3 = suc h23 /\ heap_join h1 h23 = suc h) <->
    E. h12 (heap_join h1 h2 = suc h12 /\ heap_join h12 h3 = suc h) $ =
(focus
  (def (f x) '(bitr (exeqi @
      bitr (aneq (bitr heap_join_S2 ancomb) heap_join_S) @ bitr anass @ aneq1i eqcomb) @
    exeqe @ sylbir (eqlower2 @ unfin finns finns) ,x))
  '(bitr4
    ,(f '(syl aneq2a @ exp @ syl6bb anass @ aneqd (aneqd
      (syl bian2 @ mpbird (isfeqd anl) @ mpbird (rsyl anrr unisf) anrl)
      (syl6bb uneq0 @ eqseq1d @ syl6eqs indi @ ineq2d @ syl6eqs dmun @ dmeqd anl))
      (anwl @ eqseq1d @ syl6eqsr unass uneq2)))
    ,(f '(syl6bb anlass @ syl6bb (aneq2i @ bitr4 an4 @ aneq anass anass) @
      syl6bb anass @ syl6bb (aneq1i anass) @ syl aneq2a @ exp @
      syl6bb anass @ aneqd (syl6bbr anass @ aneqd
        (syl bian1 @ mpbird (isfeqd anl) @ mpbird (rsyl anrr unisf) anrl)
        (syl6bb ancomb @ syl6bb uneq0 @ eqseq1d @
          syl6eqs indir @ ineq1d @ syl6eqs dmun @ dmeqd anl)) @
      eqseq1d @ uneq1d anl))));

theorem heap_join_ex2: $ E. h2 heap_join h1 h2 = suc h <-> isfun h /\ h1 C_ h $ =
(focus
  '(ibii (eex @ iand heap_join_isf3 @ mpbii ssun1 @ sseq2d @ sylbi heap_join_S anr) _)
  (have 'h '(syl5eqs undi @ syl6eqs inv2 @ ineqd (sylib equn1 anr) @ a1i uncpl2))
  '(sylibr (exeqi heap_join_S) @ syl (iexe @ sylbir (eqlower2 @ infin1 finns) ,eqtac) @
    iand (iand (iand (impcom isfss) @ anwl @ isfss inss1) @
      mpbiri (mpbir ineq0r inss2) (syl dmdisj @ mpbird (isfeqd h) anl)) h));

theorem heap_join_ex1: $ E. h1 heap_join h1 h2 = suc h <-> isfun h /\ h2 C_ h $ =
'(bitr (exeqi @ eqeq1 heap_join_com) heap_join_ex2);

@_ local def oheap_join (oh1 oh2: nat): nat =
$ obind oh1 (\ h1, obind oh2 (\ h2, heap_join h1 h2)) $;

theorem oheap_join_S: $ oheap_join oh1 oh2 = suc h <-> E. h1 (
  oh1 = suc h1 /\ E. h2 (oh2 = suc h2 /\ heap_join h1 h2 = suc h)) $ =
'(bitr obindeqS @ rexeqi @
  bitr (eqeq1 @ applame ,eqtac) @ bitr obindeqS @ rexeqi @
  eqeq1 @ applame ,eqtac);

theorem oheap_join_com: $ oheap_join h1 h2 = oheap_join h2 h1 $ =
(named '(mpbir eqsucext @ ax_gen @ bitr4 oheap_join_S @ bitr4 oheap_join_S @
  bitr rexcomb @ rexeqi @ rexeqi @ eqeq1 heap_join_com));

theorem oheap_join_ass: $ oheap_join h1 (oheap_join h2 h3) = oheap_join (oheap_join h1 h2) h3 $ =
'(mpbir eqsucext @ !! ax_gen h @ bitr4 oheap_join_S @ bitr4 oheap_join_S @
  bitr4 (!! exeqi x1 @ aneq2i @ !! exeqi x23 @ aneq1i @ !! oheap_join_S x2 x3) @
  bitr (!! birexexi x12 _ @ birexan1i @ !! oheap_join_S x1 x2) @ rexeqi @
  bitr4 (birexexi @ bicom rexan2) @ bitr4 (birexexi @ bicom rexan2) @ rexeqi @
  bitr4 rexcomb @ bitr (birexexi @ bicom rexan2) @ rexeqi heap_join_ass);

@_ local def s_lift (p: wff): set = $ {h | isfun h /\ p} $;
prefix s_lift: $^s$ prec 81;
theorem el_s_lift: $ h e. ^s p <-> isfun h /\ p $ = '(elabe ,eqtac);

theorem s_lift_ss: $ ^s p C_ ^s q <-> (p -> q) $ =
'(ibii (rsyl ssel @ sylbi (imeqi el_s_lift el_s_lift) @ syl5 (ian isf0) @ imim2i anr) @
  !! iald h @ sylibr (imeqi el_s_lift el_s_lift) anim2);

@_ local def s_bot: set = $ ^s F. $;
prefix s_bot: $F.s$ prec max;
theorem el_s_bot: $ ~h e. F.s $ = '(mpbi imfal @ sylbi el_s_lift anr);

theorem s_bot_0: $ F.s == 0 $ = '(!! ax_gen h @ binth el_s_bot nel0);
theorem s_bot_ss1: $ F.s C_ P $ = '(mpbir (sseq1 s_bot_0) ss01);
theorem s_bot_ss2: $ P C_ F.s <-> P == F.s $ =
'(bitr4 (sseq2 s_bot_0) @ bitr4 (eqseq2 s_bot_0) ss02);

@_ local def s_emp: set = $ sn 0 $;
prefix s_emp: $emp$ prec max;
@_ local def s_top: set = $ ^s T. $;
prefix s_top: $T.s$ prec max;
theorem el_s_top: $ h e. T.s <-> isfun h $ = '(bitr el_s_lift @ bian2 itru);
theorem s_top_01: $ 0 e. T.s $ = '(mpbir el_s_top isf0);

theorem s_lift_sstop: $ ^s p C_ T.s $ = '(mpbir s_lift_ss @ a1i itru);

theorem el_sstop: $ P C_ T.s -> h e. P -> isfun h $ = '(syl6ib el_s_top ssel);

theorem s_lift_eqtop: $ p <-> ^s p == T.s $ =
'(ibii (sylbir eqtru s_lifteq) @ anrd @ sylib el_s_lift @ mpbiri s_top_01 eleq2);
theorem s_lift_eqbot: $ ~p <-> ^s p == F.s $ =
'(ibii (sylbir eqfal s_lifteq) @ mpbiri el_s_bot @ noteqd @
  syl5bbr (bitr el_s_lift @ bian1 isf0) eleq2);

theorem heap_join_sstop1: $ heap_join h1 h2 = suc h -> h1 e. T.s $ = '(sylibr el_s_top heap_join_isf1);
theorem heap_join_sstop2: $ heap_join h1 h2 = suc h -> h2 e. T.s $ = '(sylibr el_s_top heap_join_isf2);
theorem heap_join_sstop3: $ heap_join h1 h2 = suc h -> h e. T.s $ = '(sylibr el_s_top heap_join_isf3);

@_ local def s_or (P Q: set): set = $ Union P Q $;
infixl s_or: $\/s$ prec 64;
theorem el_s_or: $ h e. P \/s Q <-> h e. P \/ h e. Q $ = 'elun;

@_ local def s_an (P Q: set): set = $ Inter P Q $;
infixl s_an: $/\s$ prec 70;
theorem el_s_an: $ h e. P /\s Q <-> h e. P /\ h e. Q $ = 'elin;
theorem s_bian1a: $ Q C_ P <-> P /\s Q == Q $ = 'eqin2;
theorem s_bian2a: $ P C_ Q <-> P /\s Q == P $ = 'eqin1;
theorem s_antop: $ P C_ T.s <-> P /\s T.s == P $ = 's_bian2a;
theorem s_anl: $ P /\s Q C_ P $ = 'inss1;
theorem s_anr: $ P /\s Q C_ Q $ = 'inss2;
theorem s_anwl: $ P C_ R -> P /\s Q C_ R $ = '(sstr s_anl);
theorem s_anwr: $ Q C_ R -> P /\s Q C_ R $ = '(sstr s_anr);
theorem ss_s_an: $ A C_ P /\s Q <-> A C_ P /\ A C_ Q $ = 'ssin;
theorem s_ancom: $ P /\s Q == Q /\s P $ = 'incom;
theorem s_anass: $ (P /\s Q) /\s R == P /\s (Q /\s R) $ = 'inass;
theorem s_antop2: $ P /\s T.s /\s T.s == P /\s T.s $ = '(mpbi s_antop s_anr);

theorem el_s_antop: $ h e. P /\s T.s <-> isfun h /\ h e. P $ =
'(bitr el_s_an @ bitr ancomb @ aneq1i el_s_top);

theorem s_lift_an: $ ^s p /\s ^s q == ^s (p /\ q) $ =
(named '(ax_gen @ bitr4 el_s_an @ bitr el_s_lift @ bitr4 anandi @
  aneq el_s_lift el_s_lift));

theorem s_lift_anidm: $ ^s p /\s ^s p == ^s p $ = '(eqstr s_lift_an @ s_lifteq anidm);

theorem s_anlift_ass: $ ^s (p /\ q) /\s P == ^s p /\s (^s q /\s P) $ =
'(eqstr3 (s_aneq1 s_lift_an) s_anass);

theorem s_bot_an1: $ F.s /\s P == F.s $ = '(mpbi s_bot_ss2 s_anl);
theorem s_bot_an2: $ P /\s F.s == F.s $ = '(mpbi s_bot_ss2 s_anr);

theorem s_aneq2a: $ (p -> P == Q) -> ^s p /\s P == ^s p /\s Q $ =
(begin (def h '(syl6eqs s_bot_an1 @ sylbi s_lift_eqbot s_aneq1))
  '(casesd (imim2i s_aneq2) @ a1i @ eqstr4d ,h ,h));

theorem s_bian1: $ P C_ T.s -> p -> ^s p /\s P == P $ =
'(exp @ eqstrd (s_aneq1d @ sylib s_lift_eqtop anr) @ syl5eqs s_ancom @ sylib s_bian2a anl);

@_ local def s_im (P Q: set): set = $ {h | isfun h /\ (h e. P -> h e. Q)} $;
infixr s_im: $->s$ prec 61;
theorem el_s_im: $ h e. (P ->s Q) <-> isfun h /\ (h e. P -> h e. Q) $ = '(elabe ,eqtac);

@_ local def s_ex {x: nat} (A: set) (P: set x): set = $ {h | E. x (x e. A /\ h e. P)} $;
notation s_ex {x} (A P) = ($E.s$:75) x ($e.$:50) A ($,$:0) P;
theorem el_s_ex (A: set) (P: set x):
  $ h e. E.s x e. A, P <-> E. x (x e. A /\ h e. P) $ = '(elabe ,eqtac);

theorem s_exeq1 (P: set x): $ A == B -> E.s x e. A, P == E.s x e. B, P $ = '(s_exeq1d id);
theorem s_exeq2a (P Q: set x):
  $ (A. x (x e. A -> P == Q)) -> E.s x e. A, P == E.s x e. A, Q $ =
(named '(abeqd @ syl exeq @ alimi @ syl aneq2a @ imim2i eleq2));
theorem s_exeq2da (P Q: set x) (h: $ G /\ x e. A -> P == Q $):
  $ G -> E.s x e. A, P == E.s x e. A, Q $ =
'(syl s_exeq2a @ iald @ exp h);
theorem s_exeq2ia (P Q: set x) (h: $ x e. A -> P == Q $): $ E.s x e. A, P == E.s x e. A, Q $ =
'(s_exeq2a @ ax_gen h);
theorem s_exeq2i (P Q: set x) (h: $ P == Q $): $ E.s x e. A, P == E.s x e. A, Q $ =
'(s_exeq2ia @ a1i h);
theorem nfs_ex1 (A P: set x) (h1: $ FS/ x A $): $ FS/ x E.s x e. A, P $ = (named '(nfab nfex1));
theorem nfs_ex (A P: set x y)
  (h1: $ FS/ x A $) (h2: $ FS/ x P $): $ FS/ x E.s y e. A, P $ =
(named '(nfab @ nfex @ nfan (nfel2 h1) (nfel2 h2)));
theorem cbvs_exh (P Q: set x y) (h1: $ FS/ y P $) (h2: $ FS/ x Q $)
  (e: $ x = y -> P == Q $): $ E.s x e. A, P == E.s y e. A, Q $ =
(named '(abeqi @ cbvexh (nfan nfv @ nfel2 h1) (nfan nfv @ nfel2 h2) @
  aneqd eleq1 @ eleq2d e));
theorem cbvs_ex (P: set x) (Q: set y) (e: $ x = y -> P == Q $):
  $ E.s x e. A, P == E.s y e. A, Q $ = '(cbvs_exh nfsv nfsv e);
theorem cbvs_exs (P: set x): $ E.s x e. A, P == E.s y e. A, S[y / x] P $ =
'(cbvs_exh nfsv nfsbs1 sbsq);
theorem cbvs_exd (G A) (P: set x) (Q: set y)
  (h: $ G /\ x = y -> P == Q  $): $ G -> E.s x e. A, P == E.s y e. A, Q $ =
'(syl5eqs cbvs_exs @ s_exeq2d @ syl sbset @ iald @ exp h);

theorem s_exan1 (Q: set x): $ E.s x e. A, (P /\s Q) == P /\s E.s x e. A, Q $ =
(named '(ax_gen @ bitr4 el_s_ex @ bitr4 el_s_an @
  bitr4 (rexeqi el_s_an) @ bitr4 (aneq2i el_s_ex) rexan1));
theorem s_exan2 (P: set x): $ E.s x e. A, (P /\s Q) == E.s x e. A, P /\s Q $ =
'(eqstr (s_exeq2i s_ancom) @ eqstr s_exan1 s_ancom);

theorem s_ex_ssi (P: set x) (h: $ P C_ Q $): $ E.s x e. A, P C_ Q $ =
(named '(ax_gen @ sylbi el_s_ex @ eex @ anwr @ ssel h));

@_ local def s_al {x: nat} (A: set) (P: set x): set = $ {h | A. x (x e. A -> h e. P)} $;
notation s_al {x} (A P) = ($A.s$:75) x ($e.$:50) A ($,$:0) P;
theorem el_s_al (A: set) (P: set x):
  $ h e. A.s x e. A, P <-> A. x (x e. A -> h e. P) $ = '(elabe ,eqtac);

theorem s_aleq1 (P: set x): $ A == B -> A.s x e. A, P == A.s x e. B, P $ = '(s_aleq1d id);
theorem s_aleq2a (P Q: set x):
  $ (A. x (x e. A -> P == Q)) -> A.s x e. A, P == A.s x e. A, Q $ =
(named '(abeqd @ syl aleq @ alimi @ syl imeq2a @ imim2i eleq2));
theorem s_aleq2da (P Q: set x) (h: $ G /\ x e. A -> P == Q $):
  $ G -> A.s x e. A, P == A.s x e. A, Q $ =
'(syl s_aleq2a @ iald @ exp h);
theorem nfs_al1 (A P: set x) (h1: $ FS/ x A $): $ FS/ x A.s x e. A, P $ = (named '(nfab nfal1));
theorem nfs_al (A P: set x y)
  (h1: $ FS/ x A $) (h2: $ FS/ x P $): $ FS/ x A.s y e. A, P $ =
(named '(nfab @ nfal @ nfim (nfel2 h1) (nfel2 h2)));
theorem cbvs_alh (P Q: set x y) (h1: $ FS/ y P $) (h2: $ FS/ x Q $)
  (e: $ x = y -> P == Q $): $ A.s x e. A, P == A.s y e. A, Q $ =
(named '(abeqi @ cbvalh (nfim nfv @ nfel2 h1) (nfim nfv @ nfel2 h2) @
  imeqd eleq1 @ eleq2d e));
theorem cbvs_al (P: set x) (Q: set y) (e: $ x = y -> P == Q $):
  $ A.s x e. A, P == A.s y e. A, Q $ = '(cbvs_alh nfsv nfsv e);
theorem cbvs_als (P: set x): $ A.s x e. A, P == A.s y e. A, S[y / x] P $ =
'(cbvs_alh nfsv nfsbs1 sbsq);
theorem cbvs_ald (G A) (P: set x) (Q: set y)
  (h: $ G /\ x = y -> P == Q  $): $ G -> A.s x e. A, P == A.s y e. A, Q $ =
'(syl5eqs cbvs_als @ s_aleq2d @ syl sbset @ iald @ exp h);

@_ local def s_sep (P Q: set): set =
$ {h | E. h1 E. h2 (h1 e. P /\ h2 e. Q /\ heap_join h1 h2 = suc h)} $;
infixl s_sep: $*s$ prec 72;

theorem el_s_sep: $ h e. P *s Q <->
  E. h1 E. h2 (h1 e. P /\ h2 e. Q /\ heap_join h1 h2 = suc h) $ =
'(elabe ,eqtac);

theorem el_s_sep2: $ h e. P *s Q <->
  E. h1 (h1 e. P /\ E. h2 (h2 e. Q /\ heap_join h1 h2 = suc h)) $ =
'(bitr el_s_sep @ exeqi @ bitr (exeqi anass) exan1);

theorem el_s_sep_sn1: $ h e. sn h1 *s Q <->
  E. h2 (h2 e. Q /\ heap_join h1 h2 = suc h) $ =
'(bitr el_s_sep2 @ bitr (exeqi @ aneq1i elsn) @ exeqe ,eqtac);
theorem el_s_sep_sn2: $ h e. P *s sn h2 <->
  E. h1 (h1 e. P /\ heap_join h1 h2 = suc h) $ =
'(bitr el_s_sep2 @ rexeqi @ bitr (exeqi @ aneq1i elsn) @ exeqe ,eqtac);
theorem el_s_sep_sn: $ h e. sn h1 *s sn h2 <-> heap_join h1 h2 = suc h $ =
'(bitr el_s_sep_sn1 @ bitr (exeqi @ aneq1i elsn) @ exeqe ,eqtac);
theorem s_sep_sn: $ (sn h1 *s sn h2) == sn h <-> heap_join h1 h2 = suc h $ =
(named '(ibii (sylib el_s_sep_sn @ mpbiri snid eleq2) @
  eqrd @ bitr4g el_s_sep_sn elsn @ syl6bb peano2 @ syl6bb eqcomb eqeq1));

theorem s_sep_com: $ P *s Q == Q *s P $ =
(named '(ax_gen @ bitr4 el_s_sep @ bitr4 el_s_sep @ bitr excomb @
  exeqi @ exeqi @ aneq ancomb @ eqeq1 heap_join_com));

theorem s_sep_ass: $ (P *s Q) *s R == P *s (Q *s R) $ =
(named '(ax_gen @ bitr4 el_s_sep2 @ bitr4 el_s_sep2 @
  bitr4 (bitr4 (exeqi @ bitr4 (aneq1i el_s_sep2) rexan2) rexexcomb) @
  rexeqi @ bitr4 (bitr4 (exeqi @ bitr4 (aneq1i el_s_sep2) rexan2) rexexcomb) @
  bitr4 (bitr2 rexexcomb (exeqi rexan2)) @ rexeqi @
  bitr4 (bitr2 rexexcomb (exeqi rexan2)) @ bitr4 rexcomb @
  rexeqi heap_join_ass));

theorem s_sep_sstop: $ P *s Q C_ T.s $ =
(named '(ax_gen @ sylbi el_s_sep @ eex @ eex @ anwr heap_join_sstop3));
theorem s_sep_antop1: $ (P /\s T.s) *s Q == P *s Q $ =
(named '(eqri @ bitr4 el_s_sep @ bitr4 el_s_sep @ exeqi @ exeqi @
  aneq1a @ aneq1d @ syl5bb el_s_an @ syl bian2 @ heap_join_sstop1));
theorem s_sep_antop2: $ P *s (Q /\s T.s) == P *s Q $ =
'(eqstr4 s_sep_com @ eqstr4 s_sep_com s_sep_antop1);

theorem s_sep_ss1: $ P C_ Q -> P *s R C_ Q *s R $ =
(named '(sylib ssab @ iald @ eximd @ eximd @ anim1d @ anim1d ssel));
theorem s_sep_ss2: $ Q C_ R -> P *s Q C_ P *s R $ =
'(sylib (sseq s_sep_com s_sep_com) s_sep_ss1);

theorem s_sep_subsn: $ subsn P -> subsn Q -> subsn (P *s Q) $ =
(named '(sylbi subsnsssn @ eex @ syl5bi subsnsssn @ eexda @
  syl (mpi subsnsn subsnss) @
  sylc sstr (anwl s_sep_ss1) @ sylc sstr (anwr s_sep_ss2) @
  a1i @ ax_gen @ sylbi el_s_sep_sn @ sylibr elsn @
  sylib (eqlower2 @ unfin finns finns) @ eqscomd heap_join_un));

theorem s_sep_emp2a: $ P *s emp == P /\s T.s $ =
(named @ focus
  '(eqri @ bitr el_s_sep2 @ bitr3 (exeqi _) (exeqe eleq1))
  '(bitr (aneq2i @ bitr el_s_antop ancomb) @ bitr4 anlass @ aneq2i @
    bitr (exeqi @ aneq1i elsn) @ bitr (exeqe @ eqeq1d heap_joineq2) @
    bitr3 (bian2a heap_join_isf1) @ aneq1a @
    syl6bb peano2 @ sylbir heap_join_02 eqeq1));
theorem s_sep_emp1a: $ emp *s P == P /\s T.s $ = '(eqstr s_sep_com s_sep_emp2a);
theorem s_sep_emp2: $ P C_ T.s <-> P *s emp == P $ =
'(bitr4 s_antop @ eqseq1 s_sep_emp2a);
theorem s_sep_emp1: $ P C_ T.s <-> emp *s P == P $ =
'(bitr s_sep_emp2 @ eqseq1 s_sep_com);

theorem s_lift_sep: $ ^s p *s ^s q == ^s (p /\ q) $ =
(named '(ax_gen @ bitr4 el_s_sep @ bitr4 el_s_lift @
  bitr (exeqi @ bitr (exeqi @ bitr4 (aneq1i @
    bitr (aneq el_s_lift el_s_lift) an4) anrass) exan2) @
  bitr exan2 @ aneq1i @ bitr4 (exeqi @ exeqi @ bian1a @ iand heap_join_isf1 heap_join_isf2) @
  ibii (iexde @ iexde @ mpbird ,eqtac @ sylibr heap_join_02 anll) @
  eex @ eex heap_join_isf3));

theorem s_lift_sep1: $ ^s p /\s P C_ ^s p *s P $ =
(named @ focus
  (have 'h '(sylib el_s_lift an3l))
  '(ax_gen @ sylbi el_s_an @ sylibr el_s_sep @ iexde @ iexde @ mpbird ,eqtac @
    iand (iand (sylibr el_s_lift @ syl (ian isf0) @ anrd h) anllr) @
    sylibr heap_join_01 @ anld h));
theorem s_lift_sep2: $ P /\s ^s p C_ P *s ^s p $ =
'(mpbi (sseq s_ancom s_sep_com) s_lift_sep1);

theorem s_ssseptop: $ P /\s T.s C_ P *s T.s $ = 's_lift_sep2;

theorem s_lift_sepidm: $ ^s p *s ^s p == ^s p $ = '(eqstr s_lift_sep @ s_lifteq anidm);
theorem s_top_sepidm: $ T.s *s T.s == T.s $ = 's_lift_sepidm;
theorem s_septop2: $ A *s T.s *s T.s == A *s T.s $ = '(eqstr s_sep_ass @ s_sepeq2 s_top_sepidm);

theorem s_bot_sep1: $ F.s *s P == F.s $ =
(named '(ax_gen @ binth (mtbir el_s_sep @ nexi @ nexi @ mt anll el_s_bot) el_s_bot));
theorem s_bot_sep2: $ P *s F.s == F.s $ = '(eqstr s_sep_com s_bot_sep1);

theorem s_ansepdi: $ (P /\s Q) *s R C_ (P *s R) /\s (Q *s R) $ =
'(mpbir ss_s_an @ ian (s_sep_ss1 s_anl) (s_sep_ss1 s_anr));
theorem s_orsepdi: $ (P \/s Q) *s R == (P *s R) \/s (Q *s R) $ =
(named '(ax_gen @ bitr el_s_sep2 @ bitr (exeqi @ bitr (aneq1i el_s_or) andir) @
  bitr4 exor @ bitr el_s_or @ oreq el_s_sep2 el_s_sep2));

theorem s_sep_anlift1: $ (^s p /\s P) *s Q == ^s p /\s (P *s Q) $ =
(named '(ax_gen @ bitr el_s_sep2 @
  bitr (exeqi @ bitr (aneq1a @ syl5bb el_s_an @ aneq1d @
    syl5bb el_s_lift @ syl bian1 @ eex @ anwr @ heap_join_isf1) anass) @
  bitr4 exan1 @ bitr el_s_an @
  bitr (aneq1a @ syl5bb el_s_lift @ syl bian1 @ el_sstop s_sep_sstop) @
  aneq2i el_s_sep2));

theorem s_sep_anlift2: $ P *s (^s p /\s Q) == ^s p /\s (P *s Q) $ =
'(eqstr s_sep_com @ eqstr s_sep_anlift1 @ s_aneq2 s_sep_com);

theorem s_sep_anlift: $ (^s p /\s P) *s (^s q /\s Q) == ^s (p /\ q) /\s (P *s Q) $ =
'(eqstr4 s_sep_anlift1 @ eqstr3 (s_aneq1 s_lift_an) @
  eqstr4 s_anass @ s_aneq2 s_sep_anlift2);

@_ local def s_wand (P Q: set): set =
$ {h1 | isfun h1 /\ A. h2 A. h (h2 e. P -> heap_join h1 h2 = suc h -> h e. Q)} $;
infixr s_wand: $-*s$ prec 61;
theorem el_s_wand: $ h1 e. P -*s Q <-> isfun h1 /\
  A. h2 A. h (h2 e. P -> heap_join h1 h2 = suc h -> h e. Q) $ =
'(elabe ,eqtac);

theorem s_wand_sstop: $ P -*s Q C_ T.s $ =
(named '(ax_gen @ sylbi el_s_wand @ sylibr el_s_top anl));

theorem s_wand_I: $ h1 e. P -*s Q -> h2 e. P -> heap_join h1 h2 = suc h -> h e. Q $ =
'(sylbi el_s_wand @ anwr @ ealie @ ealde @ bi1d ,eqtac);
theorem s_wand_Ir: $ h2 e. P -*s Q -> h1 e. P -> heap_join h1 h2 = suc h -> h e. Q $ =
'(syl6ib (imeq1i @ eqeq1 heap_join_com) s_wand_I);

theorem ss_s_wand_g: $ A C_ P -*s Q <-> A C_ T.s /\ A *s P C_ Q $ =
(named '(bitr (aleqi @ bitr (imeq2i el_s_wand) imandi) @ bitr4 alan @
  aneq (aleqi @ imeq2i el_s_top) @
  bitr4 (aleqi @ bitr (imeq1i el_s_sep2) @ bitr erexb @ aleqi @ imeq2i erexb) @
  bitr (aleqi @ imeq2i alcomb) ralalcomb));

theorem s_wand_imp: $ A C_ P -*s Q -> A *s P C_ Q $ = '(sylbi ss_s_wand_g anr);

theorem ss_s_wand: $ A C_ T.s -> (A C_ P -*s Q <-> A *s P C_ Q) $ =
'(syl5bb ss_s_wand_g bian1);
theorem ss_s_wand2: $ A C_ T.s -> (A C_ P -*s Q <-> P *s A C_ Q) $ =
'(syl6bb (sseq1 s_sep_com) ss_s_wand);

theorem s_wand_mp: $ (P -*s Q) *s P C_ Q $ = '(anri @ mpbi ss_s_wand_g ssid);
theorem s_wand_mpr: $ P *s (P -*s Q) C_ Q $ = '(mpbi (sseq1 s_sep_com) s_wand_mp);

theorem s_wand_ss1: $ P C_ Q -> Q -*s R C_ P -*s R $ =
'(sylibr ss_s_wand_g @ iand (a1i s_wand_sstop) @ syl (mpi s_wand_mp sstr) s_sep_ss2);
theorem s_wand_ss2: $ Q C_ R -> P -*s Q C_ P -*s R $ =
'(sylibr ss_s_wand_g @ iand (a1i s_wand_sstop) @ sstr s_wand_mp);

theorem s_split: $ subsn Q -> (Q *s T.s) /\s P C_ Q *s (Q -*s P) $ =
(named @ focus
  '(iald @ syl5bi el_s_an @ impd @ com23 @ exp @ syl5bi el_s_sep @ syl6ibr el_s_sep @
    eximd @ eximd @ syl anim1a @ exp @ syl anim2a @ exp @ a1d @
    sylibr el_s_wand @ iand (rsyl anlr heap_join_isf2) @
    iald @ iald @ exp @ exp @ mpbird _ an4lr)
  '(eleq1d @ sylib peano2 @ eqtr3d anr @ syl5eq heap_join_com @
    eqtrd (heap_joineq1d @ subsni an5l anlr anllr) an3lr));

@_ local def s_Sep {x: nat} (A: set) (P: set x): set =
$ {h | isfun h /\ E. f (func f (Dom h) A /\
  A. x (x e. A -> lower (h |` {z | f @ z = x}) e. P))} $;
notation s_Sep {x} (A P) = ($|*|s$:75) x ($e.$:50) A ($,$:0) P;
theorem el_s_Sep (A: set) (P: set x): $ h e. |*|s x e. A, P <->
  isfun h /\ E. f (func f (Dom h) A /\
    A. x (x e. A -> lower (h |` {z | f @ z = x}) e. P)) $ = '(elabe ,eqtac);

theorem s_Sepeq1 (P: set x): $ A == B -> |*|s x e. A, P == |*|s x e. B, P $ =
'(s_Sepeq1d id);
theorem s_Sepeq2a (P Q: set x):
  $ (A. x (x e. A -> P == Q)) -> |*|s x e. A, P == |*|s x e. A, Q $ =
(named '(abeqd @ aneq2d @ rexeqd @
  syl aleq @ alimi @ syl imeq2a @ imim2i eleq2));
theorem s_Sepeq2da (P Q: set x) (h: $ G /\ x e. A -> P == Q $):
  $ G -> |*|s x e. A, P == |*|s x e. A, Q $ =
'(syl s_Sepeq2a @ iald @ exp h);
theorem nfs_Sep1 (A P: set x) (h1: $ FS/ x A $): $ FS/ x |*|s x e. A, P $ =
(named '(nfab @ nfan nfv @ nfex @ nfan (nffunc nfsv nfsv h1) nfal1));
theorem nfs_Sep (A P: set x y)
  (h1: $ FS/ x A $) (h2: $ FS/ x P $): $ FS/ x |*|s y e. A, P $ =
(named '(nfab @ nfan nfv @ nfex @ nfan (nffunc nfsv nfsv h1) @
  nfal @ nfim (nfel2 h1) @ nfel2 h2));
theorem cbvs_Seph (P Q: set x y) (h1: $ FS/ y P $) (h2: $ FS/ x Q $)
  (e: $ x = y -> P == Q $): $ |*|s x e. A, P == |*|s y e. A, Q $ =
(named '(abeqi @ aneq2i @ rexeqi @
  cbvalh (nfim nfv @ nfel2 h1) (nfim nfv @ nfel2 h2) @
  imeqd eleq1 @ eleqd ,eqtac e));
theorem cbvs_Sep (P: set x) (Q: set y) (e: $ x = y -> P == Q $):
  $ |*|s x e. A, P == |*|s y e. A, Q $ = '(cbvs_Seph nfsv nfsv e);
theorem cbvs_Seps (P: set x): $ |*|s x e. A, P == |*|s y e. A, S[y / x] P $ =
'(cbvs_Seph nfsv nfsbs1 sbsq);
theorem cbvs_Sepd (G A) (P: set x) (Q: set y)
  (h: $ G /\ x = y -> P == Q  $): $ G -> |*|s x e. A, P == |*|s y e. A, Q $ =
'(syl5eqs cbvs_Seps @ s_Sepeq2d @ syl sbset @ iald @ exp h);

theorem s_Sep_antop (A P: set x): $ |*|s x e. A, (P /\s T.s) == |*|s x e. A, P $ =
(named '(abeqi @ aneq2a @ rexeqd @ aleqd @ imeq2d @ syl5bb el_s_antop @
  syl bian1 @ sylib (isfeq @ mpbi eqlower @ resfin finns) resisf));

theorem s_Sep_0 (P: set x): $ |*|s x e. 0, P == emp $ =
(named @ focus
  '(ax_gen @ bitr4 el_s_Sep @ bitr4 elsn @ bitr _ @
    bitr (bian1a @ mpbiri isf0 isfeq) nsinj)
  '(aneq2i @ bitr (exeqi _) @ exeqe biidd)
  '(bitr (bian2 @ ax_gen @ absurd el02) @ bitr func03 @ aneq nsinj dmeq0));

theorem s_Sep_sn_sb (P: set x): $ |*|s x e. sn a, P == S[a / x] P /\s T.s $ =
(named '(ax_gen @ bitr4 el_s_Sep @ bitr4 el_s_antop @ aneq2a @
  syl5bb (exeqi @ aneq1i @
    bitr (funceq2 @ mpbi eqlower @ dmfin finns) @ bitr funcsn2 nsinj) @
  syl5bb (exeqe ,eqtac) @ syl5bb (aleqi @ imeq1i elsn) @
  syl6bbr elsbs @ syl6bbr dfsb2 @ aleqd @ syl imeq2a @ exp @ eleq1d @
  sylib (eqlower1 @ resfin finns) @ sylib eqres @
  sylib ssab2 @ iald @ exp @ apprlamed (eqcomd anllr) @
  sylibr (ellower @ dmfin finns) anr));

theorem s_Sep_sn (P: set x)
  (e: $ G /\ x = a -> P == Q $) (h: $ G -> Q C_ T.s $): $ G -> |*|s x e. sn a, P == Q $ =
'(syl5eqs s_Sep_sn_sb @ eqstrd (s_aneq1d @ sbsed e) @ sylib s_antop h);

theorem s_Sep_un_lem1: $ isfun F -> Ran (F |` Dom (F i^i Xp _V A)) C_ A $ =
(named '(sylibr ssrn @ ssrd2 @ syl5bi prelres @ exp @
  mpd (sylib eldm anrr) @ eexd @ syl5bi elin @ exp @
  mpbird (eleq1d @ preq2d @ isfd anll (anwl anrl) anrl) @ anrr));

theorem s_Sep_un_lem2 (h1: $ C C_ A u. B $)
  (h2: $ G -> func K (Dom H) (A u. B) $):
  $ G -> func (K i^i Xp _V C) (Dom (H |` Dom (K i^i Xp _V C))) C $ =
'(iand (iand (syl (isfss inss1) @ syl funcisf h2) @
    eqscomd @ syl5eqs dmres @ sylib eqin2 @
    mpbii (dmss inss1) @ sseq2d @ syl funcdm h2) @
  a1i @ mpbir ssrn inss2);

theorem s_Sep_un_lem3 (h1: $ C C_ A u. B $)
  (h2: $ G -> func K (Dom H) (A u. B) $)
  (h3: $ G -> x e. C $):
  $ G -> H |` Dom (K i^i Xp _V C) |` {y | (K i^i Xp _V C) @ y = x} ==
         H |` {y | K @ y = x} $ =
(named '(eqrd2 @ bitr4g prelres prelres @
  bitr4g (aneq prelres @ elabe ,eqtac) (aneq2i @ elabe ,eqtac) @
  syl5bb anass @ syl aneq2a @ exp @
  bitr3d (anwl @ syl isfappb @ syl (isfss inss1) @ syl funcisf h2) @
  syl5bb elin @ bitrd (syl bian2 @ sylibr prelxp @ syl (ian elv) @ anwl h3) @
  bitrd (anwl @ syl funcappb h2) @ anwr @ rsyl preldm bian1));

theorem s_Sep_un_lem4 {p z}
  (h1: $ G -> func F (Dom H) A $)
  (h2: $ G -> func F1 (Dom H1) A1 $)
  (h3: $ G -> (p <> z e. H /\ p <> x e. F <-> p <> z e. H1 /\ p <> x e. F1) $):
  $ G -> H |` {y | F @ y = x} == H1 |` {y | F1 @ y = x} $ =
(focus
  '(eqrd2 @ bitr4g prelres prelres @
    bitr4g (aneq2i @ elabe ,eqtac) (aneq2i @ elabe ,eqtac) _)
  (def (f x) '(syl aneq2a @ exp @
    bitrd (syl funcappb @ anwl ,x) @ anwr @ syl bian1 preldm))
  '(bitr3d ,(f 'h1) @ bitrd h3 ,(f 'h2)));

theorem s_Sep_un (P: set x): $ A i^i B == 0 ->
  |*|s x e. A u. B, P == |*|s x e. A, P *s |*|s x e. B, P $ =
(focus
  '(!! iald a @ bitr4g el_s_Sep el_s_sep @
    syl6bb (bian1a @ eex @ eex @ anwr heap_join_isf3) @ syl aneq2a @ exp @
    syl6bbr (exeqi @ exeqi @ aneq1a @ aneqd
      (syl5bb el_s_Sep @ syl bian1 heap_join_isf1)
      (syl5bb el_s_Sep @ syl bian1 heap_join_isf2)) @ ibid _ _)
  (focus
    (def (f x) '(!! iexde ,(dummy! 'nat) @
      sylbir (aneq2i @ eqlower2 @ infin1 finns) @ mpbird (anwr ,eqtac) @ anwl @
      iand (s_Sep_un_lem2 ,x anrl) @ sylbir anass @ imp @
      alimd @ syl5 (imim1i @ ssel ,x) @ a2d @ exp @ bi2d @
      eleq1d @ lowereqd @ s_Sep_un_lem3 ,x anlr anr))
    '(eexda @ !! iexde f @ !! iexde g @
      sylbir (aneq (aneq2i @ eqlower2 @ resfin finns) (eqlower2 @ resfin finns)) @
      sylibr (aneq2i heap_join_S) @ mpbird (rsyl (anim1 anr) ,eqtac) @ anwll @
      iand (iand ,(f 'ssun1) ,(f 'ssun2)) _)
    (have 'h1 '(syl5eqsr indi @ sylib eqin1 @ sylib (sseq2 xpundir) @
      sylib ssrn funcrn))
    '(mpbird (rsyl anrl @
        syl heap_join_res @ syl5eqsr dmun @ eqstrd (dmeqd h1) funcdm) @
      iand anlr @ mpbird (syl dmdisj @ rsyl anrl @ mpbird (isfeqd h1) funcisf) @
      syl5eqsr inindi @ syl (sseq0 inss2) @ eqstr3g xpindir xp02 @ xpeq2d anll))
  (focus
    (have 'h2
      '(mpbid (funceq2d @ anwr heap_join_dmun) @ unfunc (anwr heap_join_dmin)
        (syl (funcss3 ssun1) @ anld anllr) (syl (funcss3 ssun2) @ anld anlr)))
    '(eexd @ eexd @ impd @ impd @ eexda @ eexda @ exp @ !! iexde h @
      mpbird (rsyl (sylibr (eqlower2 @ unfin finns finns) anr) ,eqtac) @ anwl @
      iand h2 @ sylibr (aleqi @ bitr (imeq1i elun) imor) @ sylibr alan _)
    (have 'h3 $ _ -> x e. A -> ~x e. B $
      '(sylib notan2 @ mpbiri el02 @ noteqd @ syl5bbr elin @ eleq2d an4l))
    (have 'h4 $ _ -> z e. Dom f -> ~z e. Dom g $
      '(sylib notan2 @ mpbiri el02 @ noteqd @ syl5bbr elin @ eleq2d @ rsyl anlr heap_join_dmin))
    (def (f x y z u v)
      '(rsyl (iand (anim1 @ anim (anim anl anl) anl) h2) @
        aleqd @ syl imeq2a @ exp @ eleq1d @ lowereqd @
        !! s_Sep_un_lem4 p z v anlr ,x @
        bitrd (anwl @ aneqd (bitr3d (eleq2d @ syl heap_join_un anlr) (a1i elun)) (a1i elun)) @
        bitrd (aneq2d @ syl ,z @ mtd (imp ,u) @
          syl5 prelrn @ syl ssel @ syl funcrn ,y) @
        syl aneq1a @ exp @ syl ,z @ mtd (imp @ syl5 preldm @
          mpbird (imeq1d @ eleq2d @ syl funcdm ,x) (anwl ,v)) @
        a1i preldm))
    '(iand
      (mpbird ,(f 'an4lr 'an3lr 'bior2 'h3 'h4) (anrd anllr))
      (mpbird ,(f 'an3lr 'an4lr 'bior1 '(con2d h3) '(con2d h4)) (anrd anlr)))));

theorem s_Sep_ins (P: set x)
  (e: $ G /\ x = a -> P == Q $)
  (h: $ G -> Q C_ T.s $)
  (h2: $ G -> ~a e. b $):
  $ G -> |*|s x e. a ; b, P == Q *s |*|s x e. b, P $ =
'(syl5eqs (s_Sepeq1 insunsn) @ eqstrd (syl s_Sep_un @ sylibr sndisj h2) @
  s_sepeq1d @ s_Sep_sn e h);

theorem s_Sep_bij_lem (a: nat y) (b: nat x) (P: set x) (Q: set y)
  (h1: $ G /\ x e. A -> b e. B $)
  (h2: $ G /\ y e. B -> a e. A $)
  (h3: $ G /\ x e. A /\ y e. B -> (x = a <-> y = b) $)
  (h4: $ G /\ y e. B /\ x = a -> P == Q $):
  $ G -> |*|s x e. A, P C_ |*|s y e. B, Q $ =
(named @ focus
  '(iald @ sylibr (imeqi el_s_Sep el_s_Sep) @ syl anim2a @ exp @
    eexda @ sylan (!! iexe f ,eqtac) _ _)
  (focus
    '(sylibr (rlamfunc2 @ mpbi eqlower @ dmfin finns) @ iald @ exp @
      sylc _ (anw3l @ iald @ exp h1) @ syl funcT @ anim1 anrl)
    '(ealeh (nfim nfv @ nfel nfsbn1 nfsv) @ imeqd eleq1 @ eleq1d sbnq))
  (focus
    '(iald @ sylbir anass @ imp @ com23 @ exp @
      ealdeh nfv (nfel (nflower @ nfres nfsv @ nfab @
        nf_eq (nfapp (nfns @ nfrlam nfnv nfsbn1) nfnv) nfnv) nfsv) @
      eimd (mpbird (eleq1d anr) @ sylan h2 an4l anlr) @
      bi1d @ eleqd _ @ sylan h4 (iand an4l anlr) anr)
    '(lowereqd @ eqstr3g (reseq1 resdm) (reseq1 resdm) @
      eqstr4g resres resres @ reseq2d @ sylib abeqb @ iald @
      syl aneq2a @ exp @ bitr4g (elabe ,eqtac) (elabe ,eqtac) @
      bitrd (eqeq2d anlr) @ bitr4d (syl6bb eqcomb _) @
      eqeq1d @ syl (apprlame ,eqtac) @ sylibr (ellower @ dmfin finns) anr)
    '(sylan _ (iand an5l @ sylan funcT an3lr anr) anllr)
    '(!! sbethh x (nfim nfv @ nfbi nfv @ nfeq2 nfsbn1) h3 @
      imeqd ,eqtac @ bieqd eqeq1 @ eqeq2d sbnq)));

theorem s_Sep_bij (a: nat y) (b: nat x) (P: set x) (Q: set y)
  (h1: $ G /\ x e. A -> b e. B $)
  (h2: $ G /\ y e. B -> a e. A $)
  (h3: $ G /\ x e. A /\ y e. B -> (x = a <-> y = b) $)
  (h4: $ G /\ y e. B /\ x = a -> P == Q $):
  $ G -> |*|s x e. A, P == |*|s y e. B, Q $ =
'(ssasymd (s_Sep_bij_lem h1 h2 h3 h4) @
  s_Sep_bij_lem h2 h1 (bicomd @ sylbi anrass h3) @
  eqscomd @ mpand (mpbird (eleq1d anr) @ anwl h1) @
  sylan h4 (iand an3l anr) @ mpbird (syl h3 @ anim1 anl) anlr);

theorem s_Sep_uptoS2 (P: set x)
  (e: $ G /\ x = n -> P == Q $)
  (h: $ G -> Q C_ T.s $):
  $ G -> |*|s x e. upto (suc n), P == |*|s x e. upto n, P *s Q $ =
'(eqstr4g (s_Sepeq1 @ nseq uptoS_ins) s_sep_com @
  s_Sep_ins e h @ a1i @ mtbir elupto ltirr);

theorem s_Sep_uptoA (P: set x) (Q: set y)
  (e: $ G /\ x = m + y -> P == Q $):
  $ G -> |*|s x e. upto (m + n), P ==
         |*|s x e. upto m, P *s |*|s y e. upto n, Q $ =
(focus
  '(syl5eqs (s_Sepeq1 @ eqstr2 unincpl @ mpbi equn1 @ mpbir uptoss leaddid1) @
    syl5eqs (s_Sep_un inincpl) @ s_sepeq2d _)
  (def h1 '(bitr elin @ aneq elupto @ bitr elcpl @ bitr4 (noteq elupto) lenlt))
  '(s_Sep_bij
    (anwr @ sylbi ,h1 @ sylibr elupto @ mpbird (anwr ltsubadd2) anl)
    (anwr @ sylbi elupto @ sylibr ,h1 @ iand (bi1i ltadd2) @ a1i leaddid1)
    (bitr4g eqcomb eqcomb @ bicomd @ syl subadd @ anrd @ sylib ,h1 anlr)
    (syl e @ anim1 anl)));

theorem s_Sep_uptoS (P: set x) (P1: set y)
  (e0: $ G /\ x = 0 -> P == P0 $)
  (e1: $ G /\ x = suc y -> P == P1 $)
  (h: $ G -> P0 C_ T.s $):
  $ G -> |*|s x e. upto (suc n), P == P0 *s |*|s y e. upto n, P1 $ =
'(syl5eqsr (s_Sepeq1 @ nseq @ uptoeq add11) @
  eqstrd (s_Sep_uptoA @ sylbi (aneq2i @ eqeq2 add11) e1) @
  s_sepeq1d @ syl5eqs (s_Sepeq1 @ nseq upto1_sn) @ s_Sep_sn e0 h);

theorem s_Sep_subsn_lem (P: set x) (G: wff x y)
  (h1: $ G -> A. x (x e. A -> subsn P) $)
  (h2: $ G -> func F1 (Dom H1) A $)
  (h3: $ G -> A. x (x e. A -> lower (ns H1 |` {y | F1 @ y = x}) e. P) $)
  (h4: $ G -> A. x (x e. A -> lower (ns H2 |` {y | F2 @ y = x}) e. P) $)
  (h5: $ G -> a <> b e. H1 $): $ G -> a <> b e. H2 $ =
(named @ focus
  (have 'a1 '(sylc _
    (rsyl (sylibr ralan @ iand (sylibr ralan @ iand h1 h3) h4) @
      alimi @ imim2i @
      sylibr (lowerinj (resfin finns) (resfin finns)) @ subsni anll anlr anr)
    (sylan funcT h2 @ syl preldm h5)))
  (focus '(eale ,eqtac))
  '(anld @ sylib prelres @ mpbid (eleq2d a1) @
    sylibr prelres @ iand h5 @ sylibr (elabe ,eqtac) eqidd));

theorem s_Sep_subsn (P: set x): $ A. x (x e. A -> subsn P) -> subsn (|*|s x e. A, P) $ =
(named @ focus
  (def (f x y) '(s_Sep_subsn_lem an3l (anld ,x) (anrd ,x) (anrd ,y) anr))
  '(iald @ iald @ syl5bi el_s_Sep @ syl5 anr @ eexda @
  syl5bi el_s_Sep @ syl5 anr @ eexda @
  syl axext @ sylibr axext2 @ iald @ iald @ ibida ,(f 'anllr 'anlr) ,(f  'anlr 'anllr)));

@_ local def s_weak (P Q: set): wff = $ P /\s T.s C_ Q *s T.s $;
infixr s_weak: $=>*s$ prec 27;
theorem s_weak_sstop: $ P C_ T.s -> (P =>*s Q <-> P C_ Q *s T.s) $ = '(sylbi s_antop sseq1);
theorem s_weak_sstop1: $ P C_ Q *s T.s -> P =>*s Q $ =
'(mpbird (syl s_weak_sstop @ mpi s_sep_sstop sstr) id);
theorem s_weak_septop: $ P =>*s Q <-> P *s T.s C_ Q *s T.s $ =
'(bitr (ibii (sylib (sseq2 s_septop2) s_sep_ss1) @
    sstr @ mpbi (sseq1 s_antop2) s_ssseptop) (sseq1 s_sep_antop1));
theorem s_weak_iff: $ P =>*s Q <-> A. p (p e. P /\ isfun p -> E. q (q e. Q /\ q C_ p)) $ =
(named '(aleqi @ bitr (imeq1i @ bitr el_s_antop ancomb) @
  imeq2a @ syl5bb el_s_sep2 @ rexeqd @
  syl5bb (exeqi @ bian1a heap_join_sstop2) @ syl5bb heap_join_ex2 @ anwr bian1));
theorem s_weak_antop1: $ P /\s T.s =>*s Q <-> P =>*s Q $ = '(sseq1 s_antop2);
theorem s_weak_antop2: $ P =>*s Q /\s T.s <-> P =>*s Q $ = '(sseq2 s_sep_antop1);

theorem ss_s_weak: $ P C_ Q -> P =>*s Q $ =
(named '(sylibr s_weak_iff @ iald @
  syl5 anl @ syl6 (mpand (a1i ssid) @ iexe ,eqtac) ssel));

theorem s_sep_weak2: $ P =>*s Q -> R *s P =>*s R *s Q $ =
'(sylibr (s_weak_sstop s_sep_sstop) @
  sylib (sseq s_sep_antop2 @ eqscom s_sep_ass) s_sep_ss2);
theorem s_sep_weak1: $ P =>*s Q -> P *s R =>*s Q *s R $ =
'(sylib (s_weakeq s_sep_com s_sep_com) s_sep_weak2);

theorem s_weak_sepl: $ P *s Q =>*s P $ =
'(mpbir (s_weak_sstop s_sep_sstop) @ mpbi (sseq1 s_sep_antop2) @ s_sep_ss2 s_anr);
theorem s_weak_sepr: $ P *s Q =>*s Q $ = '(mpbi (s_weakeq1 s_sep_com) s_weak_sepl);

theorem s_weak_tr: $ P =>*s Q -> Q =>*s R -> P =>*s R $ = '(syl5bi s_weak_septop sstr);

theorem s_weak_split (h1: $ G -> subsn Q $) (hA: $ G -> A C_ T.s $)
  (hP: $ G -> A C_ P $) (hQ: $ G -> A =>*s Q $): $ G -> A C_ Q *s (Q -*s P) $ =
'(sylc sstr (sylibr ss_s_an @
    iand (mpbid (syl s_weak_sstop hA) hQ) hP) @ syl s_split h1);

theorem s_Sep_weak (P: set x): $ A C_ B -> |*|s x e. B, P =>*s |*|s x e. A, P $ =
'(mpbii s_weak_sepl @ s_weakeq1d @
  syl5eqsr (s_Sep_un inincpl) @ s_Sepeq1d @ syl5eqs unincpl @ bi1 equn1);

theorem s_Sep_weak1 (P: set x)
  (e: $ G /\ x = a -> P == Q $) (h: $ G -> a e. A $): $ G -> |*|s x e. A, P =>*s Q $ =
'(sylib s_weak_antop2 @
  mpbid (s_weakeq2d @ syl5eqsr s_Sep_antop @ s_Sep_sn (s_aneq1d e) @ a1i s_anr) @
  syl s_Sep_weak @ sylibr snss h);

@_ local def X86P_Input = $ b0 0 $;
@_ local def X86P_Output = $ b0 1 $;
@_ local def X86P_RIP = $ b0 2 $;
@_ local def X86P_Flags = $ b0 3 $;
@_ local def X86P_Virtual (n: nat) = $ b0 (suc (suc (suc (suc n)))) $;
@_ local def X86P_Reg (n: nat) = $ b1 (b0 n) $;
@_ local def X86P_Mem (n: nat) = $ b1 (b1 n) $;

@_ local def read_place (ks: nat): set =
$ case
    (ocase (ksIn ks)
      (ocase (ksOut ks)
        (ocase (readRIP (ksCfg ks))
          (ocase (readFlags (ksCfg ks))
            0))))
    (case
      (\ r, readReg (ksCfg ks) r)
      (\ a, getMemory (ksCfg ks) @ a <> ksMapping ks @ a)) $;

theorem read_place_Input: $ read_place ks @ X86P_Input = ksIn ks $ =
(named '(eqtr casel ocase0));
theorem read_place_Output: $ read_place ks @ X86P_Output = ksOut ks $ =
(named '(eqtr casel @ eqtr ocaseS ocase0));
theorem read_place_RIP: $ read_place ks @ X86P_RIP = readRIP (ksCfg ks) $ =
(named '(eqtr casel @ eqtr ocaseS @ eqtr ocaseS ocase0));
theorem read_place_Flags: $ read_place ks @ X86P_Flags = readFlags (ksCfg ks) $ =
(named '(eqtr casel ,(iterate 3 (fn (x) '(eqtr ocaseS ,x)) 'ocase0)));
theorem read_place_Virtual: $ read_place ks @ X86P_Virtual n = 0 $ =
(named '(eqtr casel ,(iterate 4 (fn (x) '(eqtr ocaseS ,x)) 'app01)));
theorem read_place_Reg: $ read_place ks @ X86P_Reg r = readReg (ksCfg ks) r $ =
(named '(eqtr caser @ eqtr casel @ applame ,eqtac));
theorem read_place_Mem: $ read_place ks @ X86P_Mem a = getMemory (ksCfg ks) @ a <> ksMapping ks @ a $ =
(named '(eqtr caser @ eqtr caser @ applame ,eqtac));

theorem read_place_setMemory_ne: $ ~E. a p = X86P_Mem a ->
  read_place (setCfg ks (setMemory (ksCfg ks) m)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setMemory)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setMemory)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_setMemory)) +
     ($X86P_Mem n$ => (impcom @ syl absurdr @ iexe ,eqtac))}});
theorem read_place_setMemory_eq:
  $ read_place (setCfg ks (setMemory (ksCfg ks) m)) @ X86P_Mem a = m @ a <> ksMapping ks @ a $ =
'(eqtr read_place_Mem @
  preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) get_setMemory) @
  appneq1 ksMapping_setCfg);

@_ local def XBlock_Reg (n: nat) = $ b0 (b0 n) $;
@_ local def XBlock_Mem (a len: nat) = $ b0 (b1 (a <> len)) $;
@_ local def XBlock_Const (val: nat) = $ b1 val $;

@_ local def MSize = $ 0 ; 8 ; 16 ; 32 ; sn 64 $;
@_ local def MSize_bytes (sz: nat) = $ sz // 8 $;

@_ local def ksFault (k: nat): wff =
$ k e. KernelState /\ readException (ksCfg k) = suc exGPF $;

theorem ksFault_setException: $ k e. KernelState ->
  ksFault (setCfg k (setException (ksCfg k) (suc exGPF))) $ =
(named '(iand (sylan setCfgExceptionT id @ a1i @ mpbir optS exGPFT) @
  a1i @ eqtr (readExceptioneq ksCfg_setCfg) read_setException));

theorem ksFault_terminates: $ ksFault k -> terminates_ensuring k T $ =
'(sylan terminates_ensuring_fail
  (anim2a @ exp @ iand (iand (syl ksCfgT anl) @ a1i d1elu32) @
    orld @ iand anr @ a1i d1ne0) (a1i d1ne0));

theorem ksFault_can_terminate: $ ksFault k -> can_terminate_ensuring k T $ =
'(syl terminates_ensuring_can ksFault_terminates);

@_ local def heap_sat (k h: nat): wff =
$ isfun h /\ k e. KernelState /\ A. p A. x (p <> x e. h -> read_place k @ p = x) $;
infixl heap_sat: $|=h$ prec 50;

theorem heap_sat_isf: $ k |=h h -> isfun h $ = (named 'anll);
theorem heap_sat_ks: $ k |=h h -> k e. KernelState $ = (named 'anlr);

theorem heap_sat_sn: $ k |=h sn (p <> x) <-> k e. KernelState /\ read_place k @ p = x $ =
'(aneq (bian1 isfsn) @ bitr (aleqi @ bitr (aleqi @
    bitr (imeq1i @ bitr elsn prth) impexp) alim1) @
  aleqe @ syl5bb (aleqe ,eqtac) ,eqtac);

theorem heap_sat_E: $ k |=h h /\ p <> x e. h -> read_place k @ p = x $ =
'(impcom @ syl5 anr @ com12 @ ealie @ ealde @ bi1d ,eqtac);

@_ local def s_sat (k: nat) (P: set): wff = $ ksFault k \/ E. h (h e. P /\ k |=h h) $;
infixl s_sat: $|=s$ prec 50;
theorem s_sat_fault: $ ksFault k -> k |=s P $ = (named 'orl);
theorem s_sat_def: $ ~ksFault k -> (k |=s P <-> E. h (h e. P /\ k |=h h)) $ = 'bior1;
theorem s_sat_antop: $ k |=s P /\s T.s <-> k |=s P $ =
(named '(oreq2i @ exeqi @ aneq1a @ syl5bb el_s_antop @ syl bian1 heap_sat_isf));
theorem s_sat_ks: $ k |=s P -> k e. KernelState $ =
(named '(eor anl @ eex @ anwr heap_sat_ks));

theorem s_sat_sep_sn: $ ~ksFault k -> (k |=s R *s P <-> E. r (r e. R /\ k |=s sn r *s P)) $ =
(named '(bitr4d (syl6bb (exeqi ancomb) s_sat_def) @
  bitrd (rexeqd @ syl6bb (exeqi ancomb) s_sat_def) @ a1i @
  bitr4 rexcomb @ rexeqi @ bitr4 el_s_sep2 @ rexeqi el_s_sep_sn1));

theorem s_sat_sn: $ ~ksFault k -> (k |=s sn h <-> k |=h h) $ =
'(bitrd s_sat_def @ a1i @ bitr (exeqi @ aneq1i elsn) @ exeqe ,eqtac);

theorem s_sat_ex (P: set x): $ ~ksFault k -> (k |=s E.s x e. A, P <-> E. x (x e. A /\ k |=s P)) $ =
(named '(bitr4d s_sat_def @ bitr4d (rexeqd s_sat_def) @
  a1i @ bitr4 (exeqi @ bitr4 (aneq1i el_s_ex) rexan2) rexexcomb));

theorem s_sat_anlift1: $ ~ksFault k -> (k |=s ^s p /\s P <-> p /\ k |=s P) $ =
(named '(bitr4d s_sat_def @ bitr4d (aneq2d s_sat_def) @ a1i @
  bitr (exeqi @ bitr (aneq1a @
    syl5bb el_s_an @ aneq1d @ syl5bb el_s_lift @ syl bian1 heap_sat_isf) anass) @
  exan1));

theorem heap_sat_rlam: $ k |=h h /\ Dom h == a -> h = \. p e. a, read_place k @ p $ =
(named '(sylibr eqrlam @ iand (anim1 anll) @ mpd anlr @
  alimd @ com23 @ syld (bi2d @ eleq2d anr) @ syl5bi eldm @
  com23 @ syl6ibr eexb @ alimd @ a2d @ exp @ syl5ibrcom eqeq2 @ isfappd an4l anr));
theorem rlam_heap_sat: $ k e. KernelState -> k |=h \. p e. a, read_place k @ p $ =
(named '(iand (ian rlamisf) @ a1i @ ax_gen @ ax_gen @ sylbi elrlam @
  eex @ anwr @ sylbi prth @ mpbiri eqid @ eqeqd (appeq2d anl) anr));

theorem heap_sat_ss: $ q C_ p -> k |=h p -> k |=h q $ =
(named '(animd (anim1d isfss) @ alimd @ alimd @ imim1d ssel));

theorem s_weak_sat: $ P =>*s Q -> k |=s P -> k |=s Q $ =
(named '(sylbi s_weak_iff @ orim2d @ sylibr eexb @ alimi @ impd @ sylbi impexp @
  imim2i @ rsyl (imim1i heap_sat_isf) @ ax_2 @ eximd @ anim2d @ com12 heap_sat_ss));

theorem s_sat_an: $ k |=s P /\s Q -> k |=s P /\ k |=s Q $ =
'(iand (s_weak_sat @ ss_s_weak s_anl) (s_weak_sat @ ss_s_weak s_anr));

theorem s_sat_sep: $ k |=s P *s Q -> k |=s P /\ k |=s Q $ =
'(iand (s_weak_sat s_weak_sepl) (s_weak_sat s_weak_sepr));

@_ local def prog_ok (elf i: nat) (P: set): wff =
$ A. k (initialConfig2 elf i k -> terminates_ensuring k P) $;

@_ local def s_ok (P T: set): wff =
$ A. k (k |=s P -> terminates_ensuring k T) $;

theorem s_ok_def: $ s_ok P T <-> A. k (E. h (h e. P /\ k |=h h) -> terminates_ensuring k T) $ =
'(aleqi @ imeq1a @ rsyl (con3 ksFault_terminates) s_sat_def);
theorem s_ok_def2: $ s_ok P T <-> A. k (~ksFault k -> E. h (h e. P /\ k |=h h) -> terminates_ensuring k T) $ =
'(bitr4 s_ok_def @ aleqi @ bior1a @ a1d ksFault_terminates);

theorem s_ok_E: $ s_ok P T -> k |=s P -> terminates_ensuring k T $ = '(eale ,eqtac);

theorem s_ok_antop: $ s_ok (P /\s T.s) T <-> s_ok P T $ =
(named '(aleqi @ imeq1i s_sat_antop));

theorem s_ok_sep: $ s_ok (R *s P) T <-> A. r (r e. R -> s_ok (sn r *s P) T) $ =
(named @ focus
  '(bitr (aleqi _) @ bitr alcomb @ aleqi alim1)
  '(bitr (imeq1a @ rsyl (con3 ksFault_terminates) s_sat_sep_sn) @ bitr eexb @ aleqi impexp));

theorem s_weak_ok: $ P =>*s Q -> s_ok Q T -> s_ok P T $ =
(named '(alimd @ imim1d s_weak_sat));

--| The separation logic hoare predicate.
--| It is parameterized by a final state predicate `T` that covers the property
--| to hold on early termination, and builds in the frame rule
--| (quantifying over a heap `fr` separate from `P` and `Q`).
--| The "code" part of the hoare triple is absent because this is stored in the
--| machine state; we will use top level predicates that contain the code segment
@_ local def hoare (T P Q: set): wff =
$ A. fr (s_ok (sn fr *s Q) T -> s_ok (sn fr *s P) T) $;

theorem hoare_frame_ok: $ hoare T P Q -> s_ok (R *s Q) T -> s_ok (R *s P) T $ =
(named '(sylibr (imeqi s_ok_sep s_ok_sep) @ syl ax_4 @ alimi imim2));
theorem hoare_ok: $ hoare T P Q -> s_ok Q T -> s_ok P T $ =
(let ([h '(bitr (s_okeq1 s_sep_emp1a) s_ok_antop)])
  '(sylib (imeqi ,h ,h) hoare_frame_ok));
theorem s_weak_hoare: $ P =>*s Q -> hoare T P Q $ =
(named '(iald @ syl s_weak_ok s_sep_weak2));
theorem hoare_id: $ hoare T P P $ = (named '(ax_gen id));
theorem hoare_tr: $ hoare T P Q -> hoare T Q R -> hoare T P R $ =
(named '(syl ax_4 @ alimi imim2));

-- The famous "frame rule" of separation logic.
theorem hoare_frame: $ hoare T P Q -> hoare T (R *s P) (R *s Q) $ =
(named '(iald @ sylib (imeqi (s_okeq1 s_sep_ass) (s_okeq1 s_sep_ass)) hoare_frame_ok));

theorem hoare_save_restore_lem (G: wff p)
  (hA: $ G -> finite A $)
  (hp: $ G -> p e. P $)
  (h1: $ G -> Dom p i^i A == 0 $)
  (h2: $ G -> heap_join fr p = suc fp $)
  (h3: $ G -> k |=h fp $):
  $ G -> E. a E. a1 E. af E. f1 E. afp (Dom a == A /\
      heap_join a1 af = suc a /\
      heap_join fp a1 = suc afp /\
      heap_join f1 af = suc fr /\
      k |=h afp) $ =
(focus
  (foldr '($A$  $ A i^i Compl (Dom fr) $  $ A i^i Dom fr $
    $ Dom fr i^i Compl A $  $ Dom fp u. A $) _
    (fn (x y) '(! iexde _ _ $ \. x e. lower ,x, _ $ _ ,y)))
  '(mpbird ,eqtac @ anw5l @ iand (iand (iand (iand _ _) _) _) _)
  (def A '(mpbi eqlower @ infin1 _))
  (have 'ha '(sylib eqlower hA))
  (have 'hb '(sylib eqlower @ syl infin1 hA))
  (have 'hc '(sylib eqlower @ syl infin1 hA))
  (have 'hd '(a1i @ mpbi eqlower @ infin1 @ dmfin finns))
  (have 'hp '(a1i @ mpbi eqlower @ dmfin finns))
  (have 'hfr '(a1i @ mpbi eqlower @ dmfin finns))
  (have 'hy '(sylib eqlower @ syl (unfin @ dmfin finns) hA))
  (def (f x y) '(sylan heap_sat_rlam ,x ,y))
  (focus '(syl5eqs dmrlam @ eqscomd ha))
  (focus
    '(mpbiri (iani _ _) @ sylan heap_join_rlam2 (iand hb hc) ha)
    '(eqstr3 inindi @ sseq0 inss2 incpl1)
    '(eqstr3 indi @ mpbi eqin1 @ mpbir (sseq2 uncpl1) ssv2))
  (focus
    '(eqtrd (heap_joineq1d ,(f 'h3 'hp)) @
      mpbird (sylan heap_join_rlam2 (iand hp hb) hy) @
      iand (eqstr3d (ineq1d @ syl heap_join_dmun h2) @
        syl5eqs indir @ sylibr uneq0 @ iand (a1i @ mpbir ineq0r inss2) @
        syl (sseq0 @ ssin2 inss1) h1) @
      !! iald x @ bitr4g elun elun @ syl oreq2a @ syl6 (syl5bb elin bian2) @
        syl6ibr elcpl @ con3d @ syl ssel @ syl dmss @ anld @ syl heap_join_ss h2))
  (focus
    '(eqtr4d (mpbiri (iani _ _) @ sylan heap_join_rlam2 (iand hd @ syl5eqs incom hc) hfr) @
      suceqd ,(f '(mpd h3 @ rsyl h2 @ syl heap_sat_ss @ anld heap_join_ss) 'hfr))
    '(eqstr3 inindi @ sseq0 inss2 incpl1)
    '(eqstr3 indi @ mpbi eqin1 @ mpbir (sseq2 uncpl1) ssv2))
  (focus '(syl rlam_heap_sat @ syl heap_sat_ks h3)));

--| A partial inverse to the frame rule: we can "unframe" by some heap `a`
--| with specified domain `A`. This allows us to prove that as long as we return
--| the values to what they were, we are permitted to capture things not in
--| the heap of `P`. This is useful for e.g. proving that callee-saved registers
--| can be used in a function and restored at the end, without the caller having
--| to pass them in.
theorem hoare_save_restore (G: wff p a)
  (hA: $ G -> finite A $)
  (h1: $ G -> A. p (p e. P -> Dom p i^i A == 0) $)
  (h2: $ G -> A. a (Dom a == A -> hoare T (sn a *s P) (sn a *s Q)) $):
  $ G -> hoare T P Q $ =
(named @ focus
  '(!! iald fr @ exp @ sylibr s_ok_def @ iald @ eexd @
    impd @ syl5bi el_s_sep_sn1 @ eexda @ exp @
    mpd (hoare_save_restore_lem (anw3l hA) (anld anlr) _ (anrd anlr) anr) _)
  (focus '(sylc _ (anw3l h1) (anld anlr)) '(eale ,eqtac))
  '(eexd @ eexd @ eexd @ eexd @ eexda @ sylc eal {_ : $ _ -> s_ok _ _ $} _)
  (focus
    '(sylc hoare_frame_ok _ @ sylc s_weak_ok _ an3lr)
    (focus '(sylc _ (anw4l h2) @ anwr an4l) '(eale ,eqtac))
    '(sylib (s_weakeq1 s_sep_ass) @ syl s_sep_weak1 @
      mpbii (s_sep_weak1 @ s_weak_sepl) @ anwr @ s_weakeqd (syl5eqs s_sep_ass @
        s_sepeq2d @ sylibr s_sep_sn an3lr) @ sylibr s_sep_sn anlr))
  (focus
    '(orrd @ sylan iex (mpbird (eleq2d _) @ sylibr el_s_sep_sn1 _) anrr)
    '(anwr @ eqstr3g s_sep_ass s_sep_ass @ s_sepeq1d @
      eqstr3d (s_sepeq2d @ syl5eqs s_sep_com @ sylibr s_sep_sn an3lr) @
      syl5eqsr s_sep_ass @ syl6eqs s_sep_com @ s_sepeq1d @ sylibr s_sep_sn anlr)
    '(sylan iex (sylibr el_s_sep_sn1 _) (anwr @ syl5eq heap_join_com anllr))
    '(sylan iex (anld anllr) (anrd anllr))));

--| A hoare triple with explicit "modification" operand `R`, without reference to the
--| step relation as in `hoare`. This is useful for carrying hoare triple information
--| through the sub-steps of an instruction.
@_ local def hoareM (P R Q: set): wff =
$ A. fr A. k (k |=s sn fr *s P ->
    k e. Dom R /\
    A. k2 (k <> k2 e. R -> (ksFault k -> ksFault k2) /\ k2 |=s sn fr *s Q)) $;

theorem hoareM_step: $ hoareM P (S\ ks, {ks2 | ksStep ks ks2}) Q -> hoare T P Q $ =
(named '(alimi @ com12 @ !! alimd k1 @ a2d @
  expcom @ exp @ sylibr terminates_ensuring_val @
  iand (anwll s_sat_ks) @ !! iald k @ syl5bi ksReachable_hd @
  eord (syl5ibrcom (rsyl (anwr eqcom) ,eqtac) @
    imp @ impd @ syl5bi eldm @ com23 @ syl6ibr eexb @ !! alimd k2 @ a2d @
    syl5bi (elsabe @ elabed ,eqtac) @ exp @ syl5 anr @ syld (rsyl anlr s_ok_E) @
    syl5 terminates_ensuring_can @ anwr @ syl can_terminate_ensuring_R ksReachable1) @
  sylibr eexb @ imp @ syl5 anr @ alimd @
  syl5 (imim1i @ sylibr (elsabe @ elabed ,eqtac) anl) @
  a2d @ exp @ syl5 anr @ syld (rsyl anlr s_ok_E) @
  syl6 terminates_ensuring_can @ rsyl anrr terminates_ensuring_R));

theorem hoareM_co: $ hoareM P1 R P2 -> hoareM P2 S P3 -> hoareM P1 (R o> S) P3 $ =
(named '(syl ax_4 @ !! alimi fr @ com12 @ !! alimd k1 @ imim2d @ exp @
  iand (imp @ impd @ syl5bi eldm @ com23 @ syl6ibr eexb @ syl ax_4 @ !! alimi k2 @ a2d @
    com12 @ imimd (a1i anr) @ syl5 anl @ syl5bi eldm @ syl6ibr eldm @
    !! eximd k3 @ exp @ sylibr prco iex) @
  sylibr (aleqi @ bitr (imeq1i prco) erexb) @ sylib ralalcomb @ imp @ syl5 anr @
  syl ax_4 @ alimi @ imim2d @ impd @ com12 @ imim2d @ syl5 anr @
  alimd @ imim2d @ anim1d imim1));

theorem hoareM_ex: $ hoareM P R Q -> k |=s P -> k e. Dom R $ =
(named '(rsyl (ealie @ ealde @ bi1d ,eqtac) @
  imim (bi2i @ bitr (s_sateq2 s_sep_emp1a) s_sat_antop) anl));

theorem hoareM_fault: $ hoareM P R Q -> k <> k2 e. R -> ksFault k -> ksFault k2 $ =
(named '(rsyl (ealie @ ealde @ bi1d ,eqtac) @
  expd @ com12 @ eimd (anwr s_sat_fault) @ syl5 anr @
  syl5 (eale ,eqtac) @ com12 @ impd @ imim2i anl));

theorem hoareM_frame_E: $ hoareM P R Q -> k |=s F *s P ->
  k e. Dom R /\ A. k2 (k <> k2 e. R -> (ksFault k -> ksFault k2) /\ k2 |=s F *s Q) $ =
(named @ focus
  '(exp @ iand (imp @ syl5 (s_weak_sat s_weak_sepr) hoareM_ex) @ iald @ exp _)
  (have 'h '(sylc hoareM_fault anll anr))
  '(iand h @ casesda (anwr s_sat_fault) @ mpbird (anwr s_sat_sep_sn) @
    mpd (mpbid (syl s_sat_sep_sn @ imp @ con3d h) anllr) @
    syl exim @ mpd an3l @ alimd @ syl6 anim2 @
    syl5 (eale ,eqtac) @ imim2d @ syl5 anr @ rsyl anlr @ com12 @ syl6 anr @ eale ,eqtac));

theorem hoareM_E: $ hoareM P R Q -> k <> k2 e. R -> k |=s P -> k2 |=s Q $ =
(focus (def h '(bitr (s_sateq2 s_sep_emp1a) s_sat_antop))
  '(com23 @ syl5bir ,h @ syl6 _ hoareM_frame_E)
  '(anwr @ syl6ib ,h @ syl6 anr @ eale ,eqtac));

theorem hoareM_frame: $ hoareM P R Q -> hoareM (F *s P) R (F *s Q) $ =
(named '(iald @ iald @ exp @ sylib (aneq2i @ aleqi @ imeq2i @ aneq2i @ s_sateq2 s_sep_ass) @
  imp @ syl5bir (s_sateq2 s_sep_ass) hoareM_frame_E));

-- theorem hoareM_anlift1: $ hoareM (^s p /\s P) R Q <-> (p -> hoareM P R Q) $ =
-- (named '(bitr (aleqi @ bitr (aleqi @ bitr (imeq1i @
--   bitr (s_sateq2 s_sep_anlift2) @ s_sat_anlift1 _) impexp) alim1) alim1));

@_ local def nofaultI: set = $ S\ k, {k2 | ~ksFault k /\ k = k2} $;

theorem el_nofaultI: $ k <> k2 e. nofaultI <-> ~ksFault k /\ k = k2 $ =
'(elsabe @ elabed ,eqtac);
theorem nofaultI_co: $ k <> k2 e. nofaultI o> R <-> ~ksFault k /\ k <> k2 e. R $ =
'(bitr prco @
  bitr (exeqi @ bitr (aneq1i el_nofaultI) anass) @
  bitr exan1 @ aneq2i @ bitr (exeqi @ aneq1i eqcomb) @ exeqe ,eqtac);
theorem co_nofaultI: $ k <> k2 e. R o> nofaultI <-> ~ksFault k2 /\ k <> k2 e. R $ =
'(bitr prco @
  bitr (exeqi @ bitr (aneq2i el_nofaultI) @ bitr3 anass ancomb) @
  exeqe @ syl5bb ancomb ,eqtac);

@_ local def gsRel (G S R: set): set =
$ S\ a, {a2 | E. b (G @ a <> b e. R /\ a2 = S @ (a <> b))} $;

@_ local def gsRel_ok (G S: set): wff =
$ A. a A. b (G @ (S @ (a <> b)) = b /\
    A. c S @ (S @ (a <> b) <> c) = S @ (a <> c)) $;

theorem gsRel_ok_GS (h: $ gsRel_ok G S $): $ G @ (S @ (a <> b)) = b $ =
(named @ focus '(ealie (ealde @ bi1d _) @ !! alimi x (!! alimi y anl) h) eqtac);
theorem gsRel_ok_SS (h: $ gsRel_ok G S $): $ S @ (S @ (a <> b) <> c) = S @ (a <> c) $ =
(focus '(ealie (ealde @ ealde @ bi1d _) @ !! alimi x (!! alimi y anr) h) eqtac);

theorem el_gsRel: $ a <> a2 e. gsRel G S R <->
  E. b (G @ a <> b e. R /\ a2 = S @ (a <> b)) $ = '(elsabe @ elabed ,eqtac);

theorem gsRel_co (h: $ gsRel_ok G S $):
  $ gsRel G S (R1 o> R2) == gsRel G S R1 o> gsRel G S R2 $ =
'(mpbir axext2 @ !! ax_gen a1 @ !! ax_gen a3 @
  bitr4 (bitr el_gsRel @
    bitr4 (!! exeqi b2 @ bitr4 (aneq1i @ !! prco b1) rexan2) rexexcomb) @
  bitr (bitr prco @
    bitr4 (!! exeqi a2 @ bitr4 (aneq el_gsRel el_gsRel) rexan2) rexexcomb) @
  rexeqi @ exeqe @ exeqd @ aneqd
    (eleq1d @ preq1d @ syl6eq (gsRel_ok_GS h) appeq2)
    (eqeq2d @ syl6eq (gsRel_ok_SS h) @ appeq2d preq1));

theorem eldm_gsRel: $ a e. Dom (gsRel G S R) <-> G @ a e. Dom R $ =
(named '(bitr4 eldm @ bitr4 eldm @ bitr4 (exeqi el_gsRel) @
  biexexi @ bitr2 exan1 @ bian2 ax_6));

@_ local def viaMemory (R: set): set =
$ gsRel (\ k, getMemory k) (\\ k, \ m, setMemory k m) R $;

theorem el_viaMemory: $ k <> k2 e. viaMemory R <->
  E. m (getMemory k <> m e. R /\ k2 = setMemory k m) $ =
'(bitr el_gsRel @ exeqi @ aneq (eleq1 @ preq1 @ applame getMemoryeq) @
  eqeq2 @ appslame @ applamed ,eqtac);

theorem eldm_viaMemory: $ k e. Dom (viaMemory R) <-> getMemory k e. Dom R $ =
(named '(bitr eldm_gsRel @ eleq1 @ applame ,eqtac));

theorem viaMemory_ok: $ gsRel_ok (\ k, getMemory k) (\\ k, \ m, setMemory k m) $ =
(named '(ax_gen @ ax_gen @ iani
  (eqtr (appeq2 @ appslame @ applamed ,eqtac) @
    applame @ syl6eq get_setMemory ,eqtac) @
  ax_gen @ eqtr (appeq2 @ preq1 @ appslame @ applamed ,eqtac) @
  eqtr4 (appslame @ applamed ,eqtac) @
  eqtr4 (appslame @ applamed ,eqtac) set_setMemory));

theorem viaMemory_co: $ viaMemory (R o> S) == viaMemory R o> viaMemory S $ =
(named '(gsRel_co viaMemory_ok));

theorem viaMemory_fault {m m2}
  (h: $ m <> m2 e. R -> m e. Memory -> m2 e. Memory /\
        PageMapping m C_ PageMapping m2 $):
  $ k <> k2 e. viaMemory R ->
    k e. Config /\ readException k = suc exGPF ->
    k2 e. Config /\ readException k2 = suc exGPF /\
    PageMapping (getMemory k) C_ PageMapping (getMemory k2) $ =
'(sylbi el_viaMemory @ eex @ exp @ mpbird ,eqtac @
  mpand (sylc (!! sbeth m h ,eqtac) anll @ syl getMemoryT anrl) @
  iand (iand (sylan setMemoryT (anld anlr) anrl) @
    syl5eq readException_setMemory @ anwl anrr) @
  sylibr (sseq2 @ PageMappingeq get_setMemory) anrr);

@_ local def viaCfg (R: set): set =
$ gsRel (\ ks, ksCfg ks) (\\ ks, \ k, setCfg ks k) R $;

theorem el_viaCfg: $ ks <> ks2 e. viaCfg R <->
  E. k (ksCfg ks <> k e. R /\ ks2 = setCfg ks k) $ =
'(bitr el_gsRel @ exeqi @ aneq (eleq1 @ preq1 @ applame ksCfgeq) @
  eqeq2 @ appslame @ applamed ,eqtac);

theorem eldm_viaCfg: $ k e. Dom (viaCfg R) <-> ksCfg k e. Dom R $ =
(named '(bitr eldm_gsRel @ eleq1 @ applame ,eqtac));

theorem viaCfg_ok: $ gsRel_ok (\ ks, ksCfg ks) (\\ ks, \ k, setCfg ks k) $ =
(named '(ax_gen @ ax_gen @ iani
  (eqtr (appeq2 @ appslame @ applamed ,eqtac) @
    applame @ syl6eq ksCfg_setCfg ,eqtac) @
  ax_gen @ eqtr (appeq2 @ preq1 @ appslame @ applamed ,eqtac) @
  eqtr4 (appslame @ applamed ,eqtac) @
  eqtr4 (appslame @ applamed ,eqtac) set_setCfg));

theorem viaCfg_co: $ viaCfg (R o> S) == viaCfg R o> viaCfg S $ =
(named '(gsRel_co viaCfg_ok));

theorem viaCfg_fault {k k2}
  (h: $ k <> k2 e. R ->
      k e. Config /\ readException k = suc exGPF ->
      k2 e. Config /\ readException k2 = suc exGPF /\
      PageMapping (getMemory k) C_ PageMapping (getMemory k2) $):
  $ ks <> ks2 e. viaCfg R -> ksFault ks -> ksFault ks2 $ =
'(sylbi el_viaCfg @ eex @ exp @ mpbird (ksFaulteqd anlr) @
  mpand (sylc (!! sbeth k h ,eqtac) anll @ anwr @ anim1 ksCfgT) @
  iand (mpbird (syl setCfgT @ anld anlr) @ iand (anwr anll) @
    sylc ssel anrr @ syl ksMappingT @ anld anlr) @
  syl5eq (readExceptioneq ksCfg_setCfg) @ anwr anlr);

@_ local def withEx (R: set): set =
$ S\ k, {k2 | ifp (ksFault k)
    (ksFault k2)
    (E. e (e e. Option Exception /\
      E. ki (e <> ksCfg k <> ki e. R /\ k2 = setCfg k (setException ki e))))} $;

theorem el_withEx:
  $ k <> k2 e. withEx R <-> ifp (ksFault k)
    (ksFault k2) (E. e (e e. Option Exception /\
      E. ki (e <> ksCfg k <> ki e. R /\ k2 = setCfg k (setException ki e)))) $ =
'(elsabe @ elabed ,eqtac);

theorem withEx_fault: $ k <> k2 e. withEx R -> ksFault k -> ksFault k2 $ =
(named '(sylbi el_withEx @ com12 @ bi1d ifppos));

theorem el_withEx_nofault:
  $ ~ksFault k -> (k <> k2 e. withEx R <-> E. e (e e. Option Exception /\
      E. ki (e <> ksCfg k <> ki e. R /\ k2 = setCfg k (setException ki e)))) $ =
'(syl5bb el_withEx ifpneg);

theorem eldm_withEx:
  $ k e. Dom (withEx R) <-> ksFault k \/
      E. e (e e. Option Exception /\ ksCfg k e. Dom (R @' e)) $ =
(named @ focus
  '(bitr eldm @ bitr (exeqi el_withEx) @ cases _ _)
  '(bithd (iexde @ mpbird (anwl ifppos) @ mpbird ,eqtac @ anwll ksFault_setException) orl)
  '(bitr4d (syl6bbr (biexrexi _) @ exeqd ifpneg) bior1)
  '(bitr eldm @ bitr (exeqi @ bitr4 elrapp @ bian2 ax_6) rexexcomb));

--| The primitive memory heaplet: `s_mem1 p a v` says that
--| address `a` is mapped with permission `p`,
--| and if the data at `a` is readable then the value is `v`.
@_ local def s_mem1 (p a v): set =
$ ^s (a e. u64 /\ v e. u8 /\ p e. Prot) /\s
    sn (sn (X86P_Mem a <> ((p <> v) <> suc p))) $;

theorem el_s_mem1: $ h e. s_mem1 p a v <->
  a e. u64 /\ v e. u8 /\ p e. Prot /\
  h = sn (X86P_Mem a <> ((p <> v) <> suc p)) $ =
'(bitr el_s_an @ bitr (aneq el_s_lift elsn) @
  aneq1a @ syl bian1 @ mpbiri isfsn @ isfeqd nseq);

theorem s_mem1_subsn: $ subsn (s_mem1 p a v) $ = '(subsnss s_anr subsnsn);
theorem s_mem1_sstop: $ s_mem1 p a v C_ T.s $ = '(sstr s_anl s_lift_sstop);

theorem s_mem1_readMemory1:
  $ ~ksFault k /\ k |=s s_mem1 p a v /\ ps C_ p ->
    readMemory1 ps (getMemory (ksCfg k)) a v $ =
(named '(sylbi anrass @ imp @ mpbird (imeq1d @ anwl s_sat_def) @
  eexd @ impd @ syl5bi el_s_mem1 @ impd @ exp @
  syl5ibrcom (imeq1d heap_sateq2) @ syl5bi heap_sat_sn @
  impd @ exp @ syl5bi (eqeq1 read_place_Mem) @ syl5bi prth @ exp @
  iand (iand (syl getMemoryT @ syl ksCfgT anlr) @ syl anll anllr) @
  syl (iexe ,eqtac) @ iand anrl an3lr));

@_ local def setMem1 (m a v: nat): nat = $ lower (write m a (fst (m @ a) <> v)) $;

theorem setMem1_eqs: $ m @ a = p <> w -> setMem1 m a v == write m a (p <> v) $ =
'(syl5eqsr (mpbi eqlower @ writefin finns) @ writeeq3d @ preq1d @ syl6eq fstpr fsteq);
theorem setMem1_ne: $ b != a -> setMem1 m a v @ b = m @ b $ =
'(syl5eq (appeq1 @ setMem1_eqs @ eqcom fstsnd) writeNe);
theorem setMem1_eq: $ m @ a = p <> w -> setMem1 m a v @ a = p <> v $ =
'(syl6eq writeEq (appeq1d setMem1_eqs));

theorem setMem1T (h1: $ G -> m e. Memory $) (h2: $ G -> a e. u64 $) (h3: $ G -> v e. u8 $):
  $ G -> setMem1 m a v e. Memory $ =
'(write_el_Memory h1 h2 (syl xpfst @ sylan elMemoryT h1 h2) h3 @
  syl setMem1_eqs @ a1i @ eqcom fstsnd);

theorem setMem1PM: $ PageMapping m C_ PageMapping (setMem1 m a v) $ =
'(trud @ writePM (a1i @ eqcom fstsnd) @ a1i @ eqscom @ mpbi eqlower @ writefin finns);

theorem s_mem1_writeMemory1a
  (h1: $ G -> ~ksFault k $)
  (h2: $ G -> v e. u8 $)
  (h3: $ G -> k |=s s_mem1 p a w $):
  $ G -> (writeMemory1 (getMemory (ksCfg k)) a v m2 e <->
    ifp (PROT_READ + PROT_WRITE C_ p)
      (m2 = setMem1 (getMemory (ksCfg k)) a v /\ e = 0)
      (m2 = getMemory (ksCfg k) /\ e = suc exGPF)) $ =
(focus
  '(mpd h3 @ syld (bi1d @ syl s_sat_anlift1 h1) @ impd @ exp @
    syld (bi1d @ syl s_sat_sn @ anwl h1) @ syl5bi heap_sat_sn @ impd @ exp @
    syl5bi (bitr (eqeq1 read_place_Mem) prth) @ exp @
    bitrd (sylan bian1 (iand (syl getMemoryT @ syl ksCfgT anlr) @
      rsyl anllr anll) (anw3l h2)) @
    syl6bb (bian1 expr) @ syl6bb exan2 @ !! exeqd pr @ syl6bb exan2 @ !! exeqd b2 @
    aneq2da @ bitr2d (rsyl (sylib prth @ eqtr3d (anld anlr) anr) ,eqtac) @
    ifpeqd biidd (aneq1d @ syl5bbr nsinj @ eqseq2d @ anwr setMem1_eqs)
      (a1i @ aneq1i @ bicom nsinj)));

theorem s_mem1_writeMemory1
  (h1: $ G -> ~ksFault k $)
  (h2: $ G -> e != suc exGPF $)
  (h3: $ G -> v e. u8 $)
  (h4: $ G -> k |=s s_mem1 p a w $):
  $ G -> (writeMemory1 (getMemory (ksCfg k)) a v m2 e <->
    PROT_READ + PROT_WRITE C_ p /\ e = 0 /\ m2 = setMem1 (getMemory (ksCfg k)) a v) $ =
'(bitrd (s_mem1_writeMemory1a h1 h3 h4) @
  syl6bb (bitr3 anass anrass) (syl bior2 @ rsyl h2 @ con3 anrr));

@_ local def writeMemory1R (a v) =
$ withEx (S\ e, viaMemory (S\ m, {m2 | writeMemory1 m a v m2 e})) $;

theorem el_writeMemory1R:
  $ ~ksFault ks -> (ks <> ks2 e. writeMemory1R a v <->
    E. e (e e. Option Exception /\
    E. m2 (writeMemory1 (getMemory (ksCfg ks)) a v m2 e /\
      ks2 = setCfg ks (setException (setMemory (ksCfg ks) m2) e)))) $ =
(focus
  '(syl6bb (rexeqi _) el_withEx_nofault)
  '(bitr (exeqi @ aneq1i @ elsabe @ syl5bb el_viaMemory @
      exeqd @ aneq1d @ elsabed @ elabed ,eqtac) @
    bitr (birexexi @ birexan1i biid) @ rexeqi @ exeqe ,eqtac));

theorem eldm_writeMemory1R:
  $ ks e. Dom (writeMemory1R a v) <-> ksFault ks \/
    E. e (e e. Option Exception /\ E. m2 writeMemory1 (getMemory (ksCfg ks)) a v m2 e) $ =
'(bitr eldm_withEx @ oreq2 @ rexeqi @ bitr (eleq2 @ dmeq @ rappsabe ,eqtac) @
  bitr eldm_viaMemory @ bitr eldm @ exeqi @ elsabe @ elabed ,eqtac);

theorem writeMemory1R_fault:
  $ ks <> ks2 e. writeMemory1R a v -> ksFault ks -> ksFault ks2 $ =
(named 'withEx_fault);

-- theorem s_mem1_hoareM_writeMemory1R:
--   $ v e. u8 -> hoareM (s_mem1 p a w)
--       (writeMemory1R a v)
--       (^s (PROT_READ + PROT_WRITE C_ p) /\s s_mem1 p a v) $ =
-- (focus
--   '(iald @ iald @ exp @ iand (sylibr eldm_writeMemory1R @ exp _) _)
--   (focus
--     (def (f x y)
--       '(iexde @ iand (mpbiri ,x ,eqtac) @ iexde @ mpbird (syl ,y anllr) @ iand anr anlr))
--     '(mpbird (rexeqd @ exeqd @ s_mem1_writeMemory1a anr anll @ rsyl anlr @ s_weak_sat s_weak_sepr) @
--       casesda ,(f 'opt0 'ifppos) ,(f '(mpbir optS exGPFT) 'ifpneg)))
--   (focus '(iald @ exp @ iand (anwr writeMemory1R_fault) @ casesda _ _)));

theorem s_mem1_sat
  (h1: $ G -> ~ksFault k $)
  (h2: $ G -> e != suc exGPF $)
  (h3: $ G -> v e. u8 $)
  (h4: $ G -> k |=s R *s s_mem1 p a w $):
  $ G -> setCfg k (setMemory (ksCfg k) (setMem1 (getMemory (ksCfg k)) a v))
          |=s R *s s_mem1 p a v $ =
(named @ focus
  '(mpd h4 @ syl5bi (s_sateq2 s_sep_anlift2) @ syld (bi1d @ syl s_sat_anlift1 h1) @ impd @ exp @
    mpbird (imeq1d @ syl s_sat_def @ anwl h1) @ eexd @ impd @ syl5bi el_s_sep_sn2 @ eexda @ exp _)
  (have 'a1 '(sylib prth @ syl5eqr read_place_Mem @ sylan heap_sat_E anr @
    mpbii (elun2 snid) @ eleq2d @ syl heap_join_un @ anrd anlr))
  (have 'a2
    '(sylibr heap_join_S2 @ iand (iand (iand heap_join_isf1 @ a1i isfsn) @
      syl5eqs (ineq2 @ eqstr4 dmsn dmsn) heap_join_dmin) eqidd))
  (have 'ksT '(anwr heap_sat_ks))
  (have 'kT '(syl ksCfgT ksT))
  (have 'mT '(syl getMemoryT kT))
  '(sylibr (s_sateq2 s_sep_anlift2) @ syl (cases (a1d s_sat_fault) @ bi2d s_sat_anlift1) @
    iand (sylc (anim1d @ anim2d ax_1) (anw3l h3) anllr) @ orrd @
    sylan (iexe ,eqtac)
      (sylibr el_s_sep_sn2 @ rsyl anlr @ syl (iexe ,eqtac) @ anim2 a2) @
    iand _ _)
  (focus
    '(iand (syl heap_join_isf3 @ rsyl anlr @ anwr a2) @
      mpbird (syl setCfgT ksT) @
      iand (sylan setMemoryT kT @ setMem1T mT (syl anll anllr) (anw3l h3)) @
      sseld (a1i @ mpbir (sseq2 @ PageMappingeq get_setMemory) setMem1PM) @
      syl ksMappingT ksT))
  '(iald @ !! iald v2 @ syl5bi (ellower @ unfin finns finns) @
    syl5bi elun @ eord _ _)
  (focus
    '(exp @ eqtrd _ @ imp @
      syld (syl ssel @ anld @ syl heap_join_ss @ anrd anlr) @
      syl eal @ syl (!! eal q) anrr)
    '(imp @ casesd (eexd _) @ a1i @ a1d read_place_setMemory_ne)
    '(syl5ibrcom ,eqtac @ exp @ eqtr4g read_place_setMemory_eq read_place_Mem @
      preq1d @ syl setMem1_ne @ mtd _ @ a1i X86P_Memeq)
    '(disjne (rsyl anllr @ anwr heap_join_dmin) (anwr preldm) @ a1i @ preldm snid))
  (focus
    '(syl5ibrcom (sylbi elsn @ sylbi prth ,eqtac) @
      syl5eq read_place_setMemory_eq @ preqd (syl setMem1_eq @ anld a1) @
      anrd @ sylib prth @ syl5eqr read_place_Mem @ sylan heap_sat_E anr _)
    '(mpbii (elun2 snid) @ eleq2d @ syl heap_join_un @ anrd anlr)));

--| The primitive memory heaplet: `s_pto a v` or `a >->m v` says that
--| address `a` is mapped, and if the data at `a` is readable then the value is `v`.
--| It does not imply readability of the memory since if the data is not readable
--| we can conclude anything (because reading will cause a crash).
@_ local def s_pto (a v): set =
$ E.s p e. Prot, (^s (PROT_READ C_ p) /\s s_mem1 p a v) $;
infixl s_pto: $>->m$ prec 80;

theorem el_s_pto: $ h e. a >->m v <-> a e. u64 /\ v e. u8 /\
  E. p (p e. Prot /\ PROT_READ C_ p /\
    h = sn (X86P_Mem a <> ((p <> v) <> suc p))) $ =
'(bitr4 el_s_ex @ bitr3 exan1 @ exeqi @ bitr anlass @ bitr4 anass @
  aneq2a @ syl5bb el_s_an @ syl5bb (aneq1a @
    syl5bb el_s_lift @ syl bian1 @ el_sstop s_mem1_sstop) @
  aneq2d @ syl5bb el_s_mem1 @ aneq1d bian2);

theorem s_pto_sstop: $ a >->m v C_ T.s $ = (named '(s_ex_ssi @ sstr s_anl s_lift_sstop));

theorem s_pto_readMemory1:
  $ ~ksFault k /\ k |=s a >->m v ->
    readMemory1 PROT_READ (getMemory (ksCfg k)) a v $ =
(named '(imp @ syld (bi1d s_sat_ex) @ eexd @ syl5 anr @ syld (bi1d s_sat_anlift1) @
  syl6 s_mem1_readMemory1 @ syl5 ancom @ anim1d ian));

--| The primitive memory heaplet: `s_block a v` or `a >=> v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_mem (P a v): set =
$ ^s (a + len v e. u64 /\ v e. List u8) /\s
  |*|s i e. upto (len v), E.s p e. P, s_mem1 p (a + i) (nth i v - 1) $;

theorem s_mem_T: $ ~ksFault k /\ k |=s s_mem P a v -> a + len v e. u64 /\ v e. List u8 $ =
(named '(rsyl (imp @ bi1d s_sat_def) @ eex @ anwl @ sylbi el_s_an @ anwl @ sylbi el_s_lift anr));

theorem s_mem_0: $ s_mem P a 0 == ^s (a e. u64) /\s emp $ =
(named '(s_aneq (s_lifteq @ bitr (bian2 elList0) @ eleq1 @ eqtr (addeq2 len0) add02) @
  eqstr (s_Sepeq1 @ nseq @ eqtr (uptoeq len0) upto0) s_Sep_0));

theorem s_mem_S: $ s_mem P a (b : v) == E.s p e. P, s_mem1 p a b *s s_mem P (suc a) v $ =
(named '(eqstr4
  (s_aneq
    (s_lifteq @ bitr (aneq (eleq1 @ eqtr4 (addeq2 lenS) addSass) elListS) anlass) @
    eqstr (s_Sepeq1 @ nseq @ uptoeq lenS) @
    trud @ s_Sep_uptoS
      (anwr @ s_exeq2d @ s_mem1eqd eqidd (syl6eq add02 addeq2) @
        syl6eq sucsub1 @ subeq1d @ syl6eq nthZ @ ntheq1)
      (anwr @ s_exeq2d @ s_mem1eqd eqidd (syl6eqr addSass addeq2) @
        subeq1d @ syl6eq nthS ntheq1) @
    a1i @ s_ex_ssi s_mem1_sstop) @
  eqstr3 (s_sepeq1 @ mpbi s_bian1a @ s_ex_ssi @ s_anwl @ mpbir s_lift_ss anlr) @
  s_sep_anlift));

theorem s_mem_readMemory (G: wff x)
  (h1: $ G -> ps e. Prot $)
  (h2: $ G -> ~ksFault k $)
  (h3: $ G -> k |=s s_mem P a v $)
  (hp: $ G -> A. x (x e. P -> ps C_ x) $):
  $ G -> readMemory ps (getMemory (ksCfg k)) a v $ =
(named @ focus
  '(mpd h3 @ syl (!! eale b ,(eqtac-gen 'a)) ,(induct '(listindd) 'v _ _))
  '(iald @ syl5bi (s_sateq2 s_mem_0) @ syld (bi1d @ syl s_sat_anlift1 h2) @
    exp @ sylibr readMemory0 @
    iand (iand (anwl h1) @ syl getMemoryT @ syl ksCfgT @ rsyl anrr s_sat_ks) anrl)
  '(sylibr (cbval ,eqtac) @ iald @ syl5bi (s_sateq2 s_mem_S) @
    syl5 s_sat_sep @ syl6ibr readMemoryS @ animd _ _)
  (focus
    '(syld (bi1d @ syl s_sat_ex @ anwl h2) @ sylc _ (anwl h2) (anwl hp))
    '(syl6ibr erexb @ alimd @ imim2d @ com23 @ exp @ exp s_mem1_readMemory1))
  '(imp @ syl5 (eale ,eqtac) @ a2d @ exp @ bi2d @ readMemoryeq3d @
    syl add64S_eqid @ syl (u64le1 leaddid1) @ anld @ syl s_mem_T @ anim1 h2));

--| A block of readable or read/write memory: `a >=>m v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_block (a v): set = $ s_mem {p | PROT_READ C_ p} a v $;
infixl s_block: $>=>m$ prec 80;

theorem s_block_sstop: $ a >=>m v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));

theorem s_block_readMemory:
  $ ~ksFault k /\ k |=s a >=>m v -> readMemory PROT_READ (getMemory (ksCfg k)) a v $ =
(named '(s_mem_readMemory (a1i PROT_READ_T) anl anr @
  a1i @ ax_gen @ bi1 @ elabe ,eqtac));

theorem s_block_readMem: $ ~ksFault k /\ k |=s a >=>m v -> readMem (ksCfg k) a v $ =
'(iand (syl ksCfgT @ anwr s_sat_ks) s_block_readMemory);

--| A block of executable code: `a >=>c v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_code (a v): set = $ s_mem {p | PROT_READ + PROT_EXEC C_ p} a v $;
infixl s_code: $>=>c$ prec 80;

theorem s_code_readMemory:
  $ ~ksFault k /\ k |=s a >=>c v ->
    readMemory (PROT_READ + PROT_EXEC) (getMemory (ksCfg k)) a v $ =
(named '(s_mem_readMemory (a1i PROT_RX_T) anl anr @ a1i @ ax_gen @ bi1 @ elabe ,eqtac));

theorem s_code_readMemX: $ ~ksFault k /\ k |=s a >=>c v -> readMemX (ksCfg k) a v $ =
'(iand (syl ksCfgT @ anwr s_sat_ks) s_code_readMemory);

--| A block of uninitialized memory: `a >=>. n` says that there are
--| `n` free bytes at address `a`.
--| The bytes can be written to but not read until first write.
@_ local def s_block0 (a n): set = $ E.s v e. Array u8 n, s_mem _V a v $;
infixl s_block0: $>=>.$ prec 80;

--| A no-access memory heaplet: `s_block_Z a n` says that the memory at
--| `a ... a+n` is mapped but read-protected and will cause a fault if accessed.
@_ local def s_block_Z (a n): set =
$ |*|s i e. upto n, E.s b e. u8, s_mem1 0 (a + i) b $;

--| The unused portion of the stack, which contains an arbitrary block of
--| read/write data followed by a no-access guard page.
--|
--| `unused_stack lo sz` means that there are `sz` bytes of stack, such that
--| the low `min sz 4096` bytes of it are read protected, and the rest has
--| arbitrary readable memory.
@_ local def unused_stack (lo sz): set =
$ E.s v e. Array u8 (sz - 2 ^ 12),
    (s_block_Z lo (min sz (2 ^ 12)) *s (lo + 2 ^ 12) >=>m v) $;

--| `unused_stack_bd hi sz` means that there are at least `sz` bytes of stack
--| "above" `hi` (the top of the stack). Note that the stack grows down so these
--| unused bytes are at lower addresses than `hi`, and `hi` itself is not included.
--|
--| This means in particular that writing to any element up to `sz` bytes above `hi`
--| is safe, because we know it is either allocated or guarded.
@_ local def unused_stack_bd (hi sz): set =
$ E.s lo e. u64, (^s (lo + sz <= hi /\ lo <= hi) /\s unused_stack lo (hi - lo)) $;

--| `r >->r v` means that register `r e. Regs` contains value `v e. u64`.
@_ local def s_reg (r v): set =
$ ^s (r e. Regs /\ v e. u64) /\s sn (sn (X86P_Reg r <> v)) $;
infixl s_reg: $>->r$ prec 80;

--| `flags>-> fl` means that the flags have value `fl`.
@_ local def s_flags (v): set = $ ^s (v e. Flags) /\s sn (sn (X86P_Flags <> v)) $;
prefix s_flags: $flags>->$ prec 80;

--| `RIP>-> a` means that the instruction pointer has value `a`.
@_ local def s_RIP (a): set = $ ^s (a e. u64) /\s sn (sn (X86P_RIP <> a)) $;
prefix s_RIP: $RIP>->$ prec 80;

-- -- TODO
-- @_ local def alloc_stack (sp hi): set =
-- $ RSP >->r sp *s
--   E.s lo e. upto sp, unused_stack lo hi $;
do (check-proofs #t);

--| The null layout.
@_ local def L_emp: set = $ S\ a, S\ sz, (^s (a e. u64 /\ sz = 0) /\s emp) $;

--| A sequential composition of layouts.
@_ local def L_seq (L1 L2: set): set =
$ S\ a, S\ sz, (E.s sz1 e. u64, E.s sz2 e. u64,
   (^s (sz e. u64 /\ sz = sz1 + sz2) /\s
    L1 @' a @' sz1 *s L2 @' (a + sz1) @' sz2)) $;

--| The layout for a single value `v: List u8`.
@_ local def L_1 (v: nat): set = $ S\ a, S\ sz, (^s (sz = len v) /\s a >=>m v) $;

--| A padding layout.
@_ local def L_pad: set = $ S\ a, S\ sz, (a >=>. sz) $;

--| An overlapping composition of layouts.
@_ local def L_or (L1 L2: set): set =
$ S\ a, S\ sz, (E.s sz1 e. u64, E.s sz2 e. u64,
   (^s (sz = max sz1 sz2) /\s
    L1 @' a @' sz1 *s L_pad @' (a + sz1) @' (sz - sz1) \/s
    L2 @' a @' sz1 *s L_pad @' (a + sz2) @' (sz - sz2))) $;

--| The portion of the layout that we always want to know in any hoare triple.
--| `main_layout c sp ip` means that the code `c` is at `text_start`,
--| the instruction pointer at `ip`, and the flags are assigned to an arbitrary value
--| (i.e. we are permitted to clobber them).
--| Additionally, the stack is laid out according to stack layout `L`
--| (see the `L_*` functions) with at least `n` spare bytes left in the stack frame;
--| `sp` is the value of the stack pointer relative to the stack layout.
@_ local def main_layout (c sp ip n L): set =
$ text_start >=>c c *s RIP>-> ip *s
  E.s fl e. Flags, flags>-> fl *s
  E.s lo e. u64, E.s sz e. u64, (^s (lo + sz e. u64 /\ sp <= lo + sz) /\s
    RSP >->r (lo + sz - sp) *s (L @' lo @' sz *s unused_stack_bd lo n)) $;

--| The correctness predicate for a function call.
--| * `T`: A global parameter, the correctness predicate on final IO
--| * `c`: A global parameter, the program code
--| * `ip`: The address of the function
--| * `P`: The function's precondition, arranged using a calling convention
--| * `Q`: The function's postcondition, also determined by a calling convention
--| This says that if we were to call a function at location `ip`,
--| with inputs arranged according to `P`, then the function will successfully
--| terminate and the outputs will be arranged according to `Q`.
--|
--| Both `P` and `Q` are allowed to depend on common logical variables `vs`.
@_ local def func_ok (T c ip P Q): wff =
$ A. vs A. ret (ret e. u64 -> hoare T
    (main_layout c 8 ip (2 ^ 12) (L_1 (toBytes 8 ret)) *s (P @' vs))
    (main_layout c 0 ret 8 L_emp *s (Q @' vs))) $;

--| The correctness predicate for a jump target.
--| * `T, c`: Global parameters
--| * `sp`: The value of the stack pointer (a function-global parameter)
--| * `fr`: The frame condition (a function-global parameter)
--| * `ip`: The address of the jump target
--| * `L`: The stack frame layout as of the jump
--| * `P`: The jump's precondition, arranged using a calling convention
--| This says that if we were to jump to location `ip`,
--| with inputs arranged according to `L` and `P`, then the
--| program will eventually terminate. This is used as an available
--| hypothesis for every jump target in scope.
--|
--| Both `L` and `P` are allowed to depend on common logical variables `vs`.
@_ local def jump_ok (T c sp fr ip L P): wff =
$ A. vs s_ok (sn fr *s (main_layout c sp ip 8 (L @' vs) *s (P @' vs))) T $;

-- A type ty is a pair of a separating proposition [v : ty] which gives truth
-- conditions for "v has type ty", and a set of values {v : ty} which gives
-- the valid byte strings that can represent v. A type may have no valid
-- byte strings, in which case it is only usable for ghost values. the size
-- of a type is the smallest `n` such that `A. l (l e. {v : ty} -> len l <= n)`.

@_ local def has_ty (v: nat) (ty: set): set = $ Fst (ty @' v) $;
@_ local def ty_Rep (v: nat) (ty: set): set = $ Snd (ty @' v) $;
@_ local def ty_rep (ty: set) (v l: nat): set =
$ ^s (l e. ty_Rep v ty) /\s has_ty v ty $;

--| An assignment of register `r` to value `v` of type `ty`.
@_ local def t_reg (r v: nat) (ty: set): set =
$ E.s n e. upto (suc 8), E.s a e. Bits (8 * n), (
  ^s (n <= 8) /\s r >->r a *s
  ty_rep ty v (toBytes n a)) $;

--| A memory allocation at `a` with value `v` of type `ty`.
@_ local def t_mem (a v: nat) (ty: set): set =
$ E.s l e. List u8, (a >=>m l *s ty_rep ty v l) $;

@_ local def ty_u8: set = $ S\ v, Sum (^s (v e. u8) /\s emp) (sn (v : 0)) $;
@_ local def ty_u16: set = $ S\ v, Sum (^s (v e. u16) /\s emp) (sn (u16Bytes v)) $;
@_ local def ty_u32: set = $ S\ v, Sum (^s (v e. u32) /\s emp) (sn (u32Bytes v)) $;
@_ local def ty_u64: set = $ S\ v, Sum (^s (v e. u64) /\s emp) (sn (u64Bytes v)) $;
@_ local def ty_i8: set = $ S\ v, Sum (^s (v e. u8) /\s emp) (sn (i8Bytes v)) $;
@_ local def ty_i16: set = $ S\ v, Sum (^s (v e. u16) /\s emp) (sn (i16Bytes v)) $;
@_ local def ty_i32: set = $ S\ v, Sum (^s (v e. u32) /\s emp) (sn (i32Bytes v)) $;
@_ local def ty_i64: set = $ S\ v, Sum (^s (v e. u64) /\s emp) (sn (i64Bytes v)) $;
@_ local def ty_nat: set = $ S\ v, Sum emp 0 $;
@_ local def ty_int: set = $ S\ v, Sum emp 0 $;

--| A singleton has the same representation as the underlying type, but
--| it only has one valid value.
@_ local def ty_sn (a: nat) (ty: set): set =
$ S\ v, Sum (^s (v = a) /\s has_ty v ty) (ty_Rep v ty) $;

------------------------------------
-- Eliminating the free variables --
------------------------------------

--| The separating conjunction lifted over functions on `vs`.
@_ local def v_sep (P Q): set = $ S\ vs, (P @' vs *s Q @' vs) $;

--| The `n`th variable as a higher order function from the variable list to a value.
@_ local def vn (n: nat): set = $ \ vs, nth n vs - 1 $;

--| An assignment of register `r` to value `v` of type `ty`.
local def v_reg (r: hex) (v ty: set): set = $ S\ vs, t_reg r (v @ vs) (ty @' vs) $;

--| A memory allocation at `a` with value `v` of type `ty`.
@_ local def v_mem (a: nat) (v ty: set): set = $ S\ vs, t_mem a (v @ vs) (ty @' vs) $;

--| Asserts that the expression `v` has type `ty`.
@_ local def v_has_ty (v ty: set): set = $ S\ vs, has_ty (v @ vs) (ty @' vs) $;

--| Lift the singleton type to functions.
@_ local def v_ty_sn (a ty: set): set = $ S\ vs, ty_sn (a @ vs) (ty @' vs) $;

--| Lift addition to functions.
@_ local def v_add (a b: set): set = $ \ vs, a @ vs + b @ vs $;

--| Lift existential quantifier to functions.
@_ local def v_ex (a: nat) (ty P: set): set =
$ S\ vs, (E.s b e. ty, P @' lower (write vs a b)) $;

@_ local def v_ty_u32: set = $ S\ vs, ty_u32 $;

local def progT = $ S\ i, {o | 2 + 2 = 4} $;
local def prog: nat = $0$;
local def adder: nat = $0$;
theorem _:
  $ func_ok progT prog adder
      (v_sep
        (v_reg x7 (vn x0) v_ty_u32)
        (v_reg x6 (vn x1) v_ty_u32))
      (v_reg x0 (v_add (vn x0) (vn x1)) (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)) $;

-- (proc (adder {x : u32} {y : u32} : {ret : (sn {{x + y} : u64})})
--   (cast {(cast {x + y} (assert {{x + y} < {2 ^ 64}})) : u64}))
--
-- (proc (main : $ 2 + 2 = 4 $)
--   {(four h) := (adder 2 2)}
--   -- h: $ 2 + 2 = four $
--   {h2 := (assert {four = 4})}
--   -- h: $ 2 + 2 = four $, h2: $ four = 4 $
--   (return (entail h h2 eqtr)))

--| Constructs a cons of 16 elements represented as a perfect binary tree in `a`.
--| We use `cons16` nodes for storing lists of variable values with efficient lookup
--| (still linear time but with a better constant factor). Most functions won't have
--| more than 60-100 variables anyway so this should be fine, and if we need to do
--| better it's possible to make this logarithmic using binary random-access lists.
@_ local def cons16 (a l: nat): set =
$ ,(letrec ([(f n a x)
    @ if {n = 1} '(cons ,a ,x) (f {n - 1} '(fst ,a) @ f {n - 1} '(snd ,a) x)])
    (f 4 'a 'l)) $;

do {
  (def mmc-compiler (ref! (mmc-init)))
  (def mmc-reset
    (def c mmc-compiler)
    (fn () (set! c (mmc-init))))
  (def mmc-add
    (def c mmc-compiler)
    (fn xs (apply c '+ xs)))
  (def mmc-finish
    (def c mmc-compiler)
    (fn xs (apply c 'finish xs)))
  (def mmc-compiler)
  (def (mmc-compile x . xs)
    (apply mmc-add xs)
    (mmc-finish x))
};
