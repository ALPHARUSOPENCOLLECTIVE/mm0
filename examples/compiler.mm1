import "x86.mm1";

theorem s2n_A (h1: $ s = a $) (h2: $ t = b $): $ s '+ t = a ++ b $ =
'(eqtr s2nsadd @ appendeq h1 h2);
theorem s2n_1 (h: $ c = a $): $ s1 c = a : 0 $ = '(eqtr s2ns1 @ conseq1 h);
theorem s2n_S (h1: $ c = a $) (h2: $ s = b $): $ c ': s = a : b $ =
'(eqtr (s2n_A (s2n_1 h1) h2) append1);
theorem s2n_SE (h: $ s = a $): $ c ': s = c : a $ = '(s2n_S eqid h);
theorem s2n_SAE (h: $ s = a ++ b $): $ c ': s = c : a ++ b $ =
'(eqtr4 (s2n_SE h) appendS);
theorem append01i (h: $ a = b $): $ a = 0 ++ b $ = '(eqtr4 h append0);
theorem s2n_R0: $ s0 = repeat a 0 $ = '(eqtr4 s2ns0 repeat0);
theorem s2n_R1 (h: $ c = a $): $ s1 c = repeat a 1 $ =
'(eqtr4 (s2n_1 h) repeat1);
theorem s2n_RA (h1: $ s = repeat a m $) (h2: $ t = repeat a n $):
  $ s '+ t = repeat a (m + n) $ = '(eqtr4 (s2n_A h1 h2) repeatadd);
theorem s2n_RS (h1: $ c = a $) (h2: $ s = repeat a n $):
  $ c ': s = repeat a (suc n) $ = '(eqtr4 (s2n_S h1 h2) repeatS);
theorem saddS: $ c ': s '+ t = c ': (s '+ t) $ =
'(eqtr4 (s2n_A s2nscons eqid) @ s2n_SAE s2nsadd);

theorem s2n_toBytesS0 (h: $ c = a $) (h2: $ s = repeat 0 k $):
  $ c ': s = toBytes (suc k) a $ =
'(eqtr (s2n_S (eqcom @ modltid @ mpbi elu8_2 c2nT) @
    eqtr4 h2 @ eqtr (toByteseq2 @ divlteq0 @ mpbi elu8_2 c2nT) toBytes02) @
  eqtr3 toBytesS @ toByteseq2 h);

theorem xtoBytes0: $ s0 = toBytes 0 a $ = '(eqtr4 s2ns0 toBytes0);
theorem xtoBytesS (h: $ s = toBytes k n $): $ ch a1 a0 ': s = toBytes (suc k) (n :x a1 :x a0) $ =
'(eqtr4 (s2n_S (eqtr4 c2nhex @ anr hex_divmod256) @
    eqtr4 h @ toByteseq2 @ anl hex_divmod256) toBytesS);
theorem xtoBytesS2 (h: $ s = toBytes k x0 $): $ ch a1 a0 ': s = toBytes (suc k) (a1 :x a0) $ =
'(eqtr (xtoBytesS h) @ toByteseq2 @ hexeq1 hex01);
theorem xtoBytesS1 (h: $ s = toBytes k x0 $): $ ch x0 a0 ': s = toBytes (suc k) a0 $ =
'(eqtr (xtoBytesS2 h) @ toByteseq2 hex01);
theorem xtoBytes1S: $ s1 (ch a1 a0) = toBytes (suc 0) (n :x a1 :x a0) $ =
'(eqtr3 s2nscons0 @ xtoBytesS xtoBytes0);
theorem xtoBytes12: $ s1 (ch a1 a0) = toBytes (suc 0) (a1 :x a0) $ =
'(eqtr3 s2nscons0 @ xtoBytesS2 xtoBytes0);
theorem xtoBytes11: $ s1 (ch x0 a0) = toBytes (suc 0) a0 $ =
'(eqtr xtoBytes12 @ toByteseq2 hex01);

theorem xbitNotS (h0: $ a + b = xf $) (h1: $ c = bitsNot k n $):
  $ c :x b = bitsNot (k + 4) (n :x a) $ = '(eqtr4 (hexeq1 h1) (bitsNot_hex h0));
theorem xbitNot1 (h0: $ a + h2n b = xf $): $ b = bitsNot 4 (n :x a) $ =
'(eqtr3 hex01_ @ eqtr (xbitNotS h0 @ eqcom bitsNot01) @ bitsNoteq1 add01);
theorem xbitNot_ch (h0: $ a0 + c0 = xf $) (h1: $ a1 + c1 = xf $):
  $ c2n (ch c1 c0) = bitsNot 8 (n :x a1 :x a0) $ =
'(eqtr c2nch @ eqtr (xbitNotS h0 @ xbitNot1 h1) @ bitsNoteq1 d4add4);

theorem xtoIBytes0: $ s0 = toIBytes 0 a $ = 'xtoBytes0;
theorem xtoIBytesSb0_ (h: $ s = toBytes k n $): $ s = toIBytes k (b0 n) $ = '(eqtr4 h toIBytes_b0);
theorem xtoIBytesSb0 (h: $ s = toIBytes k (b0 n) $):
  $ ch a1 a0 ': s = toIBytes (suc k) (b0 (n :x a1 :x a0)) $ =
'(xtoIBytesSb0_ @ xtoBytesS @ eqtr h toIBytes_b0);
theorem xtoIBytes02 (h: $ s = toBytes k x0 $): $ s2n s = toIBytes k 0 $ =
'(eqtr (xtoIBytesSb0_ h) @ toIByteseq2 @ eqtr (b0eq h2n0) b00);
theorem xtoIBytesSb1S (h0: $ a0 + c0 = xf $) (h1: $ a1 + c1 = xf $) (h: $ s = toIBytes k (b1 n) $):
  $ ch c1 c0 ': s = toIBytes (suc k) (b1 (n :x a1 :x a0)) $ =
'(eqtr s2nscons @ eqtr4 (conseq (xbitNot_ch h0 h1) @
  eqtr4 h @ toIByteseq2 @ b1eq @ anli xchopshr8) toIBytesS_b1);
theorem xtoIBytesSb12 (h0: $ a0 + c0 = xf $) (h1: $ a1 + c1 = xf $) (h: $ s = toIBytes k (b1 x0) $):
  $ ch c1 c0 ': s = toIBytes (suc k) (b1 (h2n a1 :x a0)) $ =
'(eqtr (xtoIBytesSb1S h0 h1 h) @ toIByteseq2 @ b1eq @ hexeq1 hex01);
theorem xtoIBytesSb11 (h0: $ a0 + c0 = xf $) (h: $ s = toIBytes k (b1 x0) $):
  $ ch xf c0 ': s = toIBytes (suc k) (b1 (h2n a0)) $ =
'(eqtr (xtoIBytesSb12 h0 addx01 h) @ toIByteseq2 @ b1eq hex01);
theorem xtoIBytesSb10 (h: $ s = toIBytes k (b1 x0) $):
  $ ch xf xf ': s = toIBytes (suc k) (b1 x0) $ = '(xtoIBytesSb11 addx01 h);

theorem xu16Bytes (h: $ s2n s = toBytes ,(sucs 2) n $): $ s = u16Bytes n $ = 'h;
theorem xu32Bytes (h: $ s2n s = toBytes ,(sucs 4) n $): $ s = u32Bytes n $ = 'h;
theorem xu64Bytes (h: $ s2n s = toBytes ,(sucs 8) n $): $ s = u64Bytes n $ = 'h;
theorem xi8Bytes (h: $ s2n s = toIBytes ,(sucs 1) n $): $ s = i8Bytes n $ = 'h;
theorem xi16Bytes (h: $ s2n s = toIBytes ,(sucs 2) n $): $ s = i16Bytes n $ = 'h;
theorem xi32Bytes (h: $ s2n s = toIBytes ,(sucs 4) n $): $ s = i32Bytes n $ = 'h;
theorem xi64Bytes (h: $ s2n s = toIBytes ,(sucs 8) n $): $ s = i64Bytes n $ = 'h;

theorem xu8Byte_2 (a0 a1: hex): $ ch a1 a0 = a1 :x a0 $ = 'c2nhex;
theorem xu8Byte_1 (a0: hex): $ ch x0 a0 = a0 $ = 'c2nh2n;
theorem xelu8_1 (a0: hex): $ a0 e. u8 $ = '(mpbi (eleq1 xu8Byte_1) c2nT);
theorem xelu8_2 (a0 a1: hex): $ a1 :x a0 e. u8 $ = '(mpbi (eleq1 xu8Byte_2) c2nT);

theorem xelBits4S (h: $ n e. Bits (4 * k) $): $ n :x a e. Bits (4 * suc k) $ =
'(mpbir (elneq2 @ Bitseq mulS) (hexT h));
theorem xelBits41: $ h2n a e. Bits (4 * suc k) $ =
'(mpbi (eleq1 hex01_) @ xelBits4S elBits01);
theorem xelBits8S (h: $ n e. Bits (8 * k) $): $ n :x a1 :x a0 e. Bits (8 * suc k) $ =
'(mpbir (elneq2 @ Bitseq mulS) (hex2T h));
theorem xelBits82: $ h2n a1 :x a0 e. Bits (8 * suc k) $ =
'(mpbi (eleq1 @ hexeq1 hex01_) @ xelBits8S elBits01);
theorem xelBits81: $ h2n a0 e. Bits (8 * suc k) $ =
'(mpbi (eleq1 hex01) xelBits82);
theorem xelBits7S (h: $ n e. Bits (8 * k + 7) $): $ n :x a1 :x a0 e. Bits (8 * suc k + 7) $ =
'(mpbir (elneq2 @ Bitseq @ eqtr (addeq1 mulS) addrass) (hex2T h));
theorem xelBits72S: $ h2n a1 :x a0 e. Bits (8 * suc k + 7) $ =
'(mpbi (elneq (hexeq1 hex01_) @ Bitseq @ eqtr4 addrass @ addeq1 mulS) (hex2T elBits01));
theorem xelBits720 (h: $ a1 < x8 $): $ h2n a1 :x a0 e. Bits (8 * 0 + 7) $ =
'(mpbi (elneq2 @ Bitseq {,norm_num : $ 3 + 4 = _ $})
  (hexT @ mpbir elBits2 @ mpbir (lteq2 @ eqtr d2pow3 dec8) h));
theorem xelBits71: $ h2n a0 e. Bits (8 * k + 7) $ =
'(Bitsle (letr {,norm_num : $ 4 <= 7 $} leaddid2) h2nT);

theorem xeluNlem (e: $ 8 * k = n $) (h: $ a e. Bits (8 * k) $): $ a e. Bits n $ =
'(mpbi (elneq2 @ Bitseq e) h);
theorem xelu8i (h: $ a e. Bits (8 * suc 0) $): $ a e. u8 $ = '(xeluNlem mul12 h);
theorem xelu16i (h: $ a e. Bits (8 * ,(sucs 2)) $): $ a e. u16 $ = '(xeluNlem d8mul2 h);
theorem xelu32i (h: $ a e. Bits (8 * ,(sucs 4)) $): $ a e. u32 $ = '(xeluNlem d8mul4 h);
theorem xelu64i (h: $ a e. Bits (8 * ,(sucs 8)) $): $ a e. u64 $ = '(xeluNlem d8mul8 h);
theorem xelBits7b0 (h: $ a e. Bits (8 * k + 7) $): $ b0 a e. Bits (8 * suc k) $ =
'(mpbir (elneq2 @ Bitseq @ eqtr mulS addS2) @ mpbi b0Bits h);
theorem xelBits7b1 (h: $ a e. Bits (8 * k + 7) $): $ b1 a e. Bits (8 * suc k) $ =
'(mpbir (elneq2 @ Bitseq @ eqtr mulS addS2) @ mpbi b1Bits h);
theorem xelu8b0i (h: $ a e. Bits (8 * 0 + 7) $): $ b0 a e. u8 $ = '(xelu8i @ xelBits7b0 h);
theorem xelu8b1i (h: $ a e. Bits (8 * 0 + 7) $): $ b1 a e. u8 $ = '(xelu8i @ xelBits7b1 h);
theorem xelu16b0i (h: $ a e. Bits (8 * ,(sucs 1) + 7) $): $ b0 a e. u16 $ = '(xelu16i @ xelBits7b0 h);
theorem xelu16b1i (h: $ a e. Bits (8 * ,(sucs 1) + 7) $): $ b1 a e. u16 $ = '(xelu16i @ xelBits7b1 h);
theorem xelu32b0i (h: $ a e. Bits (8 * ,(sucs 3) + 7) $): $ b0 a e. u32 $ = '(xelu32i @ xelBits7b0 h);
theorem xelu32b1i (h: $ a e. Bits (8 * ,(sucs 3) + 7) $): $ b1 a e. u32 $ = '(xelu32i @ xelBits7b1 h);
theorem xelu64b0i (h: $ a e. Bits (8 * ,(sucs 7) + 7) $): $ b0 a e. u64 $ = '(xelu64i @ xelBits7b0 h);
theorem xelu64b1i (h: $ a e. Bits (8 * ,(sucs 7) + 7) $): $ b1 a e. u64 $ = '(xelu64i @ xelBits7b1 h);

do {
  -- (to-u8-ch a) returns a pair `(c p)` where p: $ c2n c = a $
  (def to-u8-ch @ match-fn
    [('hex ('h2n a) b) '((ch ,a ,b) (c2nhex ,a ,b))]
    [('h2n a) '((ch (x0) ,a) (c2nh2n ,a))])

  -- (to-toBytes k n) returns (s p) where p: $ s2n s = toBytes k n $.
  -- Note that `k` should be a unary numeral constructed by (sucs)
  (def (to-toBytes k n) @ match k
    [$suc ,k$ @ match k
      [$0$ @ match n
        [$,n :x ,a1 :x ,a0$ '($s1 (ch ,a1 ,a0)$ (xtoBytes1S ,a0 ,a1 ,n))]
        [$h2n ,a1 :x ,a0$ '($s1 (ch ,a1 ,a0)$ (xtoBytes12 ,a0 ,a1))]
        [$h2n ,a0$ '($s1 (ch ,'(x0) ,a0)$ (xtoBytes11 ,a0))]]
      [_ @ match n
        [$,n :x ,a1 :x ,a0$ @ match (to-toBytes k n) @ (s p)
          '($ch ,a1 ,a0 ': ,s$ (xtoBytesS ,a0 ,a1 ,k ,n ,s ,p))]
        [$h2n ,a1 :x ,a0$ @ match (to-toBytes k '(h2n @ x0)) @ (s p)
          '($ch ,a1 ,a0 ': ,s$ (xtoBytesS2 ,a0 ,a1 ,k ,s ,p))]
        [$h2n ,a0$ @ match (to-toBytes k '(h2n @ x0)) @ (s p)
          '($ch ,'(x0) ,a0 ': ,s$ (xtoBytesS1 ,a0 ,k ,s ,p))]]]
    [$0$ '($s0$ (xtoBytesS1 ,n))])

  -- (to-uNBytes N a) returns a pair `(s p)` where p: $ s2n s = uNBytes a $
  -- assuming N = 16,32,64
  (def (to-uNBytes n a)
    (def k (sucs {n // 8}))
    @ match (to-toBytes k a) @ (s p)
    '(,s (,(atom-app 'xu n 'Bytes) ,a ,s ,p)))

  -- (decnot a) = (b p) where p: $ a + b = xf $
  (def decnot @ match-fn @ (a)
    @ let ([n (hexdigit->number a)] [m {15 - n}])
    '((,(hexdigit m)) ,(nth 1 @ decaddn n m)))

  -- (to-toIBytesb1 k n) = (s p) where p: $ s2n s = toIBytes k (b1 n) $
  (def (to-toIBytesb1 k n) @ match k
    [$0$ '(s0 (xtoIBytes0 (b1 ,n)))]
    [$suc ,k$ @ match n
      ['(h2n @ x0) @ match (to-toIBytesb1 k '(h2n @ x0)) @ (s p)
        '($ ch xf xf ': ,s$ (xtoIBytesSb10 ,k ,s ,p))]
      [$,n :x ,a1 :x ,a0$ @ match (to-toIBytesb1 k n) @ (s p)
        @ match (decnot a0) @ (c0 p0) @ match (decnot a1) @ (c1 p1)
        '($ch ,c1 ,c0 ': ,s$ (xtoIBytesSb1S ,a0 ,a1 ,c0 ,c1 ,k ,n ,s ,p0 ,p1 ,p))]
      [$h2n ,a1 :x ,a0$ @ match (to-toIBytesb1 k '(h2n @ x0)) @ (s p)
        @ match (decnot a0) @ (c0 p0) @ match (decnot a1) @ (c1 p1)
        '($ch ,c1 ,c0 ': ,s$ (xtoIBytesSb12 ,a0 ,a1 ,c0 ,c1 ,k ,n ,s ,p0 ,p1 ,p))]
      [$h2n ,a0$ @ match (to-toIBytesb1 k '(h2n @ x0)) @ (s p)
        @ match (decnot a0) @ (c0 p0)
        '($ch ,'(xf) ,c0 ': ,s$ (xtoIBytesSb11 ,a0 ,c0 ,k ,s ,p0 ,p))]])

  -- (to-iNBytes N a) returns a pair `(s p)` where p: $ s2n s = iNBytes a $
  -- assuming N = 8,16,32,64
  (def (to-iNBytes n a)
    (def k (sucs {n // 8}))
    @ match (match a
      [$0$ @ match (to-uNBytes n '(h2n @ x0)) @ (s p) '(,s (xtoIBytes02 ,k ,s ,p))]
      [$b0 ,a$ @ match (to-uNBytes n a) @ (s p) '(,s (xtoIBytesSb0_ ,k ,a ,s ,p))]
      [$b1 ,a$ (to-toIBytesb1 k a)])
    [(s p) '(,s (,(atom-app 'xi n 'Bytes) ,a ,s ,p))])

  -- (to-elBits4 k n) proves $ n e. Bits (4 * k) $
  (def (to-elBits4 k n) @ match k
    [$suc ,k$ @ match n
      [$,n :x ,a$ '(xelBits4S ,a ,k ,n ,(to-elBits4 k n))]
      [$h2n ,a$ '(xelBits41 ,a ,k)]])

  -- (to-elBits8 k n) proves $ n e. Bits (8 * k) $
  (def (to-elBits8 k n) @ match k
    [$suc ,k$ @ match n
      [$,n :x ,a1 :x ,a0$ '(xelBits8S ,a0 ,a1 ,k ,n ,(to-elBits8 k n))]
      [$h2n ,a1 :x ,a0$ '(xelBits82 ,a0 ,a1 ,k)]
      [$h2n ,a0$ '(xelBits81 ,a0 ,k)]])

  -- (to-elBits7 k n) proves $ n e. Bits (8 * k + 7) $
  (def (to-elBits7 k n) @ match n
    [$,n :x ,a1 :x ,a0$ @ match k
      [$suc k$ '(xelBits7S ,a0 ,a1 ,k ,n ,(to-elBits8 k n))]]
    [$h2n ,a1 :x ,a0$ @ match k
      [$suc k$ '(xelBits72S ,a0 ,a1 ,k)]
      [$0$ '(xelBits720 ,a0 ,a1 ,(atom-app 'declt (hexstring (hex->number a1)) 8))]]
    [$h2n ,a0$ '(xelBits71 ,a0 ,k)])

  -- (to-elu N a) returns a proof that a is a hex literal in uN: $ a e. uN $
  -- assuming N = 8,16,32,64
  (def (to-elu n a)
    '(,(atom-app 'xelu n 'i) ,a ,(to-elBits8 (sucs {n // 8}) a)))

  -- (to-eli N a) returns a proof that a is a signed hex literal in uN: $ a e. uN $
  -- assuming N = 8,16,32,64
  (def (to-eli n a) @ match a
    [$0$ '(,(atom-app 'd0elu n))]
    [$b0 ,a$ '(,(atom-app 'xelu n 'b0i) ,a ,(to-elBits8 (sucs {{n // 8} - 1}) a))]
    [$b1 ,a$ '(,(atom-app 'xelu n 'b1i) ,a ,(to-elBits8 (sucs {{n // 8} - 1}) a))])
};

def _x00: char = 0;
def _x01: char = 1;
def _x02: char = 2;
def _x00x2: string = $ _x00 ': _x00 ': s0 $;
def _x00x4: string = $ _x00x2 '+ _x00x2 $;
def _x00x8: string = $ _x00x4 '+ _x00x4 $;

theorem _x00_eq: $ _x00 = 0 $ = '{,norm_num : $ ch = _ $};
theorem _x01_eq: $ _x01 = 1 $ = '{,norm_num : $ ch = _ $};
theorem _x02_eq: $ _x02 = 2 $ = '{,norm_num : $ ch = _ $};

theorem _x00x2_eq: $ _x00x2 = repeat 0 2 $ =
'(s2n_RS _x00_eq @ s2n_RS _x00_eq @ s2n_R0);
theorem _x00x4_eq: $ _x00x4 = repeat 0 4 $ =
'(eqtr (s2n_RA _x00x2_eq _x00x2_eq) @ repeateq2 ,norm_num);
theorem _x00x8_eq: $ _x00x8 = repeat 0 8 $ =
'(eqtr (s2n_RA _x00x4_eq _x00x4_eq) @ repeateq2 ,norm_num);

def ELF_IDENT_s: string =
$ ,0x7f ': ,"E" ': ,"L" ': ,"F" ':
  _x02 ': _x01 ': _x01 ': _x00 ': _x00x8 $;

theorem ELF_IDENT_eq: $ ELF_IDENT_s = ELF_IDENT $ =
'(s2n_SAE @ s2n_SAE @ s2n_SAE @ s2n_SAE @ append01i @
  s2n_S _x02_eq @ s2n_S _x01_eq @ s2n_S _x01_eq @
  s2n_RS _x00_eq _x00x8_eq);

def _ch16 (c: char): string = $ c ': _x00 ': s0 $;
def _ch32 (c: char): string = $ c ': _x00 ': _x00x2 $;
def _ch64 (c: char): string = $ _ch32 c '+ _x00x4 $;

theorem _ch16_eq (h: $ c = a $): $ _ch16 c = u16Bytes a $ =
'(s2n_toBytesS0 h @ s2n_RS _x00_eq @ s2n_R0);
theorem _ch32_eq (h: $ c = a $): $ _ch32 c = u32Bytes a $ =
'(s2n_toBytesS0 h @ s2n_RS _x00_eq @ _x00x2_eq);
theorem _ch64_eq (h: $ c = a $): $ _ch64 c = u64Bytes a $ =
'(eqtr saddS @ s2n_toBytesS0 h @
  eqtr (s2n_RA (s2n_RS _x00_eq _x00x2_eq) @ _x00x4_eq) @
  repeateq2 ,norm_num);

-- 0x400000 as u64, the hard coded entry point
def load_start_s (c: char): string = $ c ': _x00 ': ,0x40 ': _x00 ': _x00x4 $;
def load_start (x y): nat = $ ,0x4000 :x x :x y $;
def text_start: nat = $ load_start x7 x8 $;

theorem load_start_eq2: $ load_start x0 x0 + x :x y = load_start x y $ =
'(add_xx0 (add_x00 addx01) addx01);
theorem load_start_pow2: $ load_start x0 x0 = 2 ^ ,22 $ =
'(eqtr (x2powS @ x2powS @ x2powS @ x2powS @ x2powS @ eqtr2 d2pow2 dec4) @
  poweq2 ,norm_num);

theorem load_start_T: $ load_start x y e. u64 $ =
'(ssel u32ss64 @ xelu32i @ xelBits8S @ xelBits8S xelBits82);
theorem load_start_eq: $ load_start_s (ch x y) = u64Bytes (load_start x y) $ =
(focus
  '(xtoBytesS @ xtoBytesS @ eqtr _ @ toByteseq2 @ hexeq1 hex01_)
  '(xtoBytesS @ eqtr4 (s2n_RS _x00_eq _x00x4_eq) toBytes02));

def ELF_header_s (e: string): string =
$ ELF_IDENT_s '+ _ch16 _x02 '+ _ch16 ,0x3e '+ _ch32 _x01 '+
  e '+ _ch64 ,64 '+ _x00x8 '+
  _x00x4 '+ _ch16 ,64 '+ _ch16 ,0x38 '+ _ch16 _x01 '+
  _ch16 ,64 '+ _x00x4 $;

theorem ELF_header_ok (he: $ e = u64Bytes entry $) (he2: $ entry e. u64 $):
  $ elfHeader (ELF_header_s e) entry 64 0 1 0 $ =
(focus
  (for 0 7 @ fn (_) (refine '(ian _ _)))
  (def h0 '(mpbir (eleq1 ,to_hex) xelu8_1))
  (def h1 '(mpbir (eleq1 ,to_hex) xelu8_2))
  (def h2 '(mpbir (lteq2 @ eqtr bitsNeg1 upto16) ,norm_num))
  (refine 'he2 '(ssel u8ss64 ,h1) 'elBits01
    '(ssel u8ss16 ,h0) h2 'elBits01 h2) (swap)
  '(ax_mp (iexe ,eqtac) @ ian elBits01 _)
  '(s2n_A ELF_IDENT_eq @ s2n_A (_ch16_eq _x02_eq) @
    s2n_A (_ch16_eq eqid) @ s2n_A (_ch32_eq _x01_eq) @
    s2n_A he @ s2n_A (_ch64_eq ,norm_num) @
    s2n_A (eqtr4 _x00x8_eq toBytes02) @ s2n_A (eqtr4 _x00x4_eq toBytes02) @
    s2n_A (! _ch16_eq $64$ _ ,norm_num) @ s2n_A (_ch16_eq eqid) @
    s2n_A (_ch16_eq _x01_eq) @ s2n_A (! _ch16_eq $64$ _ ,norm_num) @
    s2n_A (eqtr4 _x00x2_eq toBytes02) (eqtr4 _x00x2_eq toBytes02)));

def PAGE_SIZE_s: string = $ _x00 ': _x00 ': ,0x20 ': _x00 ': _x00x4 $;
def PAGE_SIZE: nat = $ 2 ^ ,21 $;
theorem PAGE_SIZE_val: $ PAGE_SIZE = ,0x200000 $ =
'(eqtr2 (x2powS @ x2powS @ x2powS @ x2powS @ x2powS @ eqtr2 pow12 dec2) @
  poweq2 ,norm_num);
theorem PAGE_SIZE_eq: $ PAGE_SIZE_s = u64Bytes PAGE_SIZE $ =
(focus
  '(eqtr4 _ @ u64Byteseq PAGE_SIZE_val)
  '(xtoBytesS @ xtoBytesS @ eqtr _ @ toByteseq2 @ hexeq1 hex01_)
  '(xtoBytesS @ eqtr4 (s2n_RS _x00_eq _x00x4_eq) toBytes02));

def basic_pHeader_s (filesz memsz: string): string =
$ _ch32 _x01 '+ _ch32 ,7 '+
  _ch64 ,0x78 '+ load_start_s ,0x78 '+ _x00x8 '+
  filesz '+ memsz '+ PAGE_SIZE_s $;

def PROT_RWX = $ 7 $;
theorem PROT_RWX_val: $ PROT_RWX = upto 3 $ =
'(mpbi addcan1 @ eqtr4 (eqtr4 add12 d2pow3) uptoadd1);
theorem ss_PROT_RWX: $ p e. Prot <-> p C_ PROT_RWX $ =
'(bitr4 elBits @ sseq2 @ nseq PROT_RWX_val);
theorem PROT_RWX_T: $ PROT_RWX e. Prot $ = '(mpbir ss_PROT_RWX ssid);
theorem PROT_RWX_R: $ PROT_READ C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_READ_T);
theorem PROT_RWX_W: $ PROT_WRITE C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_WRITE_T);
theorem PROT_RWX_X: $ PROT_EXEC C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_EXEC_T);
theorem PROT_RWX_flags: $ protToFlags PROT_RWX = 7 $ =
(focus
  '(eqtr (ifpos PROT_RWX_X) @ eqtr4 (b1eq _) d7half)
  '(eqtr (ifpos PROT_RWX_W) @ eqtr4 (b1eq _) d3half)
  '(ifpos PROT_RWX_R));

theorem basic_pHeader_ok
  (hfs: $ fs = u64Bytes filesz $)
  (hms: $ ms = u64Bytes memsz $)
  (hle: $ filesz <= memsz $)
  (hms2: $ memsz e. u64 $):
  $ pHeader (basic_pHeader_s fs ms) PT_LOAD PROT_RWX
      (ch x7 x8) text_start filesz memsz $ =
(focus
  (for 0 7 @ fn (_) (refine '(ian _ _)))
  (def h0 '(mpbir (eleq1 ,to_hex) xelu8_1))
  (def h1 '(mpbir (eleq1 ,to_hex) xelu8_2))
  (refine '(ssel u8ss32 {,h0 : $ 1 e. _ $}) 'PROT_RWX_T
    '(ssel u8ss64 ,h1) 'load_start_T '(Bitsle1 hle hms2) 'hms2 'hle)
  (have 'hM '(eqtr3 load_start_eq2 @ addeq load_start_pow2 @ eqcom c2nhex))
  '(ax_mp (iexe ,eqtac) @ ian
    (ian _ @ mpbir (dvdeq2 @
      eqtr (bitsSub_eq_sub (mpbir (leeq2 hM) leaddid2) load_start_T) @
      eqtr (subeq1 hM) pncan) @ powdvd _)
    (s2n_A (_ch32_eq _x01_eq) @
      s2n_A (_ch32_eq @ eqcom @ eqtr PROT_RWX_flags ,norm_num) @
      s2n_A (_ch64_eq eqid) @ s2n_A load_start_eq @
      s2n_A (eqtr4 _x00x8_eq toBytes02) @
      s2n_A hfs @ s2n_A hms PAGE_SIZE_eq))
  norm_num
  norm_num);

local def ELF_lit (e fs ms c: string): string =
$ ELF_header_s e '+ basic_pHeader_s fs ms '+ c $;

local def ELF_parse (entry bss: nat) (c: string): nat =
$ entry <> PROT_RWX <> text_start <> c ++ repeat 0 bss $;

def ELF_lit_ok (elf: string) (entry bss: nat) (c: string) =
$ parseBasicElf elf entry PROT_RWX text_start (c ++ repeat 0 bss) $;

theorem ELF_lit_ok_isBasicElf (s entry bss c)
  (h: $ ELF_lit_ok s entry bss c $): $ isBasicElf s $ =
'(iexie @ iexde @ iexde @ iexde @ mpbiri h ,eqtac);

theorem basicElf_ok
  (he: $ e = u64Bytes entry $)
  (hfs: $ fs = u64Bytes filesz $)
  (hms: $ ms = u64Bytes memsz $)
  (hbss: $ filesz + bss = memsz $)
  (hlen: $ len c = filesz $)
  (hend: $ ,0x400078 + memsz = end $)
  (hea: $ text_start <= entry /\ entry < text_start + len c $)
  (hbd: $ end e. u64 $):
  $ ELF_lit_ok (ELF_lit e fs ms c) entry bss c $ =
(focus
  '(ian s2nT @ iexie ,(iterate 5 (fn (x) '(iexde ,x)) '(mpbiri _ ,eqtac)))
  (have 'h1 '(eqtr s2nsadd @ appendeq2 s2nsadd))
  (have 'he2 $ entry < end $
    '(ltletr (anr hea) @ mpbi (leeq2 hend) @ mpbi leadd2 @
      mpbir (leeq1 hlen) @ mpbi (leeq2 hbss) leaddid1))
  (have 'ehok '(ELF_header_ok he @ Bitsle1 (ltle he2) hbd))
  (have 'hl1 '(elArraylen @ an5l @ elfHeaderT ehok))
  (have 'phok '(basic_pHeader_ok
    (eqtr4 hfs @ u64Byteseq hlen)
    (eqtr4 hms @ u64Byteseq hbss)
    (mpbir (leeq1 hlen) leaddid1)
    (mpbir (eleq1 hbss) @ Bitsle1 (mpbi (leeq2 hend) leaddid2) hbd))) (swap)
  (have 'hl2 '(elArraylen @ an6l @ pHeaderT phok))
  (for 0 8 @ fn (_) (refine '(ian _ _)))
  (focus
    '(mpbir (sublistAteq2 h1) @ sublistAt_left sublistAt_id))
  (focus 'ehok)
  (focus
    '(mpbir (sublistAteq (eqtr2 add02 hl1) h1 eqid) @
      sublistAt_right @ sublistAt_left sublistAt_id))
  (focus 'phok)
  (focus
    '(mpbir (sublistAteq (eqtr2 (addeq hl1 @ eqtr add02 hl2)
        {,norm_num : $ 64 + ch x3 x8 = ch x7 x8 $}) h1 eqid) @
      sublistAt_right @ sublistAt_right sublistAt_id))
  (focus '(mpbir (eleq1 @ eqtr (addeq2 hbss) hend) hbd))
  (focus '(anl hea))
  (focus '(mpbir (lteq2 @ eqtr (addeq2 hbss) hend) he2))
  (focus '(appendeq2 @ repeateq2 @ eqtr2 (subeq2 hlen) pncan2)));

---------------
-- Assembler --
---------------

theorem splitBitsx0i: $ splitBits 0 x0 $ =
'(mpbir splitBits0 @ eqcom dec0);

theorem splitBitsSi
  (h1: $ a e. Bits k $) (h2: $ shl m k + a = n $) (h3: $ splitBits bs m $):
  $ splitBits ((k <> a) : bs) n $ =
'(mpbir splitBitsS @ iani h1 @ ax_mp (iexe ,eqtac) @ iani h2 h3);

theorem splitBits14i (a: hex): $ splitBits ((4 <> a) : 0) a $ = '(splitBits1i h2nT);
theorem splitBits14ie (x: hex) (h: $ a = x $): $ splitBits ((4 <> a) : 0) x $ =
'(mpbir (splitBitseq1 @ conseq1 @ preq2 h) splitBits14i);
theorem splitBitsS4i (h: $ splitBits bs n $): $ splitBits ((4 <> a) : bs) (n :x a) $ =
'(mpbir splitBitsS4 @ ax_mp (iexe ,eqtac) @ iani eqid h);

theorem splitBitsA4i
  (he: $ bs1 ++ bs2 = bs $) (hs: $ bvSize bs1 = 4 $)
  (h1: $ splitBits bs1 a $) (h2: $ splitBits bs2 n $):
  $ splitBits bs (n :x a) $ =
'(mpbi (splitBitseq1 he) @ mpbir (splitBitsA hs) @
  iexie @ mpbiri (ian h1 @ splitBitsS4i h2) ,eqtac);

theorem splitBitsA4ic
  (he: $ bs1 ++ bs2 = bs $) (hs: $ bvSize bs1 = 4 $)
  (h1: $ splitBits bs1 b $) (h2: $ splitBits bs2 a $):
  $ splitBits bs (ch a b) $ =
'(mpbir (splitBitseq2 c2nch) @ splitBitsA4i he hs h1 h2);

theorem splitBitsS1i (h0: $ bool x $)
  (hn: $ b0 n2 + x = n $) (h: $ splitBits bs n2 $):
  $ splitBits ((1 <> x) : bs) n $ =
'(splitBitsSi (mpbir elBits1 h0) (eqtr (addeq1 shl12) hn) h);

theorem splitBitsS1i0 (h1: $ n = b0 n2 $) (h2: $ splitBits bs n2 $):
  $ splitBits ((1 <> 0) : bs) n $ = '(splitBitsS1i bool0 (eqtr4 add0 h1) h2);
theorem splitBitsS1i1 (h1: $ n = b1 n2 $) (h2: $ splitBits bs n2 $):
  $ splitBits ((1 <> 1) : bs) n $ = '(splitBitsS1i bool1 (eqtr4 add12 h1) h2);

theorem splitBitsSSi (h0: $ bool x $)
  (ha: $ b0 a2 + x = a $) (hn: $ b0 n2 + x = n $)
  (h2: $ splitBits ((k <> a2) : bs) n2 $):
  $ splitBits ((suc k <> a) : bs) n $ =
(focus
  '(mpbi (splitBitseq1 @ conseq1 @ preq1 add11) @ mpbir splitBits_split @
    iexie @ iexde @ mpbiri _ ,eqtac)
  '(ian (eqtr (addeq1 shl12) ha) @ splitBitsS1i h0 hn h2));

theorem splitBitsSSi0 (ha: $ a = b0 a2 $) (hn: $ n = b0 n2 $)
  (h2: $ splitBits ((k <> a2) : bs) n2 $): $ splitBits ((suc k <> a) : bs) n $ =
'(splitBitsSSi bool0 (eqtr4 add0 ha) (eqtr4 add0 hn) h2);
theorem splitBitsSSi1 (ha: $ a = b1 a2 $) (hn: $ n = b1 n2 $)
  (h2: $ splitBits ((k <> a2) : bs) n2 $): $ splitBits ((suc k <> a) : bs) n $ =
'(splitBitsSSi bool1 (eqtr4 add12 ha) (eqtr4 add12 hn) h2);

theorem b0Bitsi (h1: $ a = b0 a2 $) (h2: $ a2 e. Bits n $): $ a e. Bits (suc n) $ =
'(mpbir (eleq1 h1) @ mpbi b0Bits h2);
theorem b1Bitsi (h1: $ a = b1 a2 $) (h2: $ a2 e. Bits n $): $ a e. Bits (suc n) $ =
'(mpbir (eleq1 h1) @ mpbi b1Bits h2);

do {
  (def (xsplitBits l i) (apply atom-app "xsplitBits_" (hexstring i) l))

  -- Adds theorems such as
  -- theorem xsplitBits_a121:
  --   $ splitBits ((1 <> 0) : (2 <> 1) : (1 <> 1) : 0) xa $;
  -- which decompose hex values into bits in different groupings.
  -- The naming system is 'xsplitBits_' + hex digit + partition,
  -- where partition is one of 13, 22, 31, 121, 1111 representing a partition of 4
  (scan '((1 3) (2 2) (3 1) (1 2 1) (1 1 1 1)) @ fn (l)
    @ for 0 16 @ fn (i)
      (def name (xsplitBits l i))
      @ letrec (
        [lhs @ match-fn*
          [(() _) $0$]
          [((k . xs) n)
            '(cons (pr (,(dn k)) (,(dn {n % {2 ^ k}})))
              ,(lhs xs {n shr k}))]]
        [f @ match-fn*
          [(() n) 'splitBitsx0i]
          [((k . xs) n)
            @ if {k = 1}
            '(,(atom-app 'splitBitsS1i {n % 2})
              ,(hexnhalf n) ,(f xs {n // 2}))
            '(,(atom-app 'splitBitsSSi {n % 2})
              ,(decnhalf {n % {2 ^ k}}) ,(hexnhalf n) ,(f (cons {k - 1} xs) {n // 2}))]])
      (add-tac-thm! name () ()
        '(splitBits ,(lhs l i) (,(hexdigit i))) () @ fn () (f l i)))

  -- (mk-splitBits (x_1 ... x_k) i) returns (n_1 ... n_k p) where p proves
  --   $ splitBits ((x_1 <> n_1) : ... : (x_k <> n_k) : 0) i $;
  -- Here the x_i are numbers (a partition of 4), the n_i are decimal numerals, and i is a number
  (def (mk-splitBits l i)
    @ letrec ([(f n xs) @ match xs
      [() '((,(xsplitBits l i)))]
      [(k . xs) '((,(dn {n % {2 ^ k}})) . ,(f {n // {2 ^ k}} xs))]])
    (f i l))

  -- (merge-bits (x_1 ... x_k) n_1 ... n_k) returns (i p) where p proves
  --   $ splitBits ((x_1 <> n_1) : ... : (x_k <> n_k) : 0) i $;
  -- Here the x_i are numbers (a partition of 4), the n_i are decimal numerals, and i is a number
  (def (merge-bits l . is)
    @ letrec ([f @ match-fn*
      [(() () i _) '(,i ,(xsplitBits l i))]
      [((k . xs) ((a) . is) i m)
        @ f xs is {i + {(decdigit->number a) shl m}} {m + k}]])
    (f l is 0 0))
};

theorem bitb00i (h: $ a = b0 b $): $ bit a 0 = 0 $ = '(eqtr (biteq1 h) bitb00);
theorem bitb10i (h: $ a = b1 b $): $ bit a 0 = 1 $ = '(eqtr (biteq1 h) bitb10);
theorem bitb0Si (h: $ a = b0 b $) (h2: $ bit b n = c $): $ bit a (suc n) = c $ =
'(eqtr (biteq1 h) @ eqtr bitb0S h2);
theorem bitb1Si (h: $ a = b1 b $) (h2: $ bit b n = c $): $ bit a (suc n) = c $ =
'(eqtr (biteq1 h) @ eqtr bitb1S h2);

-- Adds theorems such as
-- theorem xbita3: $ bit xa 3 = 0 $;
-- which evaluate the bits of an individual hex digit.
-- Naming system is "xbit" + hex digit + index
do {
  (def (xbit n i) @ atom-app "xbit" (hexstring n) (hexstring i))
  (for 0 16 @ fn (n) @ for 0 4 @ fn (i)
    @ letrec ([(f n i)
      @ if {i = 0}
      '(,(atom-app "bitb" {n % 2} "0i") ,(hexnhalf n))
      '(,(atom-app "bitb" {n % 2} "Si")
        ,(hexnhalf n) ,(f {n // 2} {i - 1}))])
    (add-tac-thm! (xbit n i) () ()
      '(eq (bit (h2n (,(hexdigit n))) (,(dn i))) (,(dn {{n shr i} band 1}))) ()
      @ fn () (f n i)))
};

theorem REX_W_Si (h: $ bit rex 3 = a $): $ REX_W (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);
theorem REX_R_Si (h: $ bit rex 2 = a $): $ REX_R (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);
theorem REX_X_Si (h: $ bit rex 1 = a $): $ REX_X (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);
theorem REX_B_Si (h: $ bit rex 0 = a $): $ REX_B (suc rex) = a $ = '(eqtr (biteq1 sucsub1) h);

theorem rex_reg_i (h: $ splitBits ((3 <> r) : (1 <> b) : 0) n $):
  $ rex_reg b r = n $ =
'(eqtr3 (addeq1 @ shleq1 ofBits1) @ anri @ mpbi splitBitsS2 h);

theorem splitBits_332
  (h1: $ splitBits ((3 <> a) : (1 <> bl) : 0) y $)
  (h2: $ splitBits ((2 <> bh) : (2 <> c) : 0) x $):
  $ splitBits ((3 <> a) : (3 <> shl bh 1 + bl) : (2 <> c) : 0) (ch x y) $ =
(focus
  '(mpbi (splitBitseq1 @ eqtr append1 @ conseq2 @ conseq1 @ preq1 add11) @
    mpbir splitBits_mid @ iexie @ iexde @ mpbiri (ian eqid _) ,eqtac)
  '(splitBitsA4ic (eqtr4 (appendSi append1) append1) ,bvSizeSi h1 h2));

theorem splitBits_121_rex_reg
  (h1: $ splitBits ((1 <> bl) : (2 <> bh) : (1 <> r) : 0) rn $)
  (h2: $ rex = r $): $ rn = rex_reg rex (shl bh 1 + bl) $ =
(focus '(eqcom @ rex_reg_i @
  mpbi (splitBitseq1 @ conseq (preq1 add11) @ conseq1 @ preq2 @ eqcom h2) @
  mpbir splitBits_split @ iexie @ iexde @ mpbiri (ian eqid h1) ,eqtac));

theorem opSize_64: $ opSize r 1 1 = wSz64 $ = '(eqtr (ifpos true1) (ifpos true1));
theorem opSize_32: $ opSize r 0 1 = wSz32 $ = '(eqtr (ifpos true1) (ifneg true0));
theorem opSize_8: $ opSize r w 0 = wSz8 r $ = '(ifneg true0);

theorem opSizeW_0 (h: $ opSize F. 0 v = a $): $ opSizeW 0 v = a $ =
'(eqtr (opSizeeq (mpbir neqfal eqid) REX_W_0 eqid) h);
theorem opSizeW_S (h1: $ bit rex 3 = w $)
  (h2: $ opSize T. w v = a $): $ opSizeW (suc rex) v = a $ =
'(eqtr (opSizeeq (mpbir eqtru peano1) (eqtr (biteq1 sucsub1) h1) eqid) h2);

theorem readSIBDisplacement_0
  (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readSIBDisplacement 0 x5 (chopZ 64 a) 0 l $ =
(named @ focus
  '(mpbir (ifppos @ ian h2n5 eqid) _)
  '(iexie @ mpbiri (iani (iani _ eqid) (eqtr h2 i32Bytes_val)) ,eqtac)
  '(iani chopZT @ eqcom @ sExt_chopZ @ iani d32le64 h1));

theorem readDisplacement_0: $ readDisplacement 0 0 s0 $ =
(named '(orl @ orl @ ian (ian eqid eqid) s2ns0));
theorem readDisplacement_8
  (h1: $ a e. u8 $) (h2: $ l = i8Bytes a $):
  $ readDisplacement 1 (chopZ 64 a) l $ =
(named @ focus
  '(orl @ orr @ iexie @ mpbiri (ian _ @ eqtr h2 i8Bytes_val) ,eqtac)
  '(ian (ian chopZT eqid) @ eqcom @ sExt_chopZ @ iani d8le64 h1));
theorem readDisplacement_32
  (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readDisplacement 2 (chopZ 64 a) l $ =
(named @ focus
  '(orr @ iexie @ mpbiri (ian _ @ eqtr h2 i32Bytes_val) ,eqtac)
  '(ian (ian chopZT eqid) @ eqcom @ sExt_chopZ @ iani d32le64 h1));

theorem readSIBDisplacement_reg
  (h1: $ bbase != x5 \/ 0 < md $)
  (h2: $ readDisplacement md q l $):
  $ readSIBDisplacement md bbase q (base_reg bbase) l $ =
(named '(mpbir (ifpneg @ mpbir notan @ mpbi (oreq (neeq2 h2n5) lt01) h1) @ ian h2 eqid));

theorem readModRM2_reg (h1: $ REX_B rex = b $) (h2: $ rex_reg b rm2 = r $):
  $ readModRM2 rex (RM_reg r) rm2 3 s0 $ =
(named '(mpbir (ifppos eqid) @ ian (RM_regeq @ eqtr2 (rex_regeq1 h1) h2) s2ns0));
theorem readModRM2_rip
  (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readModRM2 rex (RM_mem 0 base_RIP (chopZ 64 a)) 5 0 l $ =
(named '(mpbir (ifpneg @ ltne d0lt3) @ mpbir (ifppos @ ian eqid eqid) @
  iexie @ mpbiri (ian (ian chopZT @ RM_memeq3 @
    eqcom @ sExt_chopZ @ iani d32le64 h1) @ eqtr h2 i32Bytes_val) ,eqtac));
theorem readModRM2_sib (h: $ readSIB rex md rm l $):
  $ readModRM2 rex rm 4 md l $ =
(named '(mpbir (ifpneg @ anllr @ readSIB_T h) @
  mpbir (ifpneg @ mt anl {,norm_num : $ 4 != 5 $}) @ mpbir (ifppos eqid) h));
theorem readModRM2_mem
  (h1: $ REX_B rex = b $) (h2: $ rex_reg b rm2 = r $)
  (h3: $ rm2 != x4 $)
  (h4: $ rm2 != x5 \/ 0 < md $)
  (h5: $ readDisplacement md disp l $):
  $ readModRM2 rex (RM_mem 0 (base_reg r) disp) rm2 md l $ =
(named '(mpbir (ifpneg @ anllr @ readDisplacementT h5) @
  mpbir (ifpneg @ mpbir notan @ mpbi (oreq (neeq2 h2n5) lt01) h4) @
  mpbir (ifpneg @ mpbi (neeq2 h2n4) h3) @
  iexie @ mpbiri (ian h5 @ RM_memeq2 @ base_regeq @ eqtr2 (rex_regeq1 h1) h2) ,eqtac));

theorem readSIB_I
  (h1: $ splitBits ((3 <> bs) : (1 <> ixl) : 0) y $)
  (h2: $ splitBits ((2 <> ixh) : (2 <> sc) : 0) x $)
  (h3: $ REX_X rex = rx $)
  (h4: $ splitBits ((1 <> ixl) : (2 <> ixh) : (1 <> rx) : 0) index $)
  (h5: $ REX_B rex = rb $)
  (h6: $ splitBits ((3 <> bs) : (1 <> rb) : 0) bbase $)
  (h7: $ readSIBDisplacement md bbase disp base l $)
  (h8: $ if (index = RSP) 0 (suc (sc <> index)) = osi $):
  $ readModRM2 rex (RM_mem osi base disp) 4 md (ch x y ': l) $ =
(focus
  '(readModRM2_sib @ iexie ,(iterate 7 (fn (x) '(iexde ,x)) '(mpbiri _ ,eqtac)))
  '(iani (iani (iani _ _) _) s2nscons)
  '(iani (splitBits_332 h1 h2) (splitBits_121_rex_reg h4 h3))
  '(mpbir (readSIBDisplacementeq2 @ eqtr (rex_regeq1 h5) @ rex_reg_i h6) h7)
  '(RM_memeq1 @ eqcom h8));

theorem readSIB_0
  (h1: $ splitBits ((3 <> bs) : (1 <> 0) : 0) y $)
  (h2: $ splitBits ((2 <> 2) : (2 <> sc) : 0) x $)
  (h3: $ REX_X rex = 0 $)
  (h5: $ REX_B rex = rb $)
  (h6: $ splitBits ((3 <> bs) : (1 <> rb) : 0) bbase $)
  (h7: $ readSIBDisplacement md bbase disp base l $):
  $ readModRM2 rex (RM_mem 0 base disp) 4 md (ch x y ': l) $ =
'(readSIB_I h1 h2 h3 xsplitBits_4121 h5 h6 h7 @ ifpos h2n4);

theorem readSIB_S
  (h1: $ splitBits ((3 <> bs) : (1 <> ixl) : 0) y $)
  (h2: $ splitBits ((2 <> ixh) : (2 <> sc) : 0) x $)
  (h3: $ REX_X rex = rx $)
  (h4: $ splitBits ((1 <> ixl) : (2 <> ixh) : (1 <> rx) : 0) index $)
  (h5: $ REX_B rex = rb $)
  (h6: $ splitBits ((3 <> bs) : (1 <> rb) : 0) bbase $)
  (h7: $ readSIBDisplacement md bbase disp base l $)
  (h8: $ index != x4 $):
  $ readModRM2 rex (RM_mem (suc (sc <> index)) base disp) 4 md (ch x y ': l) $ =
'(readSIB_I h1 h2 h3 h4 h5 h6 h7 @ ifneg @ mpbi (neeq2 h2n4) h8);

theorem readModRM_I
  (h1: $ splitBits ((3 <> rm2) : (1 <> o) : 0) y $)
  (h2: $ splitBits ((2 <> pc) : (2 <> md) : 0) x $)
  (h3: $ REX_R rex = r $)
  (h4: $ splitBits ((1 <> o) : (2 <> pc) : (1 <> r) : 0) rn $)
  (h5: $ readModRM2 rex rm rm2 md l $):
  $ readModRM rex rn rm (ch x y ': l) $ =
(focus
  '(mpbir readModRM_val @ iexie @ iexde @ iexde @ iexde @
    mpbiri (ian (ian (splitBits_332 h1 h2) (splitBits_121_rex_reg h4 h3)) _) ,eqtac)
  '(iexie @ mpbiri (ian s2nscons h5) ,eqtac));

theorem readOpcodeModRM_I
  (h1: $ splitBits ((3 <> rm2) : (1 <> o) : 0) y $)
  (h2: $ splitBits ((2 <> pc) : (2 <> md) : 0) x $)
  (h3: $ splitBits ((1 <> o) : (2 <> pc) : (1 <> 0) : 0) opc $)
  (h4: $ readModRM2 rex r rm2 md l $):
  $ readOpcodeModRM rex opc r (ch x y ': l) $ =
(focus
  (suffices 'h '{_ :
    $ splitBits ((1 <> o) : (2 <> pc) : (1 <> REX_R rex) : 0) (shl (REX_R rex) 3 + opc) /\
      opc = chop 3 (shl (REX_R rex) 3 + opc) $})
  '(iexie @ mpbiri (iani (readModRM_I h1 h2 eqid (anl h) h4) (anr h)) ,eqtac)
  (have 'sp $ E. a (
      splitBits ((1 <> o) : (2 <> pc) : 0) a /\
      splitBits ((3 <> a) : (1 <> 0) : 0) opc) $
   '(mpbi (splitBitsA @ eqtr4 ,bvSizeSi dec3) @
    mpbir (splitBitseq1 @ appendSi append1) h3))
  '(eex (imp @ syl5bi splitBitsS @ impd @ exp @ !! eexd z @ syl5 _ _) sp)
  '(impcom @ bi2d @ eqeq1d @ syl5eqr add01 @ addeq1d @
    syl5eqr shl01 @ shleq1d @ sylbi splitBits1 anr)
  '(syl5ibrcom (rsyl eqcom ,eqtac) @
    mpand (sylibr splitBitsS @ iand anr @ iexde @
      mpbird ,eqtac @ a1i @ ian eqid @ splitBits1i @ mpbir elBits1 REX_R_T) @
    iand _ @ eqcomd @ anld @ sylib splitBitsS_uniq anr)
  '(sylib (splitBitseq1 @ appendSi append1) @
    sylibr (splitBitsA @ eqtr4 ,bvSizeSi dec3) @
    iexde @ mpbird ,eqtac @ iand an3l anlr));

theorem readImmN_I (h1: $ 8 * i = k $) (h2: $ k <= 64 $)
  (h3: $ a e. Bits k $) (h4: $ l = toIBytes i a $):
  $ readImmN k (chopZ 64 a) l $ =
(named @ focus
  '(iexie @ mpbiri (ian _ _) ,eqtac)
  '(ian chopZT @ eqcom @ sExt_chopZ @ iani h2 h3)
  '(eqtr h4 @ toByteseq (eqtr3 (muldiv2 peano1) (diveq1 h1)) (chopZeq1 h1)));

theorem readFullImmI (h1: $ 8 * i = k $)
  (hs: $ sz e. WSize $) (h2: $ wsizeBits sz = k $)
  (h3: $ a e. Bits k $) (h4: $ l = toIBytes i a $):
  $ readFullImm sz (chopZ 64 a) l $ =
'(mpbir (readImmNeq1 h2) @ readImmN_I h1
  (mpbi (leeq1 h2) @ wsizeBitsle64 hs) h3 h4);

theorem readFullImm32I (h1: $ a e. u32 $) (h2: $ l = i32Bytes a $):
  $ readFullImm wSz32 (chopZ 64 a) l $ =
'(readFullImmI d8mul4 wSz32T wSz32Bits h1 h2);

theorem readFullImm64I (h1: $ a e. u64 $) (h2: $ l = i64Bytes a $):
  $ readFullImm wSz64 (chopZ 64 a) l $ =
'(readFullImmI d8mul8 wSz64T wSz64Bits h1 h2);

theorem decodeI
  (h1: $ readPrefixes rex l1 $)
  (h2: $ decodeAux rex ast opc l2 $)
  (he: $ l1 ++ opc : l2 = l $):
  $ decode ast l $ =
'(iexie @ iexde @ iexde @ iexde @
  mpbiri (iani (iani (eqcom he) h1) h2) ,eqtac);

theorem decode0I (h: $ decodeAux 0 ast opc s $): $ decode ast (opc ': s) $ =
(named '(decodeI (orl @ ian eqid eqid) h @ eqtr4 append0 s2nscons));

theorem decode1I
  (h: $ decodeAux (suc rex) ast opc s $):
  $ decode ast (ch x4 rex ': opc ': s) $ =
(named '(decodeI (orr @ iexie @ iexde @
  mpbiri (ian (ian (splitBitsS4i @ splitBits14ie dec4) eqid) eqid) ,eqtac) h @
  eqtr4 append1 @ eqtr s2nscons @ conseq c2nhex s2nscons));

theorem decodeAux_s1
  (h: $ decodeAux rex ast opc (c ': s0) $):
  $ decodeAux rex ast opc (s1 c) $ = '(mpbi (decodeAuxeq4 s2nscons0) h);

theorem decodeBinopI (h: $ decodeBinop rex ast b l $): $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orl @ orl @ orl h);
theorem decodeMovI   (h: $ decodeMov rex ast b l $):   $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orl @ orl @ orr h);
theorem decodePushI  (h: $ decodePush rex ast b l $):  $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orl @ orr h);
theorem decodePopI   (h: $ decodePop rex ast b l $):   $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orl @ orr h);
theorem decodeFlowI  (h: $ decodeFlow rex ast b l $):  $ decodeAux rex ast b l $ = '(orl @ orl @ orl @ orr h);
theorem decodeMiscI  (h: $ decodeMisc rex ast b l $):  $ decodeAux rex ast b l $ = '(orl @ orl @ orr h);
theorem decodeHiI    (h: $ decodeHi rex ast b l $):    $ decodeAux rex ast b l $ = '(orl @ orr h);

theorem decodeMovRegI
  (h1: $ splitBits ((1 <> v) : (1 <> d) : (2 <> 2) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readModRM rex reg r l $)
  (h4: $ if (true d) (R_rm reg r) (Rm_r r reg) = ds $):
  $ decodeAux rex (xastMov sz ds) (ch x8 a) l $ =
(focus
  '(decodeMovI @ orl @ orl @ orr @ iexie @ iexde @ iexde @ iexde @
    mpbiri (iani (iani _ h3) @ eqcom @ xastMoveq h2 h4) ,eqtac)
  '(splitBitsA4ic (appendSi @ appendSi append1) ,bvSizeSi h1 @ splitBits14ie dec8));

theorem decodeMovRMI
  (h1: $ splitBits ((1 <> v) : (1 <> 1) : (2 <> 2) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readModRM rex reg r l $):
  $ decodeAux rex (xastMov sz (R_rm reg r)) (ch x8 a) l $ =
'(decodeMovRegI h1 h2 h3 @ ifpos true1);

theorem decodeMovMRI
  (h1: $ splitBits ((1 <> v) : (1 <> 0) : (2 <> 2) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readModRM rex reg r l $):
  $ decodeAux rex (xastMov sz (Rm_r r reg)) (ch x8 a) l $ =
'(decodeMovRegI h1 h2 h3 @ ifneg true0);

theorem decodeMov64I
  (h1: $ splitBits ((3 <> r) : (1 <> v) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readFullImm sz imm l $)
  (h4: $ REX_B rex = rb $)
  (h5: $ splitBits ((3 <> r) : (1 <> rb) : 0) r2 $):
  $ decodeAux rex (xastMov sz (Rm_i (RM_reg r2) imm)) (ch xb a) l $ =
(focus
  '(decodeMovI @ orl @ orr @ iexie @ iexde @ iexde @
    mpbiri (iani (iani _ _) _) ,eqtac)
  '(splitBitsA4ic (appendSi append1) ,bvSizeSi h1 @ splitBits14ie decb)
  '(mpbir (readFullImmeq1 h2) h3)
  '(eqcom @ xastMoveq h2 @ Rm_ieq1 @ RM_regeq @
    eqtr (rex_regeq1 h4) @ rex_reg_i h5));

theorem decodeMovImmI
  (h1: $ splitBits ((1 <> v) : (3 <> 3) : 0) a $)
  (h2: $ opSizeW rex v = sz $)
  (h3: $ readOpcodeModRM rex opc r l1 $)
  (h4: $ readImm sz imm l2 $):
  $ decodeAux rex (xastMov sz (Rm_i r imm)) (ch xc a) (l1 '+ l2) $ =
(focus
  '(decodeMovI @ orr @ iexie ,(iterate 5 (fn (x) '(iexde ,x))
    '(mpbiri (iani (iani (iani (iani s2nsadd _) h3) _) _) ,eqtac)))
  '(splitBitsA4ic (appendSi append1) ,bvSizeSi h1 @ splitBits14ie decc)
  '(mpbir (readImmeq1 h2) h4)
  '(eqcom @ xastMoveq1 h2));

theorem decodeTwoI (h: $ ,(foldr '(2 2 2 2 6) (get-decl 'decodeTwo) nth) $):
  $ decodeAux rex ast (ch x0 xf) (b2 ': l2) $ =
'(orr @ iani eqid @ iexie @ iexde @ mpbiri (iani s2nscons h) ,eqtac);

theorem decodeSysCallI: $ decodeAux rex xastSysCall (ch x0 xf) (s1 (ch x0 x5)) $ =
'(decodeAux_s1 @ decodeTwoI @ orr @ iani (iani eqid s2ns0) eqid);

------------
-- Linker --
------------

def assembled (c s: string) (start end: nat): wff =
$ end = start + len s /\ E. n (start = text_start + n /\ sublistAt n c s) $;

theorem assembled_start (h: $ assembled c s x y $): $ text_start <= x $ =
(named '(eex (anwl @ mpbiri leaddid1 leeq2) @ anr h));

theorem assembled_end (h: $ assembled c s x y $): $ y <= text_start + len c $ =
(named @ focus
  '(mpbir (leeq1 @ anl h) @ eex _ @ anr h)
  '(mpbird (leeq1d @ syl6eq addass @ addeq1d anl) @
    sylib leadd2 @ anwr sublistAt_len_le));

def assembled_func (c s: string) (start end: nat): wff =
$ assembled c s start end /\ start < end $;

theorem assembled_func_lt (h: $ assembled_func c s x y $): $ x < text_start + len c $ =
'(ltletr (anr h) (assembled_end @ anl h));

theorem assembled_func_bound (h: $ assembled_func c s x y $):
  $ text_start <= x /\ x < text_start + len c $ =
'(ian (assembled_start @ anl h) @ assembled_func_lt h);

def assembles (c s: string) (start end: nat) (p q: wff): wff =
$ E. n (start = text_start + n /\ sublistAt n c s) /\ p -> end = start + len s /\ q $;

def assemble1 (s: string) (start end: nat): wff =
$ end = start + len s $;

theorem assemble1_0: $ assemble1 s0 x x $ =
'(eqtr2 (addeq2 @ eqtr (leneq s2ns0) len0) add02);
theorem assemble1_1 (h1: $ suc x = y $): $ assemble1 (s1 c) x y $ =
'(eqtr2 (addeq2 @ eqtr (leneq s2ns1) len1) @ eqtr add12 h1);
theorem assemble1_A (h1: $ assemble1 s x y $) (h2: $ assemble1 t y z $): $ assemble1 (s '+ t) x z $ =
'(eqtr h2 @ eqtr (addeq1 h1) @ eqtr4 addass @ addeq2 @ eqtr (leneq s2nsadd) appendlen);
theorem assemble1_S (h1: $ suc x = y $) (h2: $ assemble1 s y z $): $ assemble1 (c ': s) x z $ =
'(assemble1_A (assemble1_1 h1) h2);

def assembles_func (s: string) (start end: nat): wff =
$ assemble1 s start end /\ start < end $;

theorem assembles_func_I (h: $ assemble1 (c ': s '+ t) x y $):
  $ assembles_func (c ': s '+ t) x y $ =
'(iani h @ mpbir (lteq (eqcom add0) h) @ mpbi ltadd2 @ mpbir (lteq2 @
    eqtr (leneq @ eqtr s2nsadd @ eqtr (appendeq1 s2nscons) appendS) lenS) lt01S);

theorem assemble_1 (h: $ assemble1 s x y $): $ assembles c s x y p (p /\ assembled c s x y) $ =
(named '(iand (a1i h) @ iand anr (iand (a1i h) anl)));

theorem assemble_func (h: $ assembles_func s x y $):
  $ assembles c s x y p (p /\ assembled_func c s x y) $ =
(named '(sylibr (aneq2i @ aneq2i @ bian2 @ anr h) @ assemble_1 @ anl h));

theorem assemblesA
  (h1: $ assembles c s x y p q $)
  (h2: $ assembles c t y z q r $):
  $ assembles c (s '+ t) x z p r $ =
(named @ focus
  (have 'h3 '(bitr (sublistAteq3 s2nsadd) sublistAt_append))
  '(mpand (syl h1 @ anim1 @ eximi @ anim2 @ sylbi h3 anl) @
    mpand (syl h2 @ sylbir anass @ anim1 @ impcom @ syl5 anl @
      eexda @ iexde @ mpbird ,eqtac @ anwl @
      iand (syl6eq addass @ addeq1d anrl) @ rsyl anrr @ sylbi h3 anr) @
    iand (eqtrd anrl @ syl6eqr (addeq2 @ eqtr (leneq s2nsadd) appendlen) @
      syl6eq addass @ addeq1d @ anwl anrl) anrr));

theorem assembles0: $ assembles c s0 x x p p $ =
(named '(anim1 @ a1i assemble1_0));

theorem assembles_finish
  (h1: $ assembles c c ,0x400078 end T. p $)
  (h2: $ ,0x400078 + n = end $):
  $ len c = n /\ p $ =
(focus
  '(anim1 (eqcomd @ sylib addcan2 @ eqtrd (a1i h2) id) @ h1 @
    ian (iexe _ @ ian (eqcom add02) sublistAt_id) tru)
  eqtac);

do {
  -- (mk-asm1 x s) returns a pair (y p) where p: $ assemble1 s x y $
  (def (mk-asm1 x s) @ match s
    [('scons c s)
      @ match (mksuc x) @ (y p)
      @ match (mk-asm1 y s) @ (z p2)
      '(,z (assemble1_S ,c ,s ,x ,y ,z ,p ,p2))]
    [('sadd s t)
      @ match (mk-asm1 x s) @ (y p)
      @ match (mk-asm1 y t) @ (z p2)
      '(,z (assemble1_A ,s ,t ,x ,y ,z ,p ,p2))]
    [('s1 c) @ match (mksuc x) @ (y p) '(,y (assemble1_1 ,c ,x ,y ,p))]
    ['(s0) '(,x (assemble1_0 ,x))])

  -- (reg-idx) converts atoms like 'rax, 'rcx, and 'r14 into their indexes.
  (def reg-idx @ lookup-fn @ append
    '([rax 0] [rcx 1] [rdx 2] [rbx 3] [rsp 4] [rbp 5] [rsi 6] [rdi 7])
    (rmap (range 0 15) @ fn (i) '[,(atom-app 'r i) i]))

  -- (asm1-len inst) gets the projected byte length of an instruction.
  (def asm1-len @ match-fn
    ['(mov.32 ,_ ,_) 5]
    ['(syscall) 2])

  -- (assemble-measure xs) does the first assembly pass, calculating the length of
  -- all instructions and assigning positions to the symbols.
  -- It returns ((entry_idx entry) xs') where `entry` is the entry address and
  -- `entry_idx` is the index of the entry function in the xs list, and xs' is
  -- the same as `xs` but with symbol references replaced by their locations.
  --
  -- See (assemble) for the input grammar of xs.
  (def (assemble-measure xs)
    (def idx (ref! 0))
    (def start 0x400078)
    (def pos (ref! start))
    (def entity @ lookup-fn @ rmap xs @ match-fn @ (ty name data)
      (def r '[,name (,(get! idx) ,(get! pos))])
      (set! idx {idx + 1})
      (set! pos {pos + (match ty
        ['func @ apply + @ map asm1-len data]
        ['string (string-len data)])})
      r)

    @ letrec (
      [eval-si @ match-fn ['{,k * ,x} '{,k * ,(eval x)}] [x x]]
      [eval @ match-fn
      ['(M {,si + ,x + ,n}) '(M ,(eval-si si) ,(eval x) ,(eval n))]
      ['(M {,si + ,n}) @ match (eval n)
        ['(reg ,x) '(M ,(eval-si si) (reg ,x) 0)]
        [n '(M ,(eval-si si) 0 ,n)]]
      ['(M ,si) '(M ,(eval-si si) 0 0)]
      [((? atom? x)) (nth 1 (entity x))]
      [(? number? n) n]
      [(? atom? x) '(reg ,(reg-idx x))]])

    @ list (entity 'main)
    @ rmap xs @ match-fn @ (ty name data)
    @ list name (nth 1 (entity name)) ty @ match ty
      ['func @ rmap data @ match-fn
        [(asm . args) (cons asm (map eval args))]]
      ['string data])

  (def (assemble-rex . xs)
    (def idx @ match-fn ['B 0] ['X 1] ['R 2] ['W 3])
    (def i @ foldl xs 0 @ match-fn*
      ['(,i (,bit (d1))) {i + {2 ^ (idx bit)}}]
      [(i _) i])
    @ if {i = 0}
      (cons $0$
        @ rmap xs @ match-fn @ (bit _) '(,(atom-app 'REX_ bit '_0)))
      (cons (def rex '(h2n @ ,(hexdigit i))) '(suc ,rex)
        @ rmap xs @ match-fn @ (bit a)
          '(,(atom-app 'REX_ bit '_Si) ,a ,rex (,(xbit i (idx bit))))))

  (def (mk-rex . xs)
    (def idx @ match-fn ['B 0] ['X 1] ['R 2] ['W 3] [n n])
    (def i @ foldl xs 0 @ match-fn*
      ['(,i (,bit (d1))) {i + {2 ^ (idx bit)}}]
      [(i _) i])
    @ if {i = 0}
      (cons $0$
        @ rmap xs @ match-fn @ (bit _)
        @ if (number? bit) '(,(xbit i bit)) '(,(atom-app 'REX_ bit '_0)))
      (cons (def rex '(h2n @ ,(hexdigit i))) '(suc ,rex)
        @ rmap xs @ match-fn @ (bit a)
        (def p '(,(xbit i (idx bit))))
        @ if (number? bit) p '(,(atom-app 'REX_ bit '_Si) ,a ,rex ,p)))

  (def assemble-inst
    (def (asm-aux rex ast opc s p) @ match rex
      [$0$ '(,ast $,opc ': ,s$ (decode0I ,ast ,opc ,s ,p))]
      [$suc (h2n ,rex)$
        '(,ast $ch ,'(x4) ,rex ': ,opc ': ,s$ (decode1I ,ast ,opc ,rex ,s ,p))])
    @ match-fn
      ['(mov.32 (reg ,r2) ,(? number? imm))
        @ match (mk-splitBits '(3 1) r2) @ (r rb h5)
        (def v $1$) (def sz '(wSz32))
        @ match (merge-bits '(3 1) r v) @ (a h1)
        (def r2 (hexdigit r2)) (def a '(,(hexdigit a)))
        @ match (assemble-rex '(B ,rb) '(3 $0$)) @ (rex h4 hsz)
        (def h2 @ match rex
          [$0$ '(opSizeW_0 ,sz ,v (opSize_32 $F.$))]
          [$suc ,rex$ '(opSizeW_S ,sz ,rex ,v $0$ ,hsz (opSize_32 $F.$))])
        (def imm_x (->zhex imm))
        @ match (to-iNBytes 32 imm_x) @ (l heq)
        (def h3 '(readFullImm32I ,imm_x ,l ,(to-eli 32 imm_x) ,heq))
        @ asm-aux rex $ xastMov ,sz (Rm_i (RM_reg ,r2) ,imm_x) $ '(ch (xb) ,a) l
        @ list 'decodeMov64I a imm_x l r r2 rb rex sz v h1 h2 h3 h4 h5]
      ['(syscall)
        @ asm-aux $0$ '(xastSysCall) '(ch (x0) (xf)) '(s1 @ ch (x0) (x5))
        '(decodeSysCallI $0$)])

  -- (assemble-core base main bss vis entry_idx entry xs')
  -- assembles an ELF file, producing the file and a correctness theorem.
  -- See (assemble) for the meaning of the `base main bss vis` arguments,
  -- and (assemble-measure) for the `entry_idx entry xs'` arguments.
  (def (assemble-core base main bss vis entry_idx entry xs)
    (def start 0x400078)
    (def start_x (->hex start))
    (def pfx (atom-app base _))
    (def content (atom-app pfx 'content))
    (def pos_x (ref! start_x))

    -- items: list (pfx_name, assembled_prop, assembled_proof,
    --   option (list (inst_ast, inst_byte_str, decode_proof)))
    (def items @ rmap xs
      @ match-fn @ (name _ ty data)
      (def name_asm (atom-app pfx name '_asm))
      @ match (match ty
        ['func
          (def asm @ map assemble-inst data)
          (def str @ foldr asm '(s0) @ fn (asm s) '(sadd ,(nth 1 asm) ,s))
          '(,str assembled_func (assemble_func @ assembles_func_I ,name_asm) ,asm)]
        ['string '(,(string->hex data) assembled (assemble_1 ,name_asm) #undef)])
        @ (str kind asf asm)
      @ match (mk-asm1 (get! pos_x) str) @ (pos2_x pf)
      (def name2 (atom-app pfx name))
      (add-term! name2 () '(string ()) () () str)
      (add-tac-thm! name_asm () ()
        '(assemble1 (,name2) ,(get! pos_x) ,pos2_x) ()
        (fn () (verb pf)))
      (def prop '(,kind (,content) (,name2) ,(get! pos_x) ,pos2_x))
      (set! pos_x pos2_x)
      (list name2 prop asf asm))

    (def content_s
      @ foldl items '(s0) (fn (x y) '(sadd ,x (,(nth 0 y)))))
    (add-term! content () '(string ()) () 'local content_s)

    (def pos (hex->number pos_x))
    (def filesz {pos - start})
    (def filesz_x (->hex filesz))
    @ match (to-uNBytes 64 filesz_x) @ (filesz_s filesz_p)

    (def asmd (atom-app pfx 'assembled))
    (add-tac-thm! asmd () ()
      '(an (eq (len (,content)) ,filesz_x)
        ,(foldl items '(wtru) @ fn (x y)
          '(an ,x ,(nth 1 y)))) ()
      @ fn ()
        '(assembles_finish
          ,(foldl items 'assembles0 @ fn (x y)
            '(assemblesA ,x ,(nth 2 y)))
          ,(verb @ nth 1 @ mkadd start_x filesz_x)))

    (def entry_x (->hex entry))
    @ match (to-uNBytes 64 entry_x) @ (entry_s entry_p)

    (def bss_x (->hex bss))
    (def memsz {filesz + bss})
    (def memsz_x (->hex memsz))
    @ match (to-uNBytes 64 memsz_x) @ (memsz_s memsz_p)

    (add-term! base () '(string ()) () vis
      '(ELF_lit ,entry_s ,filesz_s ,memsz_s (,content)))

    @ match (mkadd start_x memsz_x) @ (end_x end_p)
    (def parseElf (atom-app pfx 'parseElf))
    (add-tac-thm! parseElf () ()
      '(ELF_lit_ok (,base) ,entry_x ,bss_x (,content)) () @ fn () @ focus
      '(basicElf_ok
        ,(verb entry_p)
        ,(verb filesz_p)
        ,(verb memsz_p)
        ,(verb @ nth 1 @ mkadd filesz_x bss_x)
        (anli ,asmd)
        ,(verb end_p)
        (assembled_func_bound @ anri
          ,(iterate {(len xs) - 1 - entry_idx}
            (fn (x) '(anli ,x)) '(anri ,asmd)))
        ,(verb @ to-elu 64 end_x)))

    (add-thm! (atom-app pfx 'basicElf) () ()
      '(isBasicElf (,base)) vis
      '(() (ELF_lit_ok_isBasicElf (,base) ,entry_x ,bss_x (,content)
        (,parseElf)))))

  -- (assemble base main bss vis xs) assembles an ELF file, producing the file
  -- and a correctness theorem. `base` is the base name for all declarations,
  -- `main` is the name of the main function, `bss` is the number of bytes in the
  -- zeroed section, `vis` is the target visibility of the main theorems
  -- (either () or pub), and `xs` is the list of functions and data elements to
  -- assemble.
  --
  -- The xs argument is a list, where the arguments can have the form:
  -- * (func ,name ,data) where `name` is the name of the function and data
  --   is a list of assembly instructions
  -- * (data ,name ,str) where `name` is the name of the data element
  --   and `str` is a string literal with the target bytes
  --
  -- The assembly instructions in `data` are similar to those in a traditional
  -- assembler, but written as s-expressions. Most source/destination arguments
  -- can have the form:
  -- * `37`, etc: an immediate argument
  -- * `rax`, `r14`, etc: a register
  -- * `(reg 2)`: a register referenced by index
  -- * `(sym)`, where `sym` is a symbol: a symbol address
  --   (these are elaborated by (assemble-measure))
  -- * `(M 42)`, `(M rax)`, `(M {{4 * rax} + rsi + 14})`: memory reference
  --
  -- Available instructions:
  -- * (mov.32 dst src): 32 bit move dst <- src
  -- * (syscall): syscall instruction
  --
  -- The result of the program is a number of new definitions starting with `base`.
  --
  -- * def `base`_`name`: string;
  --   - This defines the strings in xs, the individual items that were declared
  --     with their given names
  -- * theorem `base`_`name`_asm: $ assemble1 base_name start end $;
  --   - The proof that base_name assembles from `start` to `end`
  -- * def `base`_content: string;
  --   - This is the "content" part of the ELF file, after the header. It is the
  --     concatenation of all the items
  -- * theorem `base`_assembled:
  --     $ len content = n /\ (/\_i assembled content name_i x_i x_i+1) $;
  --   - The result of assembly, which asserts the total length of the content
  --     as well as a conjunction asserting that every name_i assembles to its
  --     final location.
  -- * (pub) def `base`: string;
  --   - This is the complete ELF file string, with visibility `vis`.
  -- * theorem `base`_parseElf: $ ELF_lit_ok base entry bss base_content $;
  --   - The proof that `base` is an ELF file that parses to `base_content`.
  -- * (pub) def `base`_basicElf: $ isBasicElf base $;
  --   - The proof that `base` is an ELF file.
  (def (assemble base main bss vis xs)
    @ match (assemble-measure xs) @ ((entry_idx entry) xs)
    (assemble-core base main bss vis entry_idx entry xs))
};

@_ def X86P_Input = $ b0 0 $;
@_ def X86P_Output = $ b0 1 $;
@_ def X86P_RIP = $ b0 2 $;
@_ def X86P_Flags = $ b0 3 $;
@_ def X86P_Virtual (n: nat) = $ b0 (n + 4) $;
@_ def X86P_Reg (n: nat) = $ b1 (b0 n) $;
@_ def X86P_Mem (n: nat) = $ b1 (b1 n) $;

@_ def read_place (ks: nat): set =
$ case
    (ocase (pi11 ks)
      (ocase (pi12 ks)
        (ocase (readRIP (ksCfg ks))
          (ocase (readFlags (ksCfg ks))
            0))))
    (case
      (\ r, readReg (ksCfg ks) r)
      (\ a, getMemory (ksCfg ks) @ a <> ksMapping ks @ a)) $;

@_ def heap_sat (h ks: nat): wff =
$ A. p A. x (p <> x e. h -> read_place ks @ p = x) $;

@_ def heap_join (h1 h2: nat): nat =
$ if (Dom h1 i^i Dom h2 == 0) (lower (h1 u. h2)) 0 $;

@_ def s_and (P Q: set): set = $ Union P Q $;

@_ def s_sep (P Q: set): set =
$ {h | E. h1 E. h2 (h1 e. P /\ h2 e. Q /\ heap_join h1 h2 = suc h)} $;

@_ def s_wand (P Q: set): set =
$ {h2 | A. h1 A. h (h1 e. P -> heap_join h1 h2 = suc h -> h e. Q)} $;

@_ def x86_sat (P: set) (ks: nat): wff =
$ A. p A. x (p <> x e. P -> read_place ks @ p = x) $;

def prog_ok (elf: string) (i: nat) (P: set): wff =
$ A. k (initialConfig elf i k -> terminates_ensuring k P) $;

do {
  (def mmc-compiler (ref! (mmc-init)))
  (def mmc-reset
    (def c mmc-compiler)
    (fn () (set! c (mmc-init))))
  (def mmc-add
    (def c mmc-compiler)
    (fn xs (apply c '+ xs)))
  (def mmc-finish
    (def c mmc-compiler)
    (fn xs (apply c 'finish xs)))
  (def mmc-compiler)
  (def (mmc-compile x . xs)
    (apply mmc-add xs)
    (mmc-finish x))
};
