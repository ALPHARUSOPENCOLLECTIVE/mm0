import "x86.mm1";

theorem s2n_A (h1: $ s = a $) (h2: $ t = b $): $ s '+ t = a ++ b $ =
'(eqtr s2nsadd @ appendeq h1 h2);
theorem s2n_1 (h: $ c = a $): $ s1 c = a : 0 $ = '(eqtr s2ns1 @ conseq1 h);
theorem s2n_S (h1: $ c = a $) (h2: $ s = b $): $ c ': s = a : b $ =
'(eqtr (s2n_A (s2n_1 h1) h2) append1);
theorem s2n_SE (h: $ s = a $): $ c ': s = c : a $ = '(s2n_S eqid h);
theorem s2n_SAE (h: $ s = a ++ b $): $ c ': s = c : a ++ b $ =
'(eqtr4 (s2n_SE h) appendS);
theorem append01i (h: $ a = b $): $ a = 0 ++ b $ = '(eqtr4 h append0);
theorem s2n_R0: $ s0 = repeat a 0 $ = '(eqtr4 s2ns0 repeat0);
theorem s2n_R1 (h: $ c = a $): $ s1 c = repeat a 1 $ =
'(eqtr4 (s2n_1 h) repeat1);
theorem s2n_RA (h1: $ s = repeat a m $) (h2: $ t = repeat a n $):
  $ s '+ t = repeat a (m + n) $ = '(eqtr4 (s2n_A h1 h2) repeatadd);
theorem s2n_RS (h1: $ c = a $) (h2: $ s = repeat a n $):
  $ c ': s = repeat a (suc n) $ = '(eqtr4 (s2n_S h1 h2) repeatS);
theorem saddS: $ c ': s '+ t = c ': (s '+ t) $ =
'(eqtr4 (s2n_A s2nscons eqid) @ s2n_SAE s2nsadd);

theorem s2n_toBytesS0 (h: $ c = a $) (h2: $ s = repeat 0 k $):
  $ c ': s = toBytes (suc k) a $ =
'(eqtr (s2n_S (eqcom @ modltid @ mpbi elu8_2 c2nT) @
    eqtr4 h2 @ eqtr (toByteseq2 @ divlteq0 @ mpbi elu8_2 c2nT) toBytes02) @
  eqtr3 toBytesS @ toByteseq2 h);

theorem xtoBytes0: $ s0 = toBytes 0 a $ = '(eqtr4 s2ns0 toBytes0);
theorem xtoBytesS (h: $ s = toBytes k n $): $ ch a1 a0 ': s = toBytes (suc k) (n :x a1 :x a0) $ =
'(eqtr4 (s2n_S (eqtr4 c2nhex @ anr hex_divmod256) @
    eqtr4 h @ toByteseq2 @ anl hex_divmod256) toBytesS);
theorem xtoBytes1: $ s1 (ch a1 a0) = toBytes 1 (a1 :x a0) $ =
'(eqtr3 s2nscons0 @ eqtr (xtoBytesS xtoBytes0) @ toByteseq2 @ hexeq1 hex01);
theorem xu8Byte_2 (a0 a1: hex): $ ch a1 a0 = a1 :x a0 $ = 'c2nhex;
theorem xu8Byte_1 (a0: hex): $ ch x0 a0 = a0 $ = 'c2nh2n;
theorem xelu8_1 (a0: hex): $ a0 e. u8 $ = '(mpbi (eleq1 xu8Byte_1) c2nT);
theorem xelu8_2 (a0 a1: hex): $ a1 :x a0 e. u8 $ = '(mpbi (eleq1 xu8Byte_2) c2nT);

do {
  -- Constructs theorems like:
  -- theorem xu32Bytes_2 (a0 a1: hex):
  --   $ s2n (ch a1 a0 ': ch (x0) (x0) ': ch (x0) (x0) ': s1 (ch (x0) (x0))) =
  --     u32Bytes (h2n a1 :x a0) $;
  -- for u16, u32 and u64, and _2 counts the number of hex digits
  -- (from 1 to n/4 for the n-bit type)
  (scan '(16 32 64) @ fn (n)
    (def (name max) @ atom-app 'xu n 'Bytes_ max)
    (def (name2 max) @ atom-app 'xelu n '_ max)
    (def m {n // 4})
    (def (ai max i) @ if {i < max} (atom-app 'a i) '(x0))
    (def (mk_thm max proof)
      @ letrec (
        [(lhs i) (def j {i + 2})
          (def ch '(ch ,(ai max {i + 1}) ,(ai max i)))
          (if {j == m} '(s1 ,ch) '(scons ,ch ,(lhs j)))]
        [(rhs i) (def j {i + 1})
          (if {j == max} '(h2n ,(ai max i)) '(hex ,(rhs j) ,(ai max i)))])
      (def args @ rmap (range 0 max) @ fn (i) '(,(ai max i) hex ()))
      (def rhs (rhs 0))
      (add-tac-thm! (name max) args ()
        '(eq (s2n ,(lhs 0)) (,(atom-app 'u n 'Bytes) ,rhs)) () proof)
      (add-tac-thm! (name2 max) args () '(el ,rhs (,(atom-app 'u n))) () @ fn ()
        '(mpbir ,(atom-app 'elu n)
          ,(iterate {{max - 1} // 2} (fn (x) '(xlt256powS ,x))
            (if {{max % 2} == 0} 'xlt256pow1 'xlt256pow0)))))
    (mk_thm m @ fn ()
      @ iterate {{n // 8} - 1} (fn (x) '(xtoBytesS ,x)) 'xtoBytes1)
    (for 1 m @ fn (max)
      @ mk_thm max @ fn ()
      '(eqtr ,(name m) @ ,(atom-app 'u n 'Byteseq)
        ,(iterate {max - 1} (fn (x) '(hexeq1 ,x))
        @ iterate {m - max - 1} (fn (x) '(eqtr (hexeq1 ,x) hex01))
        'hex01))))

  -- (to_u8_ch a) returns a pair `(c p)` where p: $ c2n c = a $
  (def to_u8_ch @ match-fn
    [('hex ('h2n a) b) '((ch ,a ,b) (c2nhex ,a ,b))]
    [('h2n a) '((ch (x0) ,a) (c2nh2n ,a))])

  -- (to_fixed_str N a) returns a pair `(s p)` where p: $ s2n s = uNBytes a $
  -- assuming N = 16,32,64
  (def (to_fixed_str n a)
    @ letrec (
      [get-args @ match-fn
        [('hex a b) (cons b (get-args a))]
        [('h2n a) (list a)]]
      [str @ match-fn
        [(b a) '(s1 (ch ,a ,b))]
        [(b a . c) '(scons (ch ,a ,b) ,(str c))]])
    (def args (get-args a))
    (def max (len args))
    (def m {n // 4})
    @ list (str @ append args (repeat '(x0) {m - max}))
    @ cons (atom-app 'xu n 'Bytes_ max) args)

  -- (to_elu N a) returns a proof that a is a hex literal in uN: $ a e. uN $
  -- assuming N = 8,16,32,64
  (def (to_elu n a)
    @ letrec (
      [get-args @ match-fn
        [('hex a b) (cons b (get-args a))]
        [('h2n a) (list a)]])
    (def args (get-args a))
    @ cons (atom-app 'xelu n '_ (len args)) args)
};

def _x00: char = 0;
def _x01: char = 1;
def _x02: char = 2;
def _x00x2: string = $ _x00 ': _x00 ': s0 $;
def _x00x4: string = $ _x00x2 '+ _x00x2 $;
def _x00x8: string = $ _x00x4 '+ _x00x4 $;

theorem _x00_eq: $ _x00 = 0 $ = '{,norm_num : $ ch = _ $};
theorem _x01_eq: $ _x01 = 1 $ = '{,norm_num : $ ch = _ $};
theorem _x02_eq: $ _x02 = 2 $ = '{,norm_num : $ ch = _ $};

theorem _x00x2_eq: $ _x00x2 = repeat 0 2 $ =
'(s2n_RS _x00_eq @ s2n_RS _x00_eq @ s2n_R0);
theorem _x00x4_eq: $ _x00x4 = repeat 0 4 $ =
'(eqtr (s2n_RA _x00x2_eq _x00x2_eq) @ repeateq2 ,norm_num);
theorem _x00x8_eq: $ _x00x8 = repeat 0 8 $ =
'(eqtr (s2n_RA _x00x4_eq _x00x4_eq) @ repeateq2 ,norm_num);

def ELF_IDENT_s: string =
$ ,0x7f ': ,"E" ': ,"L" ': ,"F" ':
  _x02 ': _x01 ': _x01 ': _x00 ': _x00x8 $;

theorem ELF_IDENT_eq: $ ELF_IDENT_s = ELF_IDENT $ =
'(s2n_SAE @ s2n_SAE @ s2n_SAE @ s2n_SAE @ append01i @
  s2n_S _x02_eq @ s2n_S _x01_eq @ s2n_S _x01_eq @
  s2n_RS _x00_eq _x00x8_eq);

def _ch16 (c: char): string = $ c ': _x00 ': s0 $;
def _ch32 (c: char): string = $ c ': _x00 ': _x00x2 $;
def _ch64 (c: char): string = $ _ch32 c '+ _x00x4 $;

theorem _ch16_eq (h: $ c = a $): $ _ch16 c = u16Bytes a $ =
'(s2n_toBytesS0 h @ s2n_RS _x00_eq @ s2n_R0);
theorem _ch32_eq (h: $ c = a $): $ _ch32 c = u32Bytes a $ =
'(s2n_toBytesS0 h @ s2n_RS _x00_eq @ _x00x2_eq);
theorem _ch64_eq (h: $ c = a $): $ _ch64 c = u64Bytes a $ =
'(eqtr saddS @ s2n_toBytesS0 h @
  eqtr (s2n_RA (s2n_RS _x00_eq _x00x2_eq) @ _x00x4_eq) @
  repeateq2 ,norm_num);

-- 0x400000 as u64, the hard coded entry point
def load_start_s (c: char): string = $ c ': _x00 ': ,0x40 ': _x00 ': _x00x4 $;
def load_start (x y): nat = $ ,0x4000 :x x :x y $;
def text_start: nat = $ load_start x7 x8 $;

theorem load_start_eq2: $ load_start x0 x0 + x :x y = load_start x y $ =
'(add_xx0 (add_x00 addx01) addx01);
theorem load_start_pow2: $ load_start x0 x0 = 2 ^ ,22 $ =
'(eqtr (x2powS @ x2powS @ x2powS @ x2powS @ x2powS @ eqtr2 d2pow2 dec4) @
  poweq2 ,norm_num);

theorem load_start_T: $ load_start x y e. u64 $ =
'(ssel u32ss64 @ mpbir elu32 @ xlt256powS @ xlt256powS xlt256pow1);
theorem load_start_eq: $ load_start_s (ch x y) = u64Bytes (load_start x y) $ =
(focus
  '(xtoBytesS @ xtoBytesS @ eqtr _ @ toByteseq2 @ hexeq1 hex01_)
  '(xtoBytesS @ eqtr4 (s2n_RS _x00_eq _x00x4_eq) toBytes02));

def ELF_header_s (e: string): string =
$ ELF_IDENT_s '+ _ch16 _x02 '+ _ch16 ,0x3e '+ _ch32 _x01 '+
  e '+ _ch64 ,64 '+ _x00x8 '+
  _x00x4 '+ _ch16 ,64 '+ _ch16 ,0x38 '+ _ch16 _x01 '+
  _ch16 ,64 '+ _x00x4 $;

theorem ELF_header_ok (he: $ e = u64Bytes entry $) (he2: $ entry e. u64 $):
  $ elfHeader (ELF_header_s e) entry 64 0 1 0 $ =
(focus
  (for 0 7 @ fn (_) (refine '(ian _ _)))
  (def h0 '(mpbir elu8_3 @ mpbir (lteq1 ,to_hex) xlt256pow0))
  (def h1 '(mpbir elu8_3 @ mpbir (lteq1 ,to_hex) xlt256pow1))
  (def h2 '(mpbir (lteq2 @ eqtr bitsNeg1 upto16) ,norm_num))
  (refine 'he2 '(ssel u8ss64 ,h1) 'elBits01
    '(ssel u8ss16 ,h0) h2 'elBits01 h2) (swap)
  '(ax_mp (!! iexe _1 ,eqtac) @ ian elBits01 _)
  '(s2n_A ELF_IDENT_eq @ s2n_A (_ch16_eq _x02_eq) @
    s2n_A (_ch16_eq eqid) @ s2n_A (_ch32_eq _x01_eq) @
    s2n_A he @ s2n_A (_ch64_eq ,norm_num) @
    s2n_A (eqtr4 _x00x8_eq toBytes02) @ s2n_A (eqtr4 _x00x4_eq toBytes02) @
    s2n_A (! _ch16_eq $64$ _ ,norm_num) @ s2n_A (_ch16_eq eqid) @
    s2n_A (_ch16_eq _x01_eq) @ s2n_A (! _ch16_eq $64$ _ ,norm_num) @
    s2n_A (eqtr4 _x00x2_eq toBytes02) (eqtr4 _x00x2_eq toBytes02)));

def PAGE_SIZE_s: string = $ _x00 ': _x00 ': ,0x20 ': _x00 ': _x00x4 $;
def PAGE_SIZE: nat = $ 2 ^ ,21 $;
theorem PAGE_SIZE_val: $ PAGE_SIZE = ,0x200000 $ =
'(eqtr2 (x2powS @ x2powS @ x2powS @ x2powS @ x2powS @ eqtr2 pow12 dec2) @
  poweq2 ,norm_num);
theorem PAGE_SIZE_eq: $ PAGE_SIZE_s = u64Bytes PAGE_SIZE $ =
(focus
  '(eqtr4 _ @ u64Byteseq PAGE_SIZE_val)
  '(xtoBytesS @ xtoBytesS @ eqtr _ @ toByteseq2 @ hexeq1 hex01_)
  '(xtoBytesS @ eqtr4 (s2n_RS _x00_eq _x00x4_eq) toBytes02));

def basic_pHeader_s (filesz memsz: string): string =
$ _ch32 _x01 '+ _ch32 ,7 '+
  _ch64 ,0x78 '+ load_start_s ,0x78 '+ _x00x8 '+
  filesz '+ memsz '+ PAGE_SIZE_s $;

def PROT_RWX = $ 7 $;
theorem PROT_RWX_val: $ PROT_RWX = upto 3 $ =
'(mpbi addcan1 @ eqtr4 (eqtr4 add12 d2pow3) uptoadd1);
theorem ss_PROT_RWX: $ p e. Prot <-> p C_ PROT_RWX $ =
'(bitr4 elBits @ sseq2 @ nseq PROT_RWX_val);
theorem PROT_RWX_T: $ PROT_RWX e. Prot $ = '(mpbir ss_PROT_RWX ssid);
theorem PROT_RWX_R: $ PROT_READ C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_READ_T);
theorem PROT_RWX_W: $ PROT_WRITE C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_WRITE_T);
theorem PROT_RWX_X: $ PROT_EXEC C_ PROT_RWX $ = '(mpbi ss_PROT_RWX PROT_EXEC_T);
theorem PROT_RWX_flags: $ protToFlags PROT_RWX = 7 $ =
(focus
  '(eqtr (ifpos PROT_RWX_X) @ eqtr4 (b1eq _) d7half)
  '(eqtr (ifpos PROT_RWX_W) @ eqtr4 (b1eq _) d3half)
  '(ifpos PROT_RWX_R));

theorem basic_pHeader_ok
  (hfs: $ fs = u64Bytes filesz $)
  (hms: $ ms = u64Bytes memsz $)
  (hle: $ filesz <= memsz $)
  (hms2: $ memsz e. u64 $):
  $ pHeader (basic_pHeader_s fs ms) PT_LOAD PROT_RWX
      (ch x7 x8) text_start filesz memsz $ =
(focus
  (for 0 7 @ fn (_) (refine '(ian _ _)))
  (def h0 '(mpbir elu8_3 @ mpbir (lteq1 ,to_hex) xlt256pow0))
  (def h1 '(mpbir elu8_3 @ mpbir (lteq1 ,to_hex) xlt256pow1))
  (refine '(ssel u8ss32 {,h0 : $ 1 e. _ $}) 'PROT_RWX_T
    '(ssel u8ss64 ,h1) 'load_start_T '(Bitsle1 hle hms2) 'hms2 'hle)
  (have 'hM '(eqtr3 load_start_eq2 @ addeq load_start_pow2 @ eqcom c2nhex))
  '(ax_mp (!! iexe _1 ,eqtac) @ ian
    (ian _ @ mpbir (dvdeq2 @
      eqtr (bitsSub_eq_sub (mpbir (leeq2 hM) leaddid2) load_start_T) @
      eqtr (subeq1 hM) pncan) @ powdvd _)
    (s2n_A (_ch32_eq _x01_eq) @
      s2n_A (_ch32_eq @ eqcom @ eqtr PROT_RWX_flags ,norm_num) @
      s2n_A (_ch64_eq eqid) @ s2n_A load_start_eq @
      s2n_A (eqtr4 _x00x8_eq toBytes02) @
      s2n_A hfs @ s2n_A hms PAGE_SIZE_eq))
  norm_num
  norm_num);

local def ELF_lit (e fs ms c: string): string =
$ ELF_header_s e '+ basic_pHeader_s fs ms '+ c $;

local def ELF_parse (entry bss: nat) (c: string): nat =
$ entry <> PROT_RWX <> text_start <> c ++ repeat 0 bss $;

theorem basicElf_ok
  (he: $ e = u64Bytes entry $)
  (hfs: $ fs = u64Bytes filesz $)
  (hms: $ ms = u64Bytes memsz $)
  (hbss: $ filesz + bss = memsz $)
  (hlen: $ len c = filesz $)
  (hend: $ ,0x400078 + memsz = end $)
  (hea: $ text_start <= entry /\ entry < text_start + len c $)
  (hbd: $ end e. u64 $):
  $ basicElf (ELF_lit e fs ms c) (ELF_parse entry bss c) $ =
(focus
  '(ian s2nT @ trud ,(iterate 9 (fn (x) '(!! iexde ,(dummy! 'nat) ,x))
    '(mpbiri _ ,eqtac)))
  (have 'h1 '(eqtr s2nsadd @ appendeq2 s2nsadd))
  (have 'he2 $ entry < end $
    '(ltletr (anr hea) @ mpbi (leeq2 hend) @ mpbi leadd2 @
      mpbir (leeq1 hlen) @ mpbi (leeq2 hbss) leaddid1))
  (have 'ehok '(ELF_header_ok he @ Bitsle1 (ltle he2) hbd))
  (have 'hl1 '(elArraylen @ an5l @ elfHeaderT ehok))
  (have 'phok '(basic_pHeader_ok
    (eqtr4 hfs @ u64Byteseq hlen)
    (eqtr4 hms @ u64Byteseq hbss)
    (mpbir (leeq1 hlen) leaddid1)
    (mpbir (eleq1 hbss) @ Bitsle1 (mpbi (leeq2 hend) leaddid2) hbd))) (swap)
  (have 'hl2 '(elArraylen @ an6l @ pHeaderT phok))
  (for 0 8 @ fn (_) (refine '(ian _ _)))
  (focus
    '(mpbir (sublistAteq2 h1) @ sublistAt_left sublistAt_id))
  (focus 'ehok)
  (focus
    '(mpbir (sublistAteq (eqtr2 add02 hl1) h1 eqid) @
      sublistAt_right @ sublistAt_left sublistAt_id))
  (focus 'phok)
  (focus
    '(mpbir (sublistAteq (eqtr2 (addeq hl1 @ eqtr add02 hl2)
        {,norm_num : $ 64 + ch x3 x8 = ch x7 x8 $}) h1 eqid) @
      sublistAt_right @ sublistAt_right sublistAt_id))
  (focus '(mpbir (eleq1 @ eqtr (addeq2 hbss) hend) hbd))
  (focus '(anl hea))
  (focus '(mpbir (lteq2 @ eqtr (addeq2 hbss) hend) he2))
  (focus '(preq2 @ preq2 @ preq2 @ appendeq2 @
    repeateq2 @ eqtr2 (subeq2 hlen) pncan2)));

---------------
-- Assembler --
---------------

def assembled (c s: string) (start end: nat): wff =
$ end = start + len s /\ E. n (start = text_start + n /\ sublistAt n c s) $;

theorem assembled_start (h: $ assembled c s x y $): $ text_start <= x $ =
(named '(eex (anwl @ mpbiri leaddid1 leeq2) @ anr h));

theorem assembled_end (h: $ assembled c s x y $): $ y <= text_start + len c $ =
(named @ focus
  '(mpbir (leeq1 @ anl h) @ eex _ @ anr h)
  '(mpbird (leeq1d @ syl6eq addass @ addeq1d anl) @
    sylib leadd2 @ anwr sublistAt_len_le));

def assembled_func (c s: string) (start end: nat): wff =
$ assembled c s start end /\ start < end $;

theorem assembled_func_lt (h: $ assembled_func c s x y $): $ x < text_start + len c $ =
'(ltletr (anr h) (assembled_end @ anl h));

theorem assembled_func_bound (h: $ assembled_func c s x y $):
  $ text_start <= x /\ x < text_start + len c $ =
'(ian (assembled_start @ anl h) @ assembled_func_lt h);

def assembles (c s: string) (start end: nat) (p q: wff): wff =
$ E. n (start = text_start + n /\ sublistAt n c s) /\ p -> end = start + len s /\ q $;

def assemble1 (s: string) (start end: nat): wff =
$ end = start + len s $;

theorem assemble1_0: $ assemble1 s0 x x $ =
'(eqtr2 (addeq2 @ eqtr (leneq s2ns0) len0) add02);

theorem assemble1_S (h1: $ suc x = y $)
  (h2: $ assemble1 s y z $): $ assemble1 (c ': s) x z $ =
'(eqtr (eqtr4 h2 (addeq1 h1)) @ eqtr4 addSass @
  addeq2 @ eqtr (leneq s2nscons) lenS);

def assembles_func (s: string) (start end: nat): wff =
$ assemble1 s start end /\ start < end $;

theorem assemble_1 (h: $ assemble1 s x y $): $ assembles c s x y p (p /\ assembled c s x y) $ =
(named '(iand (a1i h) @ iand anr (iand (a1i h) anl)));

theorem assemble_func (h: $ assembles_func s x y $):
  $ assembles c s x y p (p /\ assembled_func c s x y) $ =
(named '(sylibr (aneq2i @ aneq2i @ bian2 @ anr h) @ assemble_1 @ anl h));

theorem assemblesA
  (h1: $ assembles c s x y p q $)
  (h2: $ assembles c t y z q r $):
  $ assembles c (s '+ t) x z p r $ =
(named @ focus
  (have 'h3 '(bitr (sublistAteq3 s2nsadd) sublistAt_append))
  '(mpand (syl h1 @ anim1 @ eximi @ anim2 @ sylbi h3 anl) @
    mpand (syl h2 @ sylbir anass @ anim1 @ impcom @ syl5 anl @
      eexda @ !! iexde _1 @ mpbird ,eqtac @ anwl @
      iand (syl6eq addass @ addeq1d anrl) @ rsyl anrr @ sylbi h3 anr) @
    iand (eqtrd anrl @ syl6eqr (addeq2 @ eqtr (leneq s2nsadd) appendlen) @
      syl6eq addass @ addeq1d @ anwl anrl) anrr));

theorem assembles0: $ assembles c s0 x x p p $ =
(named '(anim1 @ a1i assemble1_0));

theorem assembles_finish
  (h1: $ assembles c c ,0x400078 end T. p $)
  (h2: $ ,0x400078 + n = end $):
  $ len c = n /\ p $ =
(focus
  '(anim1 (eqcomd @ sylib addcan2 @ eqtrd (a1i h2) id) @ h1 @
    ian (!! iexe a _ @ ian (eqcom add02) sublistAt_id) tru)
  eqtac);

do {
  -- (mk-asm1 x s) returns a pair (y p) where p: $ assemble1 s x y $
  (def (mk-asm1 x s) @ match s
    [('scons c s)
      @ match (mksuc x) @ (y p)
      @ match (mk-asm1 y s) @ (z p2)
      '(,z (assemble1_S ,c ,s ,x ,y ,z ,p ,p2))]
    ['(s0) '(,x (assemble1_0 ,x))])

  -- (assemble base main bss vis xs) assembles an ELF file, producing the file
  -- and a correctness theorem. `base` is the base name for all declarations,
  -- `main` is the name of the main function, `bss` is the number of bytes in the
  -- zeroed section, `vis` is the target visibility of the main theorems
  -- (either () or pub), and `xs` is the list of functions and data elements to
  -- assemble.
  --
  -- The xs argument is a list, where the arguments can have the form:
  -- * (func ,name ,data) where `name` is the name of the function and data
  --   is a list of assembly instructions (right now just bytes)
  -- * (data ,name ,str) where `name` is the name of the data element
  --   and `str` is a string literal with the target bytes
  --
  -- The result of the program is a number of new definitions starting with `base`.
  --
  -- * def `base`_`name`: string;
  --   - This defines the strings in xs, the individual items that were declared
  --     with their given names
  -- * theorem `base`_`name`_asm: $ assemble1 base_name start end $;
  --   - The proof that base_name assembles from `start` to `end`
  -- * def `base`_content: string;
  --   - This is the "content" part of the ELF file, after the header. It is the
  --     concatenation of all the items
  -- * theorem `base`_assembled:
  --     $ len content = n /\ (/\_i assembled content name_i x_i x_i+1) $;
  --   - The result of assembly, which asserts the total length of the content
  --     as well as a conjunction asserting that every name_i assembles to its
  --     final location.
  -- * (pub) def `base`: string;
  --   - This is the complete ELF file string, with visibility `vis`.
  -- * (pub) def `base`_Elf: nat;
  --   - The parsed ELF, with visibility `vis`.
  -- * (pub) def `base`_basicElf: $ basicElf base base_Elf $;
  --   - The proof that `base` is an ELF file that parses to `base_Elf`.
  (def (assemble base main bss vis xs)
    (def pfx (atom-app base _))
    (def idx (ref! 0))
    (def entry (ref!))
    (def start 0x400078)
    (def start_x (->hex start))
    (def pos_x (ref! start_x))
    (def content (atom-app pfx 'content))
    (def items @ rmap xs @ fn (it)
      (def (finish name is_entry str kind asm)
        (def str_s (string->hex str))
        @ match (mk-asm1 (get! pos_x) str_s) @ (pos2_x pf)
        (def name2 (atom-app pfx name))
        (add-term! name2 () '(string ()) () () str_s)
        (def name_asm (atom-app pfx name '_asm))
        (add-tac-thm! name_asm () ()
          '(assemble1 (,name2) ,(get! pos_x) ,pos2_x) ()
          (fn () (verb pf)))
        (def prop '(,kind (,content) (,name2) ,(get! pos_x) ,pos2_x))
        (def asm (asm (get! pos_x) pos2_x name_asm))
        (set! pos_x pos2_x)
        (set! idx {idx + 1})
        (list name2 is_entry prop asm))
      @ match it
        [('func name data)
          (if {name == main} (set! entry @ list (get! idx) (get! pos_x)))
          (def str (list->string @ join data))
          (finish name {name == main} str 'assembled_func
            @ fn (p1 p2 x) '(assemble_func @ iani ,x
              ,(verb @ nth 1 @ mkcmp2 p1 p2)))]
        [('string name str)
          (finish name #f str 'assembled @ fn (_ _ x) '(assemble_1 ,x))])

    (def content_s
      @ foldl items '(s0) (fn (x y) '(sadd ,x (,(nth 0 y)))))
    (add-term! content () '(string ()) () 'local content_s)

    (def pos (hex->number pos_x))
    (def filesz {pos - start})
    (def filesz_x (->hex filesz))
    @ match (to_fixed_str 64 filesz_x) @ (filesz_s filesz_p)

    (def asmd (atom-app pfx 'assembled))
    (add-tac-thm! asmd () ()
      '(an (eq (len (,content)) ,filesz_x)
        ,(foldl items '(wtru) @ fn (x y)
          '(an ,x ,(nth 2 y)))) ()
      @ fn ()
        '(assembles_finish
          ,(foldl items 'assembles0 @ fn (x y)
            '(assemblesA ,x ,(nth 3 y)))
          ,(verb @ nth 1 @ mkadd start_x filesz_x)))

    @ match entry @ (entry_idx entry_x)
    @ match (to_fixed_str 64 entry_x) @ (entry_s entry_p)

    (def bss_x (->hex bss))
    (def memsz {filesz + bss})
    (def memsz_x (->hex memsz))
    @ match (to_fixed_str 64 memsz_x) @ (memsz_s memsz_p)

    (add-term! base () '(string ()) () vis
      '(ELF_lit ,entry_s ,filesz_s ,memsz_s (,content)))

    (def elf (atom-app pfx 'Elf))
    (add-term! elf () '(nat ()) () vis
      '(ELF_parse ,entry_x ,bss_x (,content)))

    @ match (mkadd start_x memsz_x) @ (end_x end_p)
    (add-tac-thm! (atom-app pfx 'basicElf) () ()
      '(basicElf (s2n (,base)) (,elf)) vis @ fn () @ focus
      '(basicElf_ok
        ,(verb entry_p)
        ,(verb filesz_p)
        ,(verb memsz_p)
        ,(verb @ nth 1 @ mkadd filesz_x bss_x)
        (anli ,asmd)
        ,(verb end_p)
        (assembled_func_bound @ anri
          ,(iterate {(len xs) - 1 - entry_idx}
            (fn (x) '(anli ,x)) '(anri ,asmd)))
        ,(verb @ to_elu 64 end_x))))
};

def X86P_Input = $ b0 0 $;
def X86P_Output = $ b0 1 $;
def X86P_RIP = $ b0 2 $;
def X86P_Flags = $ b0 3 $;
def X86P_Virtual (n: nat) = $ b0 (n + 4) $;
def X86P_Reg (n: nat) = $ b1 (b0 n) $;
def X86P_Mem (n: nat) = $ b1 (b1 n) $;

def read_place (ks: nat): set =
$ case
    (ocase (pi11 ks)
      (ocase (pi12 ks)
        (ocase (readRIP (ksCfg ks))
          (ocase (readFlags (ksCfg ks))
            0))))
    (case
      (\ r, readReg (ksCfg ks) r)
      (\ a, getMemory (ksCfg ks) @ a <> ksMapping ks @ a)) $;

def heap_sat (h ks: nat): wff =
$ A. p A. x (p <> x e. h -> read_place ks @ p = x) $;

def heap_join (h1 h2: nat): nat =
$ if (Dom h1 i^i Dom h2 == 0) (lower (h1 u. h2)) 0 $;

def s_and (P Q: set): set = $ Union P Q $;

def s_sep (P Q: set): set =
$ {h | E. h1 E. h2 (h1 e. P /\ h2 e. Q /\ heap_join h1 h2 = suc h)} $;

def s_wand (P Q: set): set =
$ {h2 | A. h1 A. h (h1 e. P -> heap_join h1 h2 = suc h -> h e. Q)} $;

def x86_sat (P: set) (ks: nat): wff =
$ A. p A. x (p <> x e. P -> read_place ks @ p = x) $;

do {
  (def mmc-compiler (ref! (mmc-init)))
  (def mmc-reset
    (def c mmc-compiler)
    (fn () (set! c (mmc-init))))
  (def mmc-add
    (def c mmc-compiler)
    (fn xs (apply c '+ xs)))
  (def mmc-finish
    (def c mmc-compiler)
    (fn xs (apply c 'finish xs)))
  (def mmc-compiler)
  (def (mmc-compile x . xs)
    (apply mmc-add xs)
    (mmc-finish x))
};
