import "separation_logic.mm1";

@_ local def X86P_Input = $ b0 0 $;
@_ local def X86P_Output = $ b0 1 $;
@_ local def X86P_Except = $ b0 2 $;
@_ local def X86P_RIP = $ b0 3 $;
@_ local def X86P_Flags = $ b0 4 $;
@_ local def X86P_Virtual (n: nat) = $ b0 (suc (suc (suc (suc (suc n))))) $;
@_ local def X86P_Reg (n: nat) = $ b1 (b0 n) $;
@_ local def X86P_Mem (n: nat) = $ b1 (b1 n) $;

@_ local def read_place (ks: nat): set =
$ case
    (ocase (ksIn ks)
      (ocase (ksOut ks)
        (ocase (readException (ksCfg ks))
          (ocase (readRIP (ksCfg ks))
            (ocase (readFlags (ksCfg ks))
              0)))))
    (case
      (\ r, readReg (ksCfg ks) r)
      (\ a, getMemory (ksCfg ks) @ a <> ksMapping ks @ a)) $;

theorem read_place_Input: $ read_place ks @ X86P_Input = ksIn ks $ =
(named '(eqtr casel ocase0));
theorem read_place_Output: $ read_place ks @ X86P_Output = ksOut ks $ =
(named '(eqtr casel @ eqtr ocaseS ocase0));
theorem read_place_Except: $ read_place ks @ X86P_Except = readException (ksCfg ks) $ =
(named '(eqtr casel @ eqtr ocaseS @ eqtr ocaseS ocase0));
theorem read_place_RIP: $ read_place ks @ X86P_RIP = readRIP (ksCfg ks) $ =
(named '(eqtr casel ,(iterate 3 (fn (x) '(eqtr ocaseS ,x)) 'ocase0)));
theorem read_place_Flags: $ read_place ks @ X86P_Flags = readFlags (ksCfg ks) $ =
(named '(eqtr casel ,(iterate 4 (fn (x) '(eqtr ocaseS ,x)) 'ocase0)));
theorem read_place_Virtual: $ read_place ks @ X86P_Virtual n = 0 $ =
(named '(eqtr casel ,(iterate 5 (fn (x) '(eqtr ocaseS ,x)) 'app01)));
theorem read_place_Reg: $ read_place ks @ X86P_Reg r = readReg (ksCfg ks) r $ =
(named '(eqtr caser @ eqtr casel @ applame ,eqtac));
theorem read_place_Mem: $ read_place ks @ X86P_Mem a = getMemory (ksCfg ks) @ a <> ksMapping ks @ a $ =
(named '(eqtr caser @ eqtr caser @ applame ,eqtac));

theorem read_place_setMemory_ne: $ ~E. a p = X86P_Mem a ->
  read_place (setCfg ks (setMemory (ksCfg ks) m)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_setMemory)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setMemory)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setMemory)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_setMemory)) +
     ($X86P_Mem n$ => (impcom @ syl absurdr @ iexe ,eqtac))}});
theorem read_place_setMemory_eq:
  $ read_place (setCfg ks (setMemory (ksCfg ks) m)) @ X86P_Mem a = m @ a <> ksMapping ks @ a $ =
'(eqtr read_place_Mem @
  preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) get_setMemory) @
  appneq1 ksMapping_setCfg);

theorem read_place_setException_ne: $ p != X86P_Except ->
  read_place (setCfg ks (setException (ksCfg ks) e)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => (imp absurd)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setException)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setException)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_setException)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_setException) @
        appneq1 ksMapping_setCfg)))}});

theorem read_place_writeFlags_ne: $ p != X86P_Flags ->
  read_place (setCfg ks (writeFlags (ksCfg ks) v)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_writeFlags)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_writeFlags)) o
     ($X86P_Flags$ => (imp absurd)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_writeFlags)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_writeFlags) @
        appneq1 ksMapping_setCfg)))}});

theorem read_place_writeRIP_ne: $ p != X86P_RIP ->
  read_place (setCfg ks (writeRIP (ksCfg ks) v)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_writeRIP)) o
     ($X86P_RIP$ => (imp absurd)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_writeRIP)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ => ,(h 'read_place_Reg 'readRegeq1 'readReg_writeRIP)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_writeRIP) @
        appneq1 ksMapping_setCfg)))}});

theorem read_place_setReg_ne: $ p != X86P_Reg r ->
  read_place (setCfg ks (setReg (ksCfg ks) r q)) @ p = read_place ks @ p $ =
(split-sop 'p
  (def (g x y) '(anwr @ mpbiri (eqtr4 ,x @ eqtr4 ,x ,y) ,eqtac))
  (def (h x y z) (g x '(eqtr (,y ksCfg_setCfg) ,z)))
  '{{($X86P_Input$ => ,(g 'read_place_Input 'ksIn_setCfg)) o
     ($X86P_Output$ => ,(g 'read_place_Output 'ksOut_setCfg)) o
     ($X86P_Except$ => ,(h 'read_place_Except 'readExceptioneq 'readException_setReg)) o
     ($X86P_RIP$ => ,(h 'read_place_RIP 'readRIPeq 'readRIP_setReg)) o
     ($X86P_Flags$ => ,(h 'read_place_Flags 'readFlagseq 'readFlags_setReg)) o
     ($X86P_Virtual n$ => ,(g 'read_place_Virtual 'eqid))} +
    {($X86P_Reg n$ =>
      (impcom @ mpbiri (sylbi (noteq @ bitr b1can b0can) @
          eqtr4g read_place_Reg read_place_Reg @
          syl5eq (readRegeq1 ksCfg_setCfg) read_setReg_ne)
        ,eqtac)) +
     ($X86P_Mem n$ => ,(g 'read_place_Mem
      '(preq (appneq1 @ eqtr (getMemoryeq ksCfg_setCfg) getMemory_setReg) @
        appneq1 ksMapping_setCfg)))}});

@_ local def XBlock_Reg (n: nat) = $ b0 (b0 n) $;
@_ local def XBlock_Mem (a len: nat) = $ b0 (b1 (a <> len)) $;
@_ local def XBlock_Const (val: nat) = $ b1 val $;

@_ local def MSize = $ 0 ; 8 ; 16 ; 32 ; sn 64 $;
@_ local def MSize_bytes (sz: nat) = $ sz // 8 $;

@_ local def heap_sat (k h: nat): wff =
$ isfun h /\ k e. KernelState /\ A. p A. x (p <> x e. h -> read_place k @ p = x) $;
infixl heap_sat: $|=h$ prec 50;

theorem heap_sat_isf: $ k |=h h -> isfun h $ = (named 'anll);
theorem heap_sat_ks: $ k |=h h -> k e. KernelState $ = (named 'anlr);

theorem heap_sat_02: $ k e. KernelState -> k |=h 0 $ =
(named '(iand (ian isf0) @ a1i @ ax_gen @ ax_gen @ absurd el02));

theorem heap_sat_sn: $ k |=h sn (p <> x) <-> k e. KernelState /\ read_place k @ p = x $ =
'(aneq (bian1 isfsn) @ bitr (aleqi @ bitr (aleqi @
    bitr (imeq1i @ bitr elsn prth) impexp) alim1) @
  aleqe @ syl5bb (aleqe ,eqtac) ,eqtac);

theorem heap_sat_E: $ k |=h h /\ p <> x e. h -> read_place k @ p = x $ =
'(impcom @ syl5 anr @ com12 @ ealie @ ealde @ bi1d ,eqtac);

@_ local def s_sat (k: nat) (P: set): wff = $ E. h (h e. P /\ k |=h h) $;
infixl s_sat: $|=s$ prec 50;
theorem s_sat_antop: $ k |=s P /\s T.s <-> k |=s P $ =
(named '(exeqi @ aneq1a @ syl5bb el_s_antop @ syl bian1 heap_sat_isf));
theorem s_sat_ks: $ k |=s P -> k e. KernelState $ = (named '(eex @ anwr heap_sat_ks));
theorem s_sat_bot: $ ~k |=s F.s $ = (named '(nexi @ mt anl el_s_bot));
theorem s_sat_emp: $ k e. KernelState -> k |=s emp $ =
(named '(sylibr (exeqi @ aneq1i el_s_emp) @ sylibr (exeqe heap_sateq2) heap_sat_02));
theorem s_sat_sep_emp1: $ k |=s emp *s P <-> k |=s P $ = '(bitr (s_sateq2 s_sep_emp1a) s_sat_antop);

theorem s_elConfig_d: $ G /\ ksCfg ks = k /\ ks |=s P -> k e. Config $ =
'(mpbid (eleq1d anlr) (anwr @ syl ksCfgT s_sat_ks));

theorem s_sat_sep_sn: $ k |=s R *s P <-> E. r (r e. R /\ k |=s sn r *s P) $ =
(named '(bitr4 (exeqi ancomb) @ bitr (rexeqi @ exeqi ancomb) @
  bitr4 rexcomb @ rexeqi @ bitr4 el_s_sep2 @ rexeqi el_s_sep_sn1));

theorem s_sat_sn: $ k |=s sn h <-> k |=h h $ =
'(bitr (exeqi @ aneq1i elsn) @ exeqe ,eqtac);

theorem s_sat_ex (P: set x): $ k |=s E.s x e. A, P <-> E. x (x e. A /\ k |=s P) $ =
(named '(bitr4 (exeqi @ bitr4 (aneq1i el_s_ex) rexan2) rexexcomb));

theorem s_sat_anlift1: $ k |=s ^s p /\s P <-> p /\ k |=s P $ =
(named '(bitr (exeqi @ bitr (aneq1a @
    syl5bb el_s_an @ aneq1d @ syl5bb el_s_lift @ syl bian1 heap_sat_isf) anass) @
  exan1));

theorem heap_sat_rlam: $ k |=h h /\ Dom h == a -> h = \. p e. a, read_place k @ p $ =
(named '(sylibr eqrlam @ iand (anim1 anll) @ mpd anlr @
  alimd @ com23 @ syld (bi2d @ eleq2d anr) @ syl5bi eldm @
  com23 @ syl6ibr eexb @ alimd @ a2d @ exp @ syl5ibrcom eqeq2 @ isfappd an4l anr));
theorem rlam_heap_sat: $ k e. KernelState -> k |=h \. p e. a, read_place k @ p $ =
(named '(iand (ian rlamisf) @ a1i @ ax_gen @ ax_gen @ sylbi elrlam @
  eex @ anwr @ sylbi prth @ mpbiri eqid @ eqeqd (appeq2d anl) anr));

theorem heap_sat_ss: $ q C_ p -> k |=h p -> k |=h q $ =
(named '(animd (anim1d isfss) @ alimd @ alimd @ imim1d ssel));

theorem s_weak_sat: $ P =>*s Q -> k |=s P -> k |=s Q $ =
(named '(sylbi s_weak_iff @ sylibr eexb @ alimi @ impd @ sylbi impexp @
  imim2i @ rsyl (imim1i heap_sat_isf) @ ax_2 @ eximd @ anim2d @ com12 heap_sat_ss));

theorem s_ss_sat: $ P C_ Q -> k |=s P -> k |=s Q $ = '(syl s_weak_sat ss_s_weak);

theorem s_sat_an: $ k |=s P /\s Q -> k |=s P /\ k |=s Q $ =
'(iand (s_ss_sat s_anl) (s_ss_sat s_anr));

theorem s_sat_sep: $ k |=s P *s Q -> k |=s P /\ k |=s Q $ =
'(iand (s_weak_sat s_sepl) (s_weak_sat s_sepr));

theorem s_sat_top: $ k e. KernelState <-> k |=s T.s $ =
'(ibii (syl (s_ss_sat s_emp_sstop) s_sat_emp) s_sat_ks);

theorem s_sat_lift: $ k |=s ^s p <-> k e. KernelState /\ p $ =
'(bitr3 s_sat_antop @ bitr s_sat_anlift1 @ bitr4 ancomb @ aneq1i s_sat_top);
theorem s_sat_elift: $ k e. KernelState -> (k |=s ^e p <-> p) $ =
'(syl5bb s_sat_anlift1 @ syl bian2 s_sat_emp);

theorem s_sat_frame_sn {q}
  (h1: $ G /\ q != p -> read_place k2 @ q = read_place k @ q $)
  (h2: $ G /\ read_place k @ p = v -> read_place k2 @ p = v2 $)
  (h3: $ G -> k |=s R *s sn (sn (p <> v)) $)
  (h4: $ G -> k2 e. KernelState $):
  $ G -> k2 |=s R *s sn (sn (p <> v2)) $ =
(named @ focus
  '(mpd h3 @ eexd @ impd @ syl5bi el_s_sep_sn2 @ eexda @ exp @ iexde _)
  (have 'H1 '(anrd anllr))
  (have 'H2 '(sylibr heap_join_S2 @ iand (rsyl H1 @
    sylbi heap_join_S2 @ anwl @ anim (anim2 @ a1i isfsn) @
    bi1i @ eqseq1 @ ineq2 @ eqstr4 dmsn dmsn) @ anwr eqcom))
  '(iand (sylibr el_s_sep_sn2 @ sylan iex (anld anllr) H2) @
    iand (iand (syl heap_join_isf3 H2) @ anw3l h4) @
    !! iald q @ !! iald a @ ! casesda _ $ q = p $ _ _ _)
  '(mpbird (anwr ,eqtac) @ anwl @
    sylbid (syl5bbr (bian2 @ mpbir (eleq2 dmsn) snid) @
      syl5bbr prelres @ eleq2d @ syl heap_join_res2 H2) @
    syl5ibrcom (sylbi elsn @ sylbi prth @ anwr ,eqtac) @
    sylan h2 an3l @ sylan heap_sat_E anlr @ sylib snss @ anrd @ syl heap_join_ss H1)
  '(sylbird (eleq2d @ syl heap_join_un @ anwl H2) @ syl5bi elun @
    syl5 orcom @ eimd (anwr @ con3 @ sylbi elsn @ sylbi prth anl) @
    syl5 orl @ syl5bir elun @ sylbid (eleq2d @ syl heap_join_un @ anwl H1) @
    sylibrd (syl (exp heap_sat_E) anllr) @ eqeq1d @ syl h1 (anim1 an3l)));

@_ local def prog_ok (elf i: nat) (P: set): wff =
$ A. k (initialConfig2 elf i k -> terminates_ensuring k P) $;

@_ local def s_ok (P T: set): wff =
$ A. k (k |=s P -> terminates_ensuring k T) $;

theorem s_ok_E: $ s_ok P T -> k |=s P -> terminates_ensuring k T $ = '(eale ,eqtac);

theorem s_ok_antop: $ s_ok (P /\s T.s) T <-> s_ok P T $ =
(named '(aleqi @ imeq1i s_sat_antop));

theorem s_ok_sep: $ s_ok (R *s P) T <-> A. r (r e. R -> s_ok (sn r *s P) T) $ =
(named @ focus
  '(bitr (aleqi _) @ bitr alcomb @ aleqi alim1)
  '(bitr (imeq1i s_sat_sep_sn) @ bitr eexb @ aleqi impexp));

theorem s_weak_ok: $ P =>*s Q -> s_ok Q T -> s_ok P T $ =
(named '(alimd @ imim1d s_weak_sat));

--| The separation logic hoare predicate.
--| It is parameterized by a final state predicate `T` that covers the property
--| to hold on early termination, and builds in the frame rule
--| (quantifying over a heap `fr` separate from `P` and `Q`).
--| The "code" part of the hoare triple is absent because this is stored in the
--| machine state; we will use top level predicates that contain the code segment
@_ local def hoare (T P Q: set): wff =
$ A. fr (s_ok (sn fr *s Q) T -> s_ok (sn fr *s P) T) $;

theorem hoare_frame_ok: $ hoare T P Q -> s_ok (R *s Q) T -> s_ok (R *s P) T $ =
(named '(sylibr (imeqi s_ok_sep s_ok_sep) @ syl ax_4 @ alimi imim2));
theorem hoare_ok: $ hoare T P Q -> s_ok Q T -> s_ok P T $ =
(let ([h '(bitr (s_okeq1 s_sep_emp1a) s_ok_antop)])
  '(sylib (imeqi ,h ,h) hoare_frame_ok));
theorem s_weak_hoare: $ P =>*s Q -> hoare T P Q $ =
(named '(iald @ syl s_weak_ok s_sep_weak2));
theorem hoare_id: $ hoare T P P $ = (named '(ax_gen id));
theorem hoare_tr: $ hoare T P Q -> hoare T Q R -> hoare T P R $ =
(named '(syl ax_4 @ alimi imim2));

-- The famous "frame rule" of separation logic.
theorem hoare_frame: $ hoare T P Q -> hoare T (R *s P) (R *s Q) $ =
(named '(iald @ sylib (imeqi (s_okeq1 s_sepass) (s_okeq1 s_sepass)) hoare_frame_ok));
theorem hoare_frame_r: $ hoare T P Q -> hoare T (P *s R) (Q *s R) $ =
'(sylib (hoareeq eqsid s_sepcom s_sepcom) hoare_frame);

theorem hoare_save_restore_lem (G: wff p)
  (hA: $ G -> finite A $)
  (hp: $ G -> p e. P $)
  (h1: $ G -> Dom p i^i A == 0 $)
  (h2: $ G -> heap_join fr p = suc fp $)
  (h3: $ G -> k |=h fp $):
  $ G -> E. a E. a1 E. af E. f1 E. afp (Dom a == A /\
      heap_join a1 af = suc a /\
      heap_join fp a1 = suc afp /\
      heap_join f1 af = suc fr /\
      k |=h afp) $ =
(focus
  (foldr '($A$  $ A i^i Compl (Dom fr) $  $ A i^i Dom fr $
    $ Dom fr i^i Compl A $  $ Dom fp u. A $) _
    (fn (x y) '(! iexde _ _ $ \. x e. lower ,x, _ $ _ ,y)))
  '(mpbird ,eqtac @ anw5l @ iand (iand (iand (iand _ _) _) _) _)
  (def A '(mpbi eqlower @ infin1 _))
  (have 'ha '(sylib eqlower hA))
  (have 'hb '(sylib eqlower @ syl infin1 hA))
  (have 'hc '(sylib eqlower @ syl infin1 hA))
  (have 'hd '(a1i @ mpbi eqlower @ infin1 @ dmfin finns))
  (have 'hp '(a1i @ mpbi eqlower @ dmfin finns))
  (have 'hfr '(a1i @ mpbi eqlower @ dmfin finns))
  (have 'hy '(sylib eqlower @ syl (unfin @ dmfin finns) hA))
  (def (f x y) '(sylan heap_sat_rlam ,x ,y))
  (focus '(syl5eqs dmrlam @ eqscomd ha))
  (focus
    '(mpbiri (iani _ _) @ sylan heap_join_rlam2 (iand hb hc) ha)
    '(eqstr3 inindi @ sseq0 inss2 incpl1)
    '(eqstr3 indi @ mpbi eqin1 @ mpbir (sseq2 uncpl1) ssv2))
  (focus
    '(eqtrd (heap_joineq1d ,(f 'h3 'hp)) @
      mpbird (sylan heap_join_rlam2 (iand hp hb) hy) @
      iand (eqstr3d (ineq1d @ syl heap_join_dmun h2) @
        syl5eqs indir @ sylibr uneq0 @ iand (a1i @ mpbir ineq0r inss2) @
        syl (sseq0 @ ssin2 inss1) h1) @
      !! iald x @ bitr4g elun elun @ syl oreq2a @ syl6 (syl5bb elin bian2) @
        syl6ibr elcpl @ con3d @ syl ssel @ syl dmss @ anld @ syl heap_join_ss h2))
  (focus
    '(eqtr4d (mpbiri (iani _ _) @ sylan heap_join_rlam2 (iand hd @ syl5eqs incom hc) hfr) @
      suceqd ,(f '(mpd h3 @ rsyl h2 @ syl heap_sat_ss @ anld heap_join_ss) 'hfr))
    '(eqstr3 inindi @ sseq0 inss2 incpl1)
    '(eqstr3 indi @ mpbi eqin1 @ mpbir (sseq2 uncpl1) ssv2))
  (focus '(syl rlam_heap_sat @ syl heap_sat_ks h3)));

--| A partial inverse to the frame rule: we can "unframe" by some heap `a`
--| with specified domain `A`. This allows us to prove that as long as we return
--| the values to what they were, we are permitted to capture things not in
--| the heap of `P`. This is useful for e.g. proving that callee-saved registers
--| can be used in a function and restored at the end, without the caller having
--| to pass them in.
theorem hoare_save_restore (G: wff p a)
  (hA: $ G -> finite A $)
  (h1: $ G -> A. p (p e. P -> Dom p i^i A == 0) $)
  (h2: $ G -> A. a (Dom a == A -> hoare T (sn a *s P) (sn a *s Q)) $):
  $ G -> hoare T P Q $ =
(named @ focus
  '(!! iald fr @ exp @ iald @ eexd @
    impd @ syl5bi el_s_sep_sn1 @ eexda @ exp @
    mpd (hoare_save_restore_lem (anw3l hA) (anld anlr) _ (anrd anlr) anr) _)
  (focus '(sylc _ (anw3l h1) (anld anlr)) '(eale ,eqtac))
  '(eexd @ eexd @ eexd @ eexd @ eexda @ sylc eal {_ : $ _ -> s_ok _ _ $} _)
  (focus
    '(sylc hoare_frame_ok _ @ sylc s_weak_ok _ an3lr)
    (focus '(sylc _ (anw4l h2) @ anwr an4l) '(eale ,eqtac))
    '(sylib (s_weakeq1 s_sepass) @ syl s_sep_weak1 @
      mpbii (s_sep_weak1 s_sepl) @ anwr @ s_weakeqd (syl5eqs s_sepass @
        s_sepeq2d @ sylibr s_sep_sn an3lr) @ sylibr s_sep_sn anlr))
  (focus
    '(sylan iex (mpbird (eleq2d _) @ sylibr el_s_sep_sn1 _) anrr)
    '(anwr @ eqstr3g s_sepass s_sepass @ s_sepeq1d @
      eqstr3d (s_sepeq2d @ syl5eqs s_sepcom @ sylibr s_sep_sn an3lr) @
      syl5eqsr s_sepass @ syl6eqs s_sepcom @ s_sepeq1d @ sylibr s_sep_sn anlr)
    '(sylan iex (sylibr el_s_sep_sn1 _) (anwr @ syl5eq heap_join_com anllr))
    '(sylan iex (anld anllr) (anrd anllr))));

theorem hoare_ksStep {k fr}
  (h1: $ G /\ k |=s sn fr *s P ->
         (P. k2 ksStep k k2 -> k2 |=s sn fr *s Q) $)
  : $ G -> hoare T P Q $ =
'(ialda @ ialda @
  sylibr (!! terminates_ensuring_val k3) @ iand (syl s_sat_ks anr) @
  iald @ syl5bi ksReachable_hd @ sylbi anrass @
  eord (syl5ibrcom (anwr @ rsyl eqcom ,eqtac) @
    imp @ mpd (syl pimex12 h1) @ eexd @ impd @ exp @ expd @ syl5 (impcom s_ok_E) @
    syl5 terminates_ensuring_can @ syl can_terminate_ensuring_R @
    anwr ksReachable1) @
  imp @ com23 @ eexda @ syl5 s_ok_E @ eimd (imp @ syl5 anl @ syl eal @ anrd h1) @
  syl6 terminates_ensuring_can @ syl terminates_ensuring_R anrr);

theorem hoare_step {k fr}
  (h1: $ G /\ k |=s sn fr *s P ->
         (P. k2 step (ksCfg k) k2 -> setCfg k k2 |=s sn fr *s Q) $)
  : $ G -> hoare T P Q $ =
(focus
  (have 'h3 '(syl s_sat_ks anlr))
  '(hoare_ksStep @ iand _ @ iald @ syl5 anr @ eord _ _)
  (focus '(mpd (anld h1) @ eexda @ syl (iexe ,eqtac) @ iand h3 @ orld @
    syl (iexe ,eqtac) @ iand anr @
    iand (sylibr anass @ sylib (aneq2a setCfgT) @ iand h3 @
      syl s_sat_ks @ imp @ syl eal @ anrd h1) eqidd))
  (focus '(eexd @ impd @ exp @ syl5ibrcom (anwr s_sateq1) @ imp @ syl eal @ anrd h1))
  (focus '(syl absurd @ rsyl (anld h1) @ eex step_no_IO)));

-- @_ local def hoareCfg (k k2: nat) (P Q: set): wff =
-- $ A. ks (ksCfg ks = k -> A. fr (ks |=s sn fr *s P -> setCfg ks k2 |=s sn fr *s Q)) $;

-- theorem hoareCfg_frame_E: $ hoareCfg (ksCfg ks) k2 P Q ->
--   ks |=s R *s P -> setCfg ks k2 |=s R *s Q $ =
-- (named '(ealie @ eimd ksCfgeq @ sylbid ,eqtac @ a1i @
--   syl5bi s_sat_sep_sn @ syl6ibr s_sat_sep_sn @ syl exim @ alimi @ anim2));

-- theorem hoareCfg_E: $ hoareCfg (ksCfg ks) k2 P Q -> ks |=s P -> setCfg ks k2 |=s Q $ =
-- (begin (def h '(bitr (s_sateq2 s_sep_emp1a) s_sat_antop))
--   '(sylib (imeqi ,h ,h) hoareCfg_frame_E));

-- theorem hoareCfg_frame: $ hoareCfg k k2 P Q -> hoareCfg k k2 (R *s P) (R *s Q) $ =
-- (named '(imidm @ alimd @ a2d @ com12 @ sylbird ,(eqtac-with #f) @
--   a1i @ a1d @ iald @ sylib (imeqi (s_sateq2 s_sepass) (s_sateq2 s_sepass)) @
--   hoareCfg_frame_E));

-- theorem hoareCfg_frame_r: $ hoareCfg k k2 P Q -> hoareCfg k k2 (P *s R) (Q *s R) $ =
-- '(sylib (hoareCfgeq eqid eqid s_sepcom s_sepcom) hoareCfg_frame);

-- theorem hoareCfg_weakl: $ P =>*s Q -> hoareCfg k k2 Q R -> hoareCfg k k2 P R $ =
-- (named '(alimd @ imim2d @ alimd @ imim1d @ syl s_weak_sat s_sep_weak2));

-- theorem hoareCfg_weakr: $ Q =>*s R -> hoareCfg k k2 P Q -> hoareCfg k k2 P R $ =
-- (named '(alimd @ imim2d @ alimd @ imim2d @ syl s_weak_sat s_sep_weak2));

-- theorem hoareCfg_exim (P Q: set x):
--   $ A. x (x e. A -> hoareCfg k k2 P Q) ->
--     hoareCfg k k2 (E.s x e. A, P) (E.s x e. A, Q) $ =
-- (named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
--  '(sylbi ralcomb @ alimi @ imim2i @ sylbi ralalcomb @ alimi @
--     sylib (imeqi ,h ,h) @ syl exim @ alimi anim2a));

-- -- theorem hoareCfg_bot1:
-- --   $ (readException k = suc exGPF -> readException k2 = suc exGPF) ->
-- --     hoareCfg k k2 F.s Q $ =
-- -- (named @ focus
-- --   (suffices 'h) '(ialdacom @ iand (syl absurd h) _)
-- --   '(iald @ syl5bi (s_sateq2 s_bot_sep2) @ syl5bi s_sat_bot @ syl absurd h)
-- --   '(imp @ _));

-- theorem hoareCfgT1: $ (k e. Config -> hoareCfg k k2 P Q) <-> hoareCfg k k2 P Q $ =
-- (named '(bitr3 alim1 @ aleqi @ bitr com12b @ imeq2a @ syl biim1a @
--   syl6 (iald @ syl5 s_sat_ks absurd) @ con3d @ syl5 ksCfgT @ bi1d eleq1));

-- theorem hoareCfg_biim1a:
--   $ P =>*s ^s p -> ((p -> hoareCfg k k2 P Q) <-> hoareCfg k k2 P Q) $ =
-- (named '(syl5bbr ralim1 @ aleqd @ imeq2d @ syl5bbr alim1 @
--   aleqd @ syl5bbr impexp @ imeq1d @ syl bian1a @
--   syl6 (sylbi s_sat_lift anr) (syl s_weak_sat s_sepwr)));

-- theorem hoareCfg_I {ks fr} (k2: nat ks)
--   (e: $ k = ksCfg ks -> k3 = k2 $)
--   (h: $ G /\ k = ksCfg ks /\ ks |=s sn fr *s P -> setCfg ks k2 |=s sn fr *s Q $):
--   $ G -> hoareCfg k k3 P Q $ =
-- '(iald @ syl5 eqcom @ exp @ mpbird (rsyl (anwr e) ,eqtac) @ ialda h);

-- theorem hoareCfg_tr:
--   $ hoareCfg k k2 P Q -> hoareCfg k2 k3 Q R -> hoareCfg k k3 P R $ =
-- (named '(com12 @ alimd @ imim2d @ ealie @ sylbid ,eqtac @ a1i @
--   eim ksCfg_setCfg @ al2imi @ imim2d @ imim2i @ bi1i @ s_sateq1 set_setCfg));

-- theorem hoareCfg_id: $ hoareCfg k k P P $ =
-- (named '(ax_gen @ iald @ bi1d @ s_sateq1d @ syl5eqr set_ksCfg setCfgeq2));

-- theorem hoareCfg_id2: $ k2 = k -> P =>*s Q -> hoareCfg k k2 P Q $ =
-- '(exp @ mpbid (hoareCfgeq1d anl) @ anwr @ mpi hoareCfg_id hoareCfg_weakl);

-- theorem hoareCfg_sn_d {q ks fr} (k2: nat ks)
--   (e: $ k = ksCfg ks -> k3 = k2 $)
--   (ha: $ G /\ k = ksCfg ks -> P =>*s sn (sn (p <> v)) $)
--   (h1: $ G /\ k = ksCfg ks /\ ks |=s P -> k2 e. Config $)
--   (h2: $ G /\ k = ksCfg ks /\ ks |=s P ->
--     PageMapping (getMemory (ksCfg ks)) C_ PageMapping (getMemory k2) $)
--   -- (h3: $ G /\ ks e. KernelState -> readException k2 = readException (ksCfg ks) $)
--   (h4: $ G /\ k = ksCfg ks /\ ks |=s P /\ q != p ->
--     read_place (setCfg ks k2) @ q = read_place ks @ q $)
--   (h5: $ G /\ k = ksCfg ks /\ ks |=s P /\
--     read_place ks @ p = v -> read_place (setCfg ks k2) @ p = v2 $)
--   (h6: $ G /\ k = ksCfg ks /\ ks |=s P ->
--     setCfg ks k2 |=s sn fr *s sn (sn (p <> v2)) -> setCfg ks k2 |=s sn fr *s Q $):
--   $ G -> hoareCfg k k3 P Q $ =
-- (focus
--   (have 'H1 '(anim2 @ s_weak_sat s_sepr))
--   '(hoareCfg_I e @ mpd _ @ syl h6 H1)
--   '(s_sat_frame_sn (syl h4 @ anim1 H1) (syl h5 @ anim1 H1)
--       (sylc s_weak_sat (syl s_sep_weak2 @ anwl ha) anr) @
--     rsyl (anim2 @ s_weak_sat s_sepr) (mpbird (syl setCfgT @ anwr s_sat_ks) @
--     iand h1 @ sseld h2 @ syl ksMappingT @ anwr s_sat_ks)));

-- theorem hoareCfg_sn {q ks} (k2: nat ks)
--   (e: $ k = ksCfg ks -> k3 = k2 $)
--   (h1: $ G /\ ks e. KernelState -> k2 e. Config $)
--   (h2: $ G /\ ks e. KernelState -> PageMapping (getMemory (ksCfg ks)) C_ PageMapping (getMemory k2) $)
--   (h3: $ G /\ q != p -> read_place (setCfg ks k2) @ q = read_place ks @ q $)
--   (h4: $ G /\ read_place ks @ p = v -> read_place (setCfg ks k2) @ p = v2 $):
--   $ G -> hoareCfg k k3 (sn (sn (p <> v))) (sn (sn (p <> v2))) $ =
-- (named '(hoareCfg_sn_d e (a1i s_weak_id)
--     (syl h1 @ anim anl s_sat_ks) (syl h2 @ anim anl s_sat_ks)
--     (syl h3 @ anim1 anll) (syl h4 @ anim1 anll) idd));

@_ local def hoareCfgR (k: nat) (R P Q: set): wff =
$ A. ks (ksCfg ks = k -> A. fr (ks |=s sn fr *s P ->
    (P. k2 k2 e. R -> setCfg ks k2 |=s sn fr *s Q))) $;

theorem hoareCfgReq3g (h1: $ P == P2 $) (h2: $ Q == Q2 $)
  (h: $ G -> hoareCfgR k R P Q $): $ G -> hoareCfgR k R P2 Q2 $ =
'(sylib (hoareCfgReq eqid eqsid h1 h2) h);

theorem hoareCfgReq4g (h1: $ P == P2 $) (h2: $ Q == Q2 $)
  (h: $ G -> hoareCfgR k R P2 Q2 $): $ G -> hoareCfgR k R P Q $ =
'(sylibr (hoareCfgReq eqid eqsid h1 h2) h);

theorem hoareCfgR_ab (p: wff k2):
  $ hoareCfgR k {k2 | p} P Q <->
    A. ks (ksCfg ks = k -> A. fr (ks |=s sn fr *s P ->
      (P. k2 p -> setCfg ks k2 |=s sn fr *s Q))) $ =
(named '(aleqi @ imeq2i @ aleqi @ imeq2i @
  cbvpimh (nfel2 nfab1) nfv nfv nfv (syl6bb abid eleq1) @ s_sateq1d setCfgeq2));

-- theorem hoareCfgR_sn: $ hoareCfgR k (sn k2) P Q <-> hoareCfg k k2 P Q $ =
-- (named '(aleqi @ imeq2i @ aleqi @ imeq2i @ bitr (pimeq1i elsn) @ pimeqe ,eqtac));

-- theorem hoareCfgR_sn2: $ hoareCfgR k {x | x = k2} P Q <-> hoareCfg k k2 P Q $ =
-- '(bitr3 (hoareCfgReq2 @ eqab2i elsn) hoareCfgR_sn);

theorem hoareCfgReq2da {ks} (p q: wff k2)
  (h: $ G /\ ksCfg ks = k /\ ks |=s P -> (p <-> q) $):
  $ G -> (hoareCfgR k {k2 | p} P Q <-> hoareCfgR k {k2 | q} P Q) $ =
(named '(aleqd @ imeq2da @ aleqd @ imeq2da @ pimeq1d @ eleq2d @ abeqd @
  syl h @ anim2 @ s_weak_sat s_sepr));

theorem hoareCfgR_frame_E: $ hoareCfgR (ksCfg ks) R P Q ->
  ks |=s F *s P -> (P. k2 k2 e. R -> setCfg ks k2 |=s F *s Q) $ =
(named '(ealie @ eimd ksCfgeq @ sylbid ,eqtac @ a1i @
  syl5bi s_sat_sep_sn @ syl6ibr (pimeq2i s_sat_sep_sn) @
  syl6 rexpim @ syl exim @ alimi anim2));

theorem hoareCfgR_sn_frame_E: $ hoareCfgR (ksCfg ks) (sn k2) P Q ->
  ks |=s R *s P -> setCfg ks k2 |=s R *s Q $ =
(named '(syl6ib (bitr (pimeq1i elsn) (pimeqe @ s_sateq1d setCfgeq2)) hoareCfgR_frame_E));

theorem hoareCfgR_frame_E_ab (p: wff k2): $ hoareCfgR (ksCfg ks) {k2 | p} P Q ->
  ks |=s F *s P -> (P. k2 p -> setCfg ks k2 |=s F *s Q) $ =
(named '(syl6ib (cbvpimh (nfel2 nfab1) nfv nfv nfv (syl6bb abid eleq1) @
  s_sateq1d setCfgeq2) hoareCfgR_frame_E));

theorem hoareCfgR_E_ex (p: wff k2)
  (h: $ G -> hoareCfgR k {k2 | p} P Q $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> E. k2 p $ =
'(syl pimex @ sylc hoareCfgR_frame_E_ab (mpbird (hoareCfgReq1d anlr) (anwll h)) @
  sylibr s_sat_sep_emp1 anr);

theorem hoareCfgR_frame: $ hoareCfgR k R P Q -> hoareCfgR k R (F *s P) (F *s Q) $ =
(named '(imidm @ alimd @ a2d @ com12 @ sylbird ,(eqtac-with #f) @
  a1i @ a1d @ iald @ sylib (imeqi (s_sateq2 s_sepass) @ pimeq2i (s_sateq2 s_sepass)) @
  hoareCfgR_frame_E));

theorem hoareCfgR_frame_r: $ hoareCfgR k R P Q -> hoareCfgR k R (P *s F) (Q *s F) $ =
'(sylib (hoareCfgReq eqid eqsid s_sepcom s_sepcom) hoareCfgR_frame);

theorem hoareCfgR_exim (P Q: set x):
  $ A. x (x e. A -> hoareCfgR k R P Q) ->
    hoareCfgR k R (E.s x e. A, P) (E.s x e. A, Q) $ =
(named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
 '(sylbi ralcomb @ alimi @ imim2i @ sylbi ralalcomb @ alimi @
    sylib (imeqi ,h @ pimeq2i ,h) @ syl6 rexpim @ syl exim @ alimi anim2a));

theorem hoareCfgR_eexb (P: set x):
  $ A. x (x e. A -> hoareCfgR k R P Q) <-> hoareCfgR k R (E.s x e. A, P) Q $ =
(named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
 '(bitr ralcomb @ aleqi @ imeq2i @ bitr ralalcomb @ aleqi @
    bitr3 erexb (imeq1i ,h)));

theorem hoareCfgR_iex (Q: set x):
  $ E. x (x e. A /\ hoareCfgR k R P Q) -> hoareCfgR k R P (E.s x e. A, Q) $ =
(named (def h '(bitr3 s_sat_ex @ s_sateq2 s_exsep1))
 '(rsyl rexral @ alimi @ imim2i @ rsyl rexral @ alimi @ imim2i @
   sylib (pimeq2i ,h) rexpim1));

theorem hoareCfgR_iexe (Q: set x) (e: $ G /\ x = a -> Q == Q2 $)
  (h1: $ G -> a e. A $)
  (h2: $ G -> hoareCfgR k R P Q2 $): $ G -> hoareCfgR k R P (E.s x e. A, Q) $ =
'(syl hoareCfgR_iex @ iexde @ iand (mpbird (eleq1d anr) (anwl h1)) @
  mpbird (hoareCfgReq4d e) (anwl h2));

theorem hoareCfgR_Td {ks} (h: $ G /\ ksCfg ks = k /\ ks |=s P -> hoareCfgR k R P Q $):
  $ G -> hoareCfgR k R P Q $ =
(named '(ialda @ ialda @ sylc hoareCfgR_frame_E
  (mpbird (hoareCfgReq1d anlr) @ syl h @ anim2 @ s_weak_sat s_sepr) anr));

theorem hoareCfgR_T1: $ (k e. Config -> hoareCfgR k R P Q) <-> hoareCfgR k R P Q $ =
(named '(ibii (hoareCfgR_Td @ mpd (mpbid (eleq1d anlr) @ anwr @ syl ksCfgT s_sat_ks) anll) ax_1));

-- theorem hoareCfg_Td {ks} (h: $ G /\ ksCfg ks = k /\ ks |=s P -> hoareCfg k k2 P Q $):
--   $ G -> hoareCfg k k2 P Q $ =
-- '(sylib hoareCfgR_sn @ hoareCfgR_Td @ sylibr hoareCfgR_sn h);

theorem hoareCfgR_weakl: $ P =>*s Q -> hoareCfgR k K Q R -> hoareCfgR k K P R $ =
(named '(alimd @ imim2d @ alimd @ imim1d @ syl s_weak_sat s_sep_weak2));

theorem hoareCfgR_weakr: $ Q =>*s R -> hoareCfgR k K P Q -> hoareCfgR k K P R $ =
(named '(alimd @ imim2d @ alimd @ imim2d @ pimim2d @ syl s_weak_sat s_sep_weak2));

theorem hoareCfgR_id: $ hoareCfgR k (sn k) P P $ =
(named '(ax_gen @ iald @ bi1d @ syl6bbr (bitr (pimeq1i elsn) (pimeqe ,eqtac)) @
  s_sateq1d @ syl5eqr set_ksCfg setCfgeq2));

theorem hoareCfgR_id2: $ R == sn k -> P =>*s Q -> hoareCfgR k R P Q $ =
'(exp @ mpbird (hoareCfgReq2d anl) @ anwr @ mpi hoareCfgR_id hoareCfgR_weakl);

theorem hoareCfgR_biim1a:
  $ P =>*s ^s p -> ((p -> hoareCfgR k R P Q) <-> hoareCfgR k R P Q) $ =
(named '(syl5bbr ralim1 @ aleqd @ imeq2d @ syl5bbr alim1 @
  aleqd @ syl5bbr impexp @ imeq1d @ syl bian1a @
  syl6 (sylbi s_sat_lift anr) (syl s_weak_sat s_sepwr)));

theorem hoareCfgR_impexp:
  $ hoareCfgR k R (^s p /\s P) Q <-> (p -> hoareCfgR k R P Q) $ =
(named '(bitr (raleqi @ bitr (aleqi @
  bitr (imeq1i @ bitr (s_sateq2 s_sep_anlift2) s_sat_anlift1) impexp) alim1) ralim1));

theorem hoareCfgR_animd (h1: $ G /\ p -> q $) (h2: $ G /\ p -> hoareCfgR k R P Q $):
  $ G -> hoareCfgR k R (^s p /\s P) (^s q /\s Q) $ =
'(sylibr hoareCfgR_impexp @ exp @
  sylc hoareCfgR_weakr (sylib s_weak_antop1 @
    syl ss_s_weak @ sylibr (sseq1 s_ancom) @
    syl s_anim1 @ sylibr s_lift_ss @ a1d h1) h2);

theorem hoareCfgR_pim (p: wff k2) (q: wff k2 k3) (r: wff k3)
  (h1: $ G -> hoareCfgR (ksCfg k) {k2 | p} P Q $)
  (h2: $ G /\ p /\ setCfg k k2 |=s F *s Q -> (P. k3 q -> r) $):
  $ G /\ k |=s F *s P -> (P. k3 E. k2 (p /\ q) -> r) $ =
'(sylc pimtr (sylibr (pimeq2a @ ax_gen bian1) @ imp @ syl hoareCfgR_frame_E_ab h1) @
  iald @ anwl @ exp @ sylbir anass h2);

theorem hoareCfgR_tr (p: wff k2) (q: wff k2 k3)
  (h1: $ G -> hoareCfgR k {k2 | p} P Q $)
  (h2: $ G /\ p -> hoareCfgR k2 {k3 | q} Q R $):
  $ G -> hoareCfgR k {k3 | E. k2 (p /\ q)} P R $ =
(named '(sylibr hoareCfgR_ab @ ialda @ ialda @
  hoareCfgR_pim (mpbird (hoareCfgReq1d anr) @ anwl h1) @
  sylib (pimeq2i @ s_sateq1 set_setCfg) @ imp @ syl hoareCfgR_frame_E_ab @
  sylibr (hoareCfgReq1 ksCfg_setCfg) @ rsyl (anim1 anl) h2));

theorem hoareCfgR_tr1
  (h1: $ G -> hoareCfgR k (sn k2) P Q $)
  (h2: $ G -> hoareCfgR k2 T Q R $):
  $ G -> hoareCfgR k T P R $ =
(named '(sylib (hoareCfgReq2 @ eqab1i @ exeqe ,eqtac) @
  hoareCfgR_tr (sylib (hoareCfgReq2 @ eqab2i elsn) h1) @
  mpbird (hoareCfgReqd anr (a1i abid2) eqsidd eqsidd) @ anwl h2));

theorem hoareCfgR_step {k} (h: $ G -> hoareCfgR k {k2 | step k k2} P Q $):
  $ G -> hoare T P Q $ =
(named '(hoare_step @ imp @ syl hoareCfgR_frame_E_ab @
  rsyl (!! iald k h) (eale ,eqtac)));

theorem hoareCfgR_sn_d {q ks fr} (k2: nat ks)
  (e: $ k = ksCfg ks -> k3 = k2 $)
  (ha: $ G /\ k = ksCfg ks -> P =>*s sn (sn (p <> v)) $)
  (h1: $ G /\ k = ksCfg ks /\ ks |=s P -> k2 e. Config $)
  (h2: $ G /\ k = ksCfg ks /\ ks |=s P ->
    PageMapping (getMemory (ksCfg ks)) C_ PageMapping (getMemory k2) $)
  -- (h3: $ G /\ ks e. KernelState -> readException k2 = readException (ksCfg ks) $)
  (h4: $ G /\ k = ksCfg ks /\ ks |=s P /\ q != p ->
    read_place (setCfg ks k2) @ q = read_place ks @ q $)
  (h5: $ G /\ k = ksCfg ks /\ ks |=s P /\
    read_place ks @ p = v -> read_place (setCfg ks k2) @ p = v2 $)
  (h6: $ G /\ k = ksCfg ks /\ ks |=s P ->
    setCfg ks k2 |=s sn fr *s sn (sn (p <> v2)) -> setCfg ks k2 |=s sn fr *s Q $):
  $ G -> hoareCfgR k (sn k3) P Q $ =
(focus
  (have 'H1 '(anim2 @ s_weak_sat s_sepr))
  '(iald @ syl5 eqcom @ exp @ ialda @
    mpbird (pimeq1d @ syl5bb elsn @ eqeq2d @ syl e anlr) @
    sylibr (pimeqe ,eqtac) @ mpd _ @ syl h6 H1)
  '(s_sat_frame_sn (syl h4 @ anim1 H1) (syl h5 @ anim1 H1)
      (sylc s_weak_sat (syl s_sep_weak2 @ anwl ha) anr) @
    rsyl (anim2 @ s_weak_sat s_sepr) (mpbird (syl setCfgT @ anwr s_sat_ks) @
    iand h1 @ sseld h2 @ syl ksMappingT @ anwr s_sat_ks)));

theorem hoareCfgR_sn {q ks} (k2: nat ks)
  (e: $ k = ksCfg ks -> k3 = k2 $)
  (h1: $ G /\ ks e. KernelState -> k2 e. Config $)
  (h2: $ G /\ ks e. KernelState -> PageMapping (getMemory (ksCfg ks)) C_ PageMapping (getMemory k2) $)
  (h3: $ G /\ q != p -> read_place (setCfg ks k2) @ q = read_place ks @ q $)
  (h4: $ G /\ read_place ks @ p = v -> read_place (setCfg ks k2) @ p = v2 $):
  $ G -> hoareCfgR k (sn k3) (sn (sn (p <> v))) (sn (sn (p <> v2))) $ =
(named '(hoareCfgR_sn_d e (a1i s_weak_id)
    (syl h1 @ anim anl s_sat_ks) (syl h2 @ anim anl s_sat_ks)
    (syl h3 @ anim1 anll) (syl h4 @ anim1 anll) idd));

--| The primitive memory heaplet: `s_mem1 p a v` says that
--| address `a` is mapped with permission `p`,
--| and if the data at `a` is readable then the value is `v`.
@_ local def s_mem1 (p a v): set =
$ ^s (a e. u64 /\ v e. u8 /\ p e. Prot) /\s
    sn (sn (X86P_Mem a <> ((p <> v) <> suc p))) $;

theorem el_s_mem1: $ h e. s_mem1 p a v <->
  a e. u64 /\ v e. u8 /\ p e. Prot /\
  h = sn (X86P_Mem a <> ((p <> v) <> suc p)) $ =
'(bitr el_s_an @ bitr (aneq el_s_lift elsn) @
  aneq1a @ syl bian1 @ mpbiri isfsn @ isfeqd nseq);

theorem s_mem1_subsn: $ subsn (s_mem1 p a v) $ = '(subsnss s_anr subsnsn);
theorem s_mem1_sstop: $ s_mem1 p a v C_ T.s $ = '(sstr s_anl s_lift_sstop);

theorem s_mem1_getMemory:
  $ k |=s s_mem1 p a v ->
    getMemory (ksCfg k) @ a = p <> v /\
    ksMapping k @ a = suc p $ =
(named '(eex @ imp @ sylbi el_s_mem1 @ anwr @
  sylbid heap_sateq2 @ a1i @ sylbi heap_sat_sn @
  sylib prth @ sylib (eqeq1 read_place_Mem) anr));

theorem s_mem1_readMemory1:
  $ k |=s s_mem1 p a v /\ ps C_ p ->
    readMemory1 ps (getMemory (ksCfg k)) a v $ =
'(iand (iand (syl getMemoryT @ syl ksCfgT @ anwl s_sat_ks) @
    anwl @ sylbi s_sat_anlift1 an3l) @
  syl (iexe ,eqtac) @ anim1 @ anld s_mem1_getMemory);

theorem s_mem1_hoareCfg
  (h1: $ G -> v e. u8 $)
  (h2: $ G -> setMem1 (getMemory k) a v = m2 <> 0 $):
  $ G -> hoareCfgR k (sn (setMemory k m2)) (s_mem1 p a w)
    (^s (PROT_READ + PROT_WRITE C_ p) /\s s_mem1 p a v) $ =
(named @ focus
  (def G $ G /\ k = ksCfg ks /\ ks |=s s_mem1 p a w $)
  (have 'H1 $ ,G -> a e. u64 /\ w e. u8 /\ p e. Prot $
    '(anld @ sylib s_sat_anlift1 anr))
  (have 'H1a $ ,G -> a e. u64 $ '(rsyl H1 anll))
  (have 'H2 $ ,G -> PROT_READ + PROT_WRITE C_ fst (getMemory k @ a) $
    '(anwll @ mpi peano1 @ con1d @ exp @ anrd @
      sylib prth @ eqtr3d (anwr ifneg) (anwl h2)))
  (have 'H3 $ ,G -> PROT_READ + PROT_WRITE C_ p $
    '(mpbid (sseq2d @ nseqd @ syl6eq fstpr @ fsteqd @
        eqtrd (appneq1d @ getMemoryeqd anlr) @ anwr @ anld s_mem1_getMemory) H2))
  (have 'H4 $ ,G -> ksCfg ks e. Config $ '(syl ksCfgT @ anwr s_sat_ks))
  (have 'H5 $ ,G -> k e. Config $ '(mpbird (eleq1d anlr) H4))
  (have 'H6 $ ,G ->
      fst (setMem1 (getMemory (ksCfg ks)) a v) ==
      write (getMemory (ksCfg ks)) a (fst (getMemory (ksCfg ks) @ a) <> v) $
    '(syl6eqsr (mpbi eqlower @ writefin finns) @
      nseqd @ syl6eq fstpr @ fsteqd @ syl ifpos @
      mpbid (sseq2d @ nseqd @ fsteqd @ appneq1d @ getMemoryeqd anlr) H2))
  '(mpbid (hoareCfgReq2d @ nseqd @ sneqd @ setMemoryeq2d @ syl6eq fstpr @ fsteqd h2) @
    hoareCfgR_sn_d ,eqtac _ _ _ _ _ _)
  (focus '(a1i @ ss_s_weak s_anr))
  (focus '(sylan setMemoryT H4 @ syl xpfst @ sylan setMem1_T
    (iand (syl getMemoryT H4) H1a) @ anwll h1))
  (focus
    '(sylibr _ @ sylan setMem1PM (iand (syl getMemoryT H4) H1a) @ anwll h1)
    '(sseq2 @ PageMappingeq get_setMemory))
  (focus
    '(imp @ casesd (eexd _) @ a1i @ a1d read_place_setMemory_ne)
    '(syl5ibrcom {,eqtac : $ q = _ -> _ $} @ syl5bi (noteq @ bitr b1can b1can) @
      exp @ eqtr4g read_place_setMemory_eq read_place_Mem @ preq1d @
      eqtrd (appeq1d @ anwl H6) @ anwr writeNe))
  (focus
    '(syl5eq read_place_setMemory_eq @
      sylan (preqd _ anlr) (sylib prth @ syl5eqr read_place_Mem anr) @ anwl H6)
    '(eqtrd (appeq1d anr) @ syl5eq writeEq @ preq1d @ syl6eq fstpr @ fsteqd anll))
  (focus
    '(bi2d @ s_sateq2d @ s_sepeq2d @ eqstrd (syl (s_bian1 s_mem1_sstop) H3) @
      sylan (s_bian1 @ mpbir s_sn_sstop isfsn) (iand H1a @ anwll h1) (anrd H1))));

--| The primitive memory heaplet: `s_pto a v` or `a >->m v` says that
--| address `a` is mapped, and if the data at `a` is readable then the value is `v`.
--| It does not imply readability of the memory since if the data is not readable
--| we can conclude anything (because reading will cause a crash).
@_ local def s_pto (a v): set =
$ E.s p e. Prot, (^s (PROT_READ C_ p) /\s s_mem1 p a v) $;
infixl s_pto: $>->m$ prec 80;

theorem el_s_pto: $ h e. a >->m v <-> a e. u64 /\ v e. u8 /\
  E. p (p e. Prot /\ PROT_READ C_ p /\
    h = sn (X86P_Mem a <> ((p <> v) <> suc p))) $ =
'(bitr4 el_s_ex @ bitr3 exan1 @ exeqi @ bitr anlass @ bitr4 anass @
  aneq2a @ syl5bb el_s_an @ syl5bb (aneq1a @
    syl5bb el_s_lift @ syl bian1 @ el_sstop s_mem1_sstop) @
  aneq2d @ syl5bb el_s_mem1 @ aneq1d bian2);

theorem s_pto_sstop: $ a >->m v C_ T.s $ = (named '(s_eex @ sstr s_anl s_lift_sstop));

theorem s_pto_readMemory1:
  $ k |=s a >->m v ->
    readMemory1 PROT_READ (getMemory (ksCfg k)) a v $ =
(named '(sylbi s_sat_ex @ eex @ anwr @ sylbi s_sat_anlift1 @
  syl s_mem1_readMemory1 ancom));

--| The primitive memory heaplet: `s_mem P a v` says that the
--| list of bytes `v` is at address `a`, where every byte has permission from the set `P`
--| (different bytes may have different permissions).
@_ local def s_mem (P a v): set =
$ ^s (a + len v e. u64 /\ v e. List u8) /\s
  |*|s i e. upto (len v), E.s p e. P @' (a + i), s_mem1 p (a + i) (nth i v - 1) $;

theorem s_mem_sstop: $ s_mem P a v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));
theorem s_mem_T: $ k |=s s_mem P a v -> a + len v e. u64 /\ v e. List u8 $ =
(named '(eex @ anwl @ sylbi el_s_an @ anwl @ sylbi el_s_lift anr));

theorem s_mem_ss: $ A. i (i < len v -> P @' (a + i) C_ Q @' (a + i)) -> s_mem P a v C_ s_mem Q a v $ =
(named '(syl s_anim2 @ syl s_Sep_ss @ iald @ syl5bi elupto @
  rsyl (eale ,eqtac) @ imim2i s_exim1));

theorem s_mem_0: $ s_mem P a 0 == ^e (a e. u64) $ =
(named '(s_aneq (s_lifteq @ bitr (bian2 elList0) @ eleq1 @ eqtr (addeq2 len0) add02) @
  eqstr (s_Sepeq1 @ nseq @ eqtr (uptoeq len0) upto0) s_Sep_0));

theorem s_mem_S: $ s_mem P a (b : v) == E.s p e. P @' a, s_mem1 p a b *s s_mem P (suc a) v $ =
(named '(eqstr4
  (s_aneq
    (s_lifteq @ bitr (aneq (eleq1 @ eqtr4 (addeq2 lenS) addSass) elListS) anlass) @
    eqstr (s_Sepeq1 @ nseq @ uptoeq lenS) @
    trud @ s_Sep_uptoS
      (anwr @ s_exeqd (rappeq2d @ syl6eq add02 addeq2) @
        s_mem1eqd eqidd (syl6eq add02 addeq2) @
        syl6eq sucsub1 @ subeq1d @ syl6eq nthZ @ ntheq1)
      (anwr @ s_exeqd (rappeq2d @ syl6eqr addSass addeq2) @
        s_mem1eqd eqidd (syl6eqr addSass addeq2) @
        subeq1d @ syl6eq nthS ntheq1) @
    a1i @ s_eex s_mem1_sstop) @
  eqstr3 (s_sepeq1 @ mpbi s_bian1a @ s_eex @ s_anwl @ mpbir s_lift_ss anlr) @
  s_sep_anlift));

theorem s_mem_A: $ len v = n -> s_mem P a (v ++ w) == s_mem P a v *s s_mem P (a + n) w $ =
(named @ focus
  (have 'H '(eqtrd (addeq2d anr) @ syl5eqr addass @ addeq1d @ addeq2d anl))
  '(syl6eqsr s_sep_anlift @
    eqstrd (s_aneq2d @
      syl5eqs (s_Sepeq1 @ nseq @ uptoeq appendlen) @
      s_Sep_uptoA @ s_exeqd (rappeq2d H) @ s_mem1eqd eqidd H @
      subeq1d @ syl6eq appendnth2_ (ntheq1d anr)) @
    s_aneqd (s_lifteqd @ syl6bb an4 @ aneqd
      (syl5bb (eleq1 @ eqtr4 (addeq2 appendlen) addass) @
        syl5bbr (bian1a @ u64le1 leaddid1) @ aneq2d @ eleq1d @ addeq1d addeq2)
      (a1i appendT)) @
    s_sepeq1d @ s_Sepeq2da @ s_exeq2d @ s_mem1eq3d @
    subeq1d @ syl appendnth1 @ sylib elupto anr));

theorem s_mem_readMemory {y} (G: wff x)
  (h1: $ G -> ps e. Prot $)
  (h2: $ G -> k |=s s_mem P a v $)
  (hp: $ G -> A. x (y <> x e. P -> ps C_ x) $):
  $ G -> readMemory ps (getMemory (ksCfg k)) a v $ =
(named @ focus
  '(mpd h2 @ syl (!! eale b ,(eqtac-gen 'a)) ,(induct '(listindd) 'v _ _))
  '(iald @ syl5bi (s_sateq2 s_mem_0) @ syl5bi s_sat_anlift1 @
    exp @ sylibr readMemory0 @
    iand (iand (anwl h1) @ syl getMemoryT @ syl ksCfgT @ rsyl anrr s_sat_ks) anrl)
  '(sylibr (cbval ,eqtac) @ iald @ syl5bi (s_sateq2 s_mem_S) @
    syl5 s_sat_sep @ syl6ibr readMemoryS @ animd _ _)
  (focus
    '(syl5bi s_sat_ex @ rsyl (anwl hp) @
      sylibr erexb @ alimi @ syl5bi elrapp @ imim2i @ com12 @ exp s_mem1_readMemory1))
  '(imp @ syl5 (eale ,eqtac) @ a2d @ exp @ bi2d @ readMemoryeq3d @
    syl add64S_eqid @ syl (u64le1 leaddid1) @ anld @ anwr s_mem_T));

theorem s_mem_hoareCfg {p x}
  (h1: $ G -> v e. List u8 $)
  (h2: $ G -> len w = len v $)
  (h3: $ G /\ PROT_READ + PROT_WRITE C_ p -> x <> p e. P -> x <> p e. Q $)
  (h4: $ G -> setMem (getMemory k) a v = m2 <> 0 $):
  $ G -> hoareCfgR k (sn (setMemory k m2)) (s_mem P a w) (s_mem Q a v) $ =
(named @ focus
  (def (f x y) '(syl (eale ,(eqtac-gen x)) ,y))
  '(mpd (iand (iand h1 h2) h4) ,(f 'a @ f 'w @ f 'm2 @ f 'k @ induct '(listindd) 'v _ _))
  (def (g x) '(sylib hoareCfgR_T1 @ exp @
    sylib (hoareCfgR_biim1a @ ss_s_weak s_anl) @
    syl5 anl @ exp ,x))
  (focus
    '(iald @ iald @ iald @ iald @ expcom ,(g _))
    '(sylc hoareCfgR_id2 (nseqd @ sneqd @ syl6eq set_getMemory @ setMemoryeq2d @ anld @
        sylib prth @ eqtr3d an3lr @ sylan setMem0 (syl getMemoryT anlr) (anwr @ u64le1 leaddid1)) @
      mpbiri s_weak_id @ s_weakeq1d @ syl6eqs (eqstr4 s_mem_0 s_mem_0) @
      s_memeq3d @ sylib leneq0 @ syl6eq len0 an4lr))
  '(sylibr (cbval @ cbvald @ cbvald @ cbvald ,eqtac) @ iald @ iald @ !! iald l @ ialda ,(g _))
  '(mpd (sylib excons @ sylib (noteq leneq0) @ syl sucne0 @ syl6eq lenS @ rsyl anllr anlr) @
    eexd @ eexda @ sylbi (bian21i @ bian21i anrass) @ imp @ mpbird (anwr ,eqtac) @
    sylbid (aneqd (a1i @ aneq elListS @ bitr (eqeq lenS lenS) peano2) @
      eqeq1d @ sylan (mpi (eqcom fstsnd) setMemS)
        (syl getMemoryT anllr) (rsyl anlr @ u64le1 leaddid1)) _)
  (have 'H1
    '(syl contra @ com12 @ sylbid (eqeq1d ifneg) @ a1i @ sylbi prth anr))
  '(syl5 (anim2 @ iand H1 @ eqtr3d (syl ifpos H1) id) @ exp @
    sylibr (hoareCfgReq eqid (nseq @ sneq @ eqcom set_setMemory) s_mem_S s_mem_S) @
    hoareCfgR_tr1 (syl hoareCfgR_frame_r _) (syl hoareCfgR_frame _))
  (focus
    '(sylc hoareCfgR_weakr _ @ syl hoareCfgR_exim @ ialda @
      rsyl anlr @ s_mem1_hoareCfg an3l @ syl5eqr fstsnd @ preq2d anrl)
    '(anw5l @ syl ss_s_weak @ iald @ sylibr (imeqi el_s_ex el_s_ex) @
      eximd @ syl5bi (aneq2i @ el_s_anlift1 s_mem1_sstop) @
      syl5bir anass @ anim1d @ impd @ com23 @ exp @ sylibr (imeqi elrapp elrapp) h3))
  (focus
    '(mpd (iand (anwr @ iand anllr anlr) @ eqtrd _ @ anwr anrr) @
      rsyl an4lr @ ealie @ ealde @ ealde @ ealde @ bi1d ,eqtac)
    '(setMemeqd (a1i get_setMemory) (eqcomd @ syl add64S_eqid _) eqidd)
    '(sylc u64le1 (sylib (leeq1 add12) @ sylib leadd2 @
        mpbiri le11S @ leeq2d @ syl6eq lenS @ leneqd anlr) anllr)));

--| A block of readable or read/write memory: `a >=> v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_block (a v): set = $ s_mem (S\ x, {p | PROT_READ C_ p}) a v $;
infixl s_block: $>=>$ prec 80;

theorem s_block_sstop: $ a >=> v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));
theorem s_block_T: $ k |=s a >=> v -> a + len v e. u64 /\ v e. List u8 $ = (named 's_mem_T);
theorem s_block_0: $ a >=> 0 == ^e (a e. u64) $ = (named 's_mem_0);
theorem s_block_A: $ len v = n -> a >=> v ++ w == a >=> v *s (a + n) >=> w $ = (named 's_mem_A);

theorem s_readMemory:
  $ k |=s a >=> v -> readMemory PROT_READ (getMemory (ksCfg k)) a v $ =
(named '(s_mem_readMemory (a1i PROT_READ_T) id @
  a1i @ ax_gen @ bi1 @ elsabe @ elabed ,eqtac));

theorem s_readMem: $ k |=s a >=> v -> readMem (ksCfg k) a v $ =
'(iand (syl ksCfgT s_sat_ks) s_readMemory);
theorem s_readMem_d (h: $ G -> P =>*s a >=> v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readMem k a v $ =
'(mpbid (readMemeq1d anlr) @ syl s_readMem @ imp @ anwl @ syl s_weak_sat h);

--| A block of executable code: `a >=>c v` says that the
--| list of bytes `v` is at address `a`.
@_ local def s_code (a v): set = $ s_mem (S\ x, {p | PROT_READ + PROT_EXEC C_ p}) a v $;
infixl s_code: $>=>c$ prec 80;

theorem s_code_sstop: $ a >=>c v C_ T.s $ = (named '(sstr s_anl s_lift_sstop));
theorem s_code_T: $ k |=s a >=>c v -> a + len v e. u64 /\ v e. List u8 $ = (named 's_mem_T);
theorem s_code_0: $ a >=>c 0 == ^e (a e. u64) $ = (named 's_mem_0);
theorem s_code_A: $ len v = n -> a >=>c v ++ w == a >=>c v *s (a + n) >=>c w $ = (named 's_mem_A);
theorem s_code_weakl: $ a >=>c v ++ w =>*s a >=>c v $ =
'(mpbir (s_weakeq1 @ s_code_A eqid) s_sepl);
theorem s_code_weakr: $ len v = n -> a >=>c v ++ w =>*s (a + n) >=>c w $ =
'(mpbiri s_sepr (s_weakeq1d s_code_A));

theorem s_readMemory_RX:
  $ k |=s a >=>c v ->
    readMemory (PROT_READ + PROT_EXEC) (getMemory (ksCfg k)) a v $ =
(named '(s_mem_readMemory (a1i PROT_RX_T) id @
  a1i @ ax_gen @ bi1 @ elsabe @ elabed ,eqtac));

theorem s_readMemX: $ k |=s a >=>c v -> readMemX (ksCfg k) a v $ =
'(iand (syl ksCfgT s_sat_ks) s_readMemory_RX);
theorem s_readMemX_d (h: $ G -> P =>*s a >=>c v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readMemX k a v $ =
'(mpbid (readMemXeq1d anlr) @ syl s_readMemX @ sylc s_weak_sat (anwll h) anr);

theorem s_code_assembled (h: $ assembled c s x y $):
  $ text_start >=>c c =>*s x >=>c s /\ x + len s = y $ =
(named @ focus
  '(iani (eex (mpbird (s_weakeq2d @ s_codeeq1d anl) _) @ anri h) @ eqcom @ anlr h)
  '(anwr @ eex @ eex @ mpbird (s_weakeq1d @ s_codeeq2d anl) @
    syl (mpi s_code_weakl s_weak_tr) (anwr s_code_weakr)));

--| A block of uninitialized memory: `a >=>. n` says that there are
--| `n` free bytes at address `a`.
--| The bytes can be written to but not read until first write.
@_ local def s_block0 (a n): set = $ E.s v e. Array u8 n, s_mem _V a v $;
infixl s_block0: $>=>.$ prec 80;

theorem s_block0_sstop: $ a >=>. n C_ T.s $ = (named '(s_eex s_mem_sstop));
theorem s_block0_T: $ k |=s a >=>. n -> a + n e. u64 $ =
(named '(sylbi s_sat_ex @ eex @
  mpbid (eleq1d @ addeq2d @ anwl elArraylen) @ anld @ anwr s_mem_T));
theorem s_block0_0: $ a >=>. 0 == ^e (a e. u64) $ =
(named '(eqstr (s_exeq1 @ ax_gen @ bitr4 elArray02 elsn) @
  trud @ s_exeqe @ syl6eqs s_mem_0 ,eqtac));

theorem s_block0_A_lem:
  $ E.s z e. Array u8 (m + n), s_mem P a z ==
    E.s x e. Array u8 m, s_mem P a x *s
    E.s y e. Array u8 n, s_mem P (a + m) y $ =
(focus
  '(eqstr (ssasym _ _) @ eqstr (s_exeq2i s_exsep1) s_exsep2)
  (focus
    (have 'H '(syl takeArray @ ian leaddid1))
    '(mpbi s_eexb @ ax_gen @
      syl s_iex @ sylan (iexe ,eqtac) H @
      syl s_iex @ sylan (iexe ,eqtac) dropArray @
      sylib (sseq1 @ s_memeq3 takedrop) @
      syl eqss @ syl s_mem_A @ rsyl H elArraylen))
  (focus
    '(mpbi s_eexb @ ax_gen @ sylib s_eexb @ ialda @
      syl s_iex @ sylan (iexe ,eqtac) (imp appendArray) @
      syl eqssr @ syl s_mem_A @ anwl elArraylen)));

theorem s_block0_A: $ a >=>. (m + n) == a >=>. m *s (a + m) >=>. n $ = (named 's_block0_A_lem);

theorem s_mem_block0: $ s_mem P a v C_ a >=>. len v $ =
(named '(mpbi (sseq1 @ mpbi s_bian1a s_anl) @ s_imp @
  syl s_iex @ iexde @
  iand (mpbird (eleq1d anr) @ sylibr elArray @ iand anlr eqidd) @
  mpbiri (s_mem_ss @ ax_gen @ a1i @ rappss ssv2) ,eqtac));

theorem s_block_block0: $ a >=> v C_ a >=>. len v $ = (named 's_mem_block0);

--| A no-access memory heaplet: `s_blockZ a n` says that the memory at
--| `a ... a+n` is mapped but read-protected and will cause a fault if accessed.
@_ local def s_blockZ (a n): set = $ E.s v e. Array u8 n, s_mem (sn 0) a v $;

theorem s_blockZ_sstop: $ s_blockZ a n C_ T.s $ = (named '(s_eex s_mem_sstop));
theorem s_blockZ_T: $ k |=s s_blockZ a n -> a + n e. u64 $ =
(named '(sylbi s_sat_ex @ eex @
  mpbid (eleq1d @ addeq2d @ anwl elArraylen) @ anld @ anwr s_mem_T));
theorem s_blockZ_block0: $ s_blockZ a n C_ a >=>. n $ =
(named '(s_eximi @ a1i @ s_mem_ss @ ax_gen @ a1i @ rappss ssv2));
theorem s_blockZ_0: $ s_blockZ a 0 == ^e (a e. u64) $ =
(named '(eqstr (s_exeq1 @ ax_gen @ bitr4 elArray02 elsn) @
  trud @ s_exeqe @ syl6eqs s_mem_0 ,eqtac));
theorem s_blockZ_A: $ s_blockZ a (m + n) ==
  s_blockZ a m *s s_blockZ (a + m) n $ = (named 's_block0_A_lem);

--| `r >->r v` means that register `r e. Regs` contains value `v e. u64`.
@_ local def s_reg (r v): set =
$ ^s (r e. Regs /\ v e. u64) /\s sn (sn (X86P_Reg r <> v)) $;
infixl s_reg: $>->r$ prec 80;

theorem s_reg_sstop: $ r >->r v C_ T.s $ = '(sstr s_anl s_lift_sstop);
theorem s_reg_T: $ k |=s r >->r v -> r e. Regs /\ v e. u64 $ = '(sylbi s_sat_anlift1 anl);
theorem s_reg_subsn: $ subsn (r >->r v) $ = '(subsnss s_anr subsnsn);

theorem s_readReg: $ k |=s r >->r v -> readReg (ksCfg k) r = v $ =
'(syl5eqr read_place_Reg @ sylbi s_sat_anlift1 @ anwr @
  sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_readReg_d (h: $ G -> P =>*s r >->r v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readReg k r = v $ =
'(eqtr3d (readRegeq1d anlr) @ syl s_readReg @ imp @ anwl @ syl s_weak_sat h);

theorem hoareCfg_setReg:
  $ v e. u64 -> hoareCfgR k (sn (setReg k r v)) (r >->r w) (r >->r v) $ =
(named @ focus
  (have 'H '(anld @ sylib s_sat_anlift1 anr))
  '(hoareCfgR_sn_d ,eqtac (a1i @ ss_s_weak s_anr)
    (sylan setRegT (iand (anwr @ syl ksCfgT s_sat_ks) @ anld H) anll)
    (a1i @ eqssr @ PageMappingeq getMemory_setReg)
    (anwr read_place_setReg_ne)
    (a1i @ eqtr read_place_Reg @ eqtr (readRegeq1 ksCfg_setCfg) read_setReg)
    (bi2d @ s_sateq2d @ s_sepeq2d @ sylan (s_bian1 @ mpbir s_sn_sstop isfsn)
      (anld H) anll)));

--| `flags>-> fl` means that the flags have value `fl`.
@_ local def s_flags (v): set = $ ^s (v e. Flags) /\s sn (sn (X86P_Flags <> v)) $;
prefix s_flags: $flags>->$ prec 80;

theorem s_flags_sstop: $ flags>-> fl C_ T.s $ = '(sstr s_anl s_lift_sstop);
theorem s_flags_T: $ k |=s flags>-> fl -> fl e. Flags $ = '(sylbi s_sat_anlift1 anl);
theorem s_flags_subsn: $ subsn (flags>-> fl) $ = '(subsnss s_anr subsnsn);

theorem s_readFlags: $ k |=s flags>-> v -> readFlags (ksCfg k) = v $ =
'(syl5eqr read_place_Flags @ sylbi s_sat_anlift1 @ anwr @
  sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_readFlags_d (h: $ P =>*s flags>-> v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readFlags k = v $ =
'(eqtr3d (readFlagseqd anlr) @ anwr @ syl s_readFlags @ s_weak_sat h);

theorem hoareCfg_writeFlags:
  $ v e. u64 -> hoareCfgR k (sn (writeFlags k v)) (flags>-> ip) (flags>-> v) $ =
(named '(mpbird (hoareCfgReq4d @ s_bian1 @ mpbir s_sn_sstop isfsn) @
  hoareCfgR_sn_d ,eqtac (a1i @ ss_s_weak s_anr)
    (sylan writeFlagsT (anwr @ syl ksCfgT s_sat_ks) anll)
    (a1i @ eqssr @ PageMappingeq getMemory_writeFlags)
    (anwr read_place_writeFlags_ne)
    (a1i @ eqtr read_place_Flags @ eqtr (readFlagseq ksCfg_setCfg) read_writeFlags)
    idd));

--| `RIP>-> a` means that the instruction pointer has value `a`.
@_ local def s_RIP (a): set = $ ^s (a e. u64) /\s sn (sn (X86P_RIP <> a)) $;
prefix s_RIP: $RIP>->$ prec 80;

theorem s_RIP_sstop: $ RIP>-> ip C_ T.s $ = '(sstr s_anl s_lift_sstop);
theorem s_RIP_T: $ k |=s RIP>-> ip -> ip e. u64 $ = '(sylbi s_sat_anlift1 anl);
theorem s_RIP_subsn: $ subsn (RIP>-> ip) $ = '(subsnss s_anr subsnsn);

theorem s_readRIP: $ k |=s RIP>-> ip -> readRIP (ksCfg k) = ip $ =
'(syl5eqr read_place_RIP @ sylbi s_sat_anlift1 @ anwr @
  sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_readRIP_d (h: $ P =>*s RIP>-> ip $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readRIP k = ip $ =
'(eqtr3d (readRIPeqd anlr) @ anwr @ syl s_readRIP @ s_weak_sat h);

theorem hoareCfg_writeRIP:
  $ v e. u64 -> hoareCfgR k (sn (writeRIP k v)) (RIP>-> ip) (RIP>-> v) $ =
(named '(mpbird (hoareCfgReq4d @ s_bian1 @ mpbir s_sn_sstop isfsn) @
  hoareCfgR_sn_d ,eqtac (a1i @ ss_s_weak s_anr)
    (sylan writeRIP_T (anwr @ syl ksCfgT s_sat_ks) anll)
    (a1i @ eqssr @ PageMappingeq getMemory_writeRIP)
    (anwr read_place_writeRIP_ne)
    (a1i @ eqtr read_place_RIP @ eqtr (readRIPeq ksCfg_setCfg) read_writeRIP)
    idd));

theorem s_writeRIP: $ v e. u64 -> k |=s R *s RIP>-> ip ->
  setCfg k (writeRIP (ksCfg k) v) |=s R *s RIP>-> v $ =
'(syl hoareCfgR_sn_frame_E hoareCfg_writeRIP);

--| `s_Except e` means that the exception flag has value `e`.
@_ local def s_Except (e): set = $ sn (sn (X86P_Except <> e)) $;
@_ local def s_OK: set = $ s_Except 0 $;
@_ local def s_IO: set = $ s_Except (suc exSysCall) $;
@_ local def s_ERR: set = $ s_Except (suc exGPF) $;

theorem s_Except_sstop: $ s_Except e C_ T.s $ = '(mpbir s_sn_sstop isfsn);
theorem s_OK_sstop: $ s_OK C_ T.s $ = 's_Except_sstop;
theorem s_IO_sstop: $ s_IO C_ T.s $ = 's_Except_sstop;
theorem s_ERR_sstop: $ s_ERR C_ T.s $ = 's_Except_sstop;
theorem s_Except_subsn: $ subsn (s_Except e) $ = 'subsnsn;
theorem s_OK_subsn: $ subsn s_OK $ = 's_Except_subsn;
theorem s_IO_subsn: $ subsn s_IO $ = 's_Except_subsn;
theorem s_ERR_subsn: $ subsn s_ERR $ = 's_Except_subsn;

theorem s_Except_readException: $ k |=s s_Except e -> readException (ksCfg k) = e $ =
'(syl5eqr read_place_Except @ sylbi s_sat_sn @ sylbi heap_sat_sn anr);
theorem s_OK_readException: $ k |=s s_OK -> readException (ksCfg k) = 0 $ = 's_Except_readException;
theorem s_IO_readException: $ k |=s s_IO -> readException (ksCfg k) = suc exSysCall $ = 's_Except_readException;
theorem s_ERR_readException: $ k |=s s_ERR -> readException (ksCfg k) = suc exGPF $ = 's_Except_readException;
theorem s_Except_readException_d (h: $ P =>*s s_Except e $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = e $ =
'(eqtr3d (readExceptioneqd anlr) @ anwr @ syl s_Except_readException @ s_weak_sat h);
theorem s_OK_readException_d (h: $ P =>*s s_OK $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = 0 $ = '(s_Except_readException_d h);
theorem s_IO_readException_d (h: $ P =>*s s_IO $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = suc exSysCall $ = '(s_Except_readException_d h);
theorem s_ERR_readException_d (h: $ P =>*s s_ERR $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readException k = suc exGPF $ = '(s_Except_readException_d h);

theorem hoareCfg_writeException (h: $ e2 e. Option Exception $):
  $ hoareCfgR k (sn (setException k e2)) (s_Except e1) (s_Except e2) $ =
(named '(trud @ hoareCfgR_sn ,eqtac
  (sylan setExceptionT (anwr ksCfgT) (a1i h))
  (a1i @ eqssr @ PageMappingeq getMemory_setException)
  (anwr read_place_setException_ne)
  (a1i @ eqtr read_place_Except @
    eqtr (readExceptioneq ksCfg_setCfg) read_setException)));

theorem s_readRegSz_8 (h1: $ b \/ ~2 e. r $) (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k (wSz8 b) r = chop 8 v $ =
'(chopeqd (a1i wSz8Bits) @ syl5eq (ifneg @ mpbir notan @
    orim1 (con2 @ sylbi prth @ anwr @ bi1i @ bitr (eqeq2 nat0) nateq0) h1) h);
theorem s_readRegSz_gt8 (h1: $ wsizeBits sz = n $) (h2: $ 8 < n $)
  (h: $ G -> readReg k r = v $): $ G -> readRegSz k sz r = chop n v $ =
'(chopeqd (a1i h1) @
  syl5eq (ifneg @ mt (anwl @ eqtr3g h1 wSz8Bits wsizeBitseq) @ ltner h2) h);
theorem s_readRegSz_16 (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k wSz16 r = chop 16 v $ = '(s_readRegSz_gt8 wSz16Bits d8lt16 h);
theorem s_readRegSz_32 (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k wSz32 r = chop 32 v $ = '(s_readRegSz_gt8 wSz32Bits d8lt32 h);
theorem s_readRegSz_64 (h: $ G -> readReg k r = v $):
  $ G -> readRegSz k wSz64 r = chop 64 v $ = '(s_readRegSz_gt8 wSz64Bits d8lt64 h);
theorem s_readRegSz_64_ (h1: $ G -> P =>*s r >->r v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readRegSz k wSz64 r = v $ =
(focus
  (have 'H '(s_readReg_d h1))
  '(eqtrd (s_readRegSz_64 H) @ syl Bits_chop @ mpbid (eleq1d H) @
    sylan readRegT s_elConfig_d @ anld @
    syl s_reg_T @ imp @ anwl @ syl s_weak_sat h1));

theorem s_readEA_i (h1: $ G -> q e. u64 $) (h2: $ G -> sz e. WSize $)
  (h3: $ G -> v = chop (wsizeBits sz) q $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz (EA_i q) v $ =
'(mpbird (sylan readEA_i (iand s_elConfig_d (anwll h1)) (anwll h2)) (anwll h3));

theorem s_readEA_r (h1: $ G -> r e. Regs $) (h2: $ G -> sz e. WSize $)
  (h3: $ G /\ ksCfg ks = k /\ ks |=s P -> readRegSz k sz r = v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz (EA_r r) v $ =
'(mpbird (sylan readEA_r (iand s_elConfig_d (anwll h1)) (anwll h2)) @ eqcomd h3);

theorem an2idms (h: $ G /\ a /\ b /\ a /\ b -> c $): $ G /\ a /\ b -> c $ =
'(rsyl (iand (iand id anlr) anr) h);

theorem s_readEA64_r (h1: $ G -> P =>*s r >->r v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA64 k (EA_r r) v $ =
'(an2idms @ s_readEA_r (anld @ syl s_reg_T @ imp @ anwl @ syl s_weak_sat h1)
    (a1i wSz64T) (anwll @ s_readRegSz_64_ h1));

theorem s_readEA_m (hn: $ wsizeBits sz = n $) (hm: $ wsizeBytes sz = m $)
  (ha: $ G -> a e. u64 $) (hsz: $ G -> sz e. WSize $)
  (hv: $ G -> v e. Bits n $) (hP: $ G -> P =>*s a >=> toBytes m v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA k sz (EA_m a) v $ =
'(mpbird (sylan readEA_m (iand s_elConfig_d (anwll ha)) (anwll hsz)) @
  iand (anwll @ sylibr (eleq2 @ nseq @ Bitseq hn) hv) @
  sylibr (readMemeq3 @ toByteseq1 hm) @ s_readMem_d hP);

theorem s_readEA64_m (ha: $ G -> a e. u64 $)
  (hv: $ G -> v e. u64 $) (hP: $ G -> P =>*s a >=> u64Bytes v $):
  $ G /\ ksCfg ks = k /\ ks |=s P -> readEA64 k (EA_m a) v $ =
'(s_readEA_m wSz64Bits wSz64Bytes ha (a1i wSz64T) hv hP);

theorem hoare_decode_step {k}
  (h1: $ G -> P =>*s ip >=>c l $)
  (h2: $ G -> decode ast l $)
  (h3: $ G -> ip + len l = ip2 $)
  (h4: $ G -> hoareCfgR k {k2 | execXAST k ast k2} (RIP>-> ip2 *s s_OK *s P) Q $)
     : $ G -> hoare T (RIP>-> ip *s s_OK *s P) Q $ =
(named @ focus
  (have 'H1 '(s_readRIP_d @ s_sepwl s_sepl))
  (have 'H2 '(imp @ anwl @ syl s_weak_sat @ syl s_sepwr h1))
  (have 'H3 '(anld @ syl s_code_T H2))
  '(hoareCfgR_step @
    mpbird (hoareCfgReq2da @
      bitrd (sylan decode_step
        (mpbird (readMemXeq2d H1) @ s_readMemX_d @ syl s_sepwr h1) (anwll h2)) @
      bitrd (syl bian1 @ s_OK_readException_d @ s_sepwl s_sepr) @
      execXASTeq1d @ writeRIPeq2d @ eqtrd (add64eq1d H1) @
      eqtrd (syl add64_eqid H3) @ anwll h3) @
    hoareCfgR_Td @ hoareCfgR_tr1
      (syl hoareCfgR_frame_r @ syl hoareCfgR_frame_r @
        syl hoareCfg_writeRIP @ mpbid (anwll @ eleq1d h3) H3)
      (anwll @ !! sbeth k h4 ,eqtac)));

theorem hoareCfgR_popAux
  (h1: $ G -> q e. u64 $)
  (h2: $ G -> P =>*s sp >=> u64Bytes q $)
  (h3: $ G -> sp +_64 8 = sp2 $):
  $ G -> hoareCfgR k {k2 | popAux k q k2} (RSP >->r sp *s P) (RSP >->r sp2 *s P) $ =
(named '(mpbird (hoareCfgReq2da @
    bitrd (syl bian1 @
      mpbird (readEA64eq2d @ EA_meqd @ s_readReg_d @ a1i s_sepl) @
      an2idms @ s_readEA64_m (anrd @ syl s_reg_T @ anwr @ s_weak_sat s_sepl)
        (anwll h1) (anwll @ syl s_sepwr h2)) @
    eqeq2d @ setRegeq3d @ eqtrd (add64eq1d @ s_readReg_d @ a1i s_sepl) (anwll h3)) @
  sylib (hoareCfgReq2 @ eqab2i elsn) @ syl hoareCfgR_frame_r @ syl hoareCfg_setReg @
  mpbii add64T @ eleq1d h3));

theorem hoareCfgR_popRIP
  (h1: $ G -> q e. u64 $)
  (h2: $ G -> P =>*s sp >=> u64Bytes q $)
  (h3: $ G -> sp +_64 8 = sp2 $):
  $ G -> hoareCfgR k {k2 | popRIP k k2}
    (RSP >->r sp *s RIP>-> ip *s P) (RSP >->r sp2 *s RIP>-> q *s P) $ =
(named @ focus
  (def H '(hoareCfgR_popAux h1 (syl s_sepwr h2) h3))
  '(sylibr (hoareCfgReq eqid eqsid s_sepass s_sepass) @
    mpbid (hoareCfgReq2da @ mpd (hoareCfgR_E_ex ,H) @ eexda @
      exeqd @ syl5bbr _ @ exeqd @
      syl bian1a @ anwr @ syl5 anl @ expcom @ anld popAux_determ) _)
  '(exeqe ,eqtac)
  '(hoareCfgR_tr ,H @ anwl @ sylib (hoareCfgReq2 @ eqab2i elsn) @
    syl hoareCfgR_frame @ syl hoareCfgR_frame_r @ syl hoareCfg_writeRIP h1));

theorem hoare_xastRet
  (h1: $ G -> sp +_64 q = sp2 $)
  (h2: $ G -> hoareCfgR k {ki | popRIP k ki} P (RSP >->r sp *s Q) $)
  : $ G -> hoareCfgR k {k2 | execXAST k (xastRet q) k2} P (RSP >->r sp2 *s Q) $ =
(named '(mpbird (hoareCfgReq2da @ a1i execXASTRet) @
  hoareCfgR_tr h2 @ sylib (hoareCfgReq2 @ eqab2i elsn) @
  syl hoareCfgR_frame_r @ hoareCfgR_Td @
  mpbird (hoareCfgReq2d @ nseqd @ sneqd @ setRegeq3d @
    eqtrd (add64eq1d @ s_readReg_d @ a1i s_weak_id) (anw3l h1)) @
  syl hoareCfg_setReg @
  mpbii add64T @ eleq1d @ anw3l h1));

theorem hoare_xastRet0
  (h1: $ G -> q e. u64 $)
  (h2: $ G -> P =>*s sp >=> u64Bytes q $)
  (h3: $ G -> sp +_64 8 = sp2 $):
  $ G -> hoareCfgR k {k2 | execXAST k (xastRet 0) k2}
    (RSP >->r sp *s RIP>-> ip *s P) (RSP >->r sp2 *s RIP>-> q *s P) $ =
(named '(sylibr (hoareCfgReq4 s_sepass) @
  hoare_xastRet (syl6eq add0 @ syl add64_eqid @
    mpbii add64T (eleq1d @ syl6eqr add0 h3)) @
  sylib (hoareCfgReq4 s_sepass) @ hoareCfgR_popRIP h1 h2 h3));

--| An unallocated stack block. Here `lo` is a parameter, representing the base of the
--| stack. The bytes within one page of the stack base have no access, otherwise
--| it is read/write data (we don't track write access).
--|
--| The upshot of this encoding is that writing to the memory is safe, and doing so
--| obtains a proof that `lo + 2 ^ 12 <= a`, because accessing the guard page
--| would have caused a crash. We can later merge the proof that `lo + 2 ^ 12 <= a` with
--| readable memory to return it to deallocated state.
@_ local def s_blockS (lo a n): set =
$ E.s v e. Array u8 n, s_mem (S\ x, {p |
    ifp (lo + 2 ^ 12 <= x) (PROT_READ C_ p) (p = 0)}) a v $;
notation s_blockS (lo a n): set = a ($>=>.[$:80) lo ($]$:0) n: 80 lassoc;

theorem s_blockS_sstop: $ a >=>.[lo] n C_ T.s $ = (named '(s_eex s_mem_sstop));
theorem s_blockS_T: $ k |=s a >=>.[lo] n -> a + n e. u64 $ =
(named '(sylbi s_sat_ex @ eex @
  mpbid (eleq1d @ addeq2d @ anwl elArraylen) @ anld @ anwr s_mem_T));
theorem s_blockS_0: $ a >=>.[lo] 0 == ^e (a e. u64) $ =
(named '(eqstr (s_exeq1 @ ax_gen @ bitr4 elArray02 elsn) @
  trud @ s_exeqe @ syl6eqs s_mem_0 ,eqtac));
theorem s_blockS_A: $ a >=>.[lo] (m + n) ==
  a >=>.[lo] m *s (a + m) >=>.[lo] n $ = (named 's_block0_A_lem);
theorem s_blockS_block0: $ a >=>.[lo] n C_ a >=>. n $ =
(named '(s_eximi @ a1i @ s_mem_ss @ ax_gen @ a1i @ rappss ssv2));

theorem s_block_blockS: $ lo + 2 ^ 12 <= a -> a >=> v C_ a >=>.[lo] len v $ =
(named '(sylib (sseq1 @ mpbi s_bian1a s_anl) @ syl s_imp @ expcom @
  syl s_iex @ iexde @
  iand (mpbird (eleq1d anr) @ sylibr elArray @ iand anllr eqidd) @
  mpbird ,eqtac (syl s_mem_ss @ ialda @
    sylibr (sseq (rappsabe ,eqtac) (rappsabe ,eqtac)) @ ssabd @
    bi2d @ syl ifppos @ syl (mpi leaddid1 letr) anllr)));

-- --| The unused portion of the stack, which contains an arbitrary block of
-- --| read/write data followed by a no-access guard page.
-- --|
-- --| `unused_stack lo sz` means that there are `sz` bytes of stack, such that
-- --| the low `min sz 4096` bytes of it are read protected, and the rest has
-- --| arbitrary readable memory.
-- @_ local def unused_stack (lo sz): set =
-- $ s_blockZ lo (min sz (2 ^ 12)) *s (lo + 2 ^ 12) >=>. (sz - 2 ^ 12) $;

-- theorem unused_stack_lo: $ sz <= 2 ^ 12 ->
--   unused_stack lo sz == ^s (lo + 2 ^ 12 e. u64) /\s s_blockZ lo sz $ =
-- '(syl6eqs s_sep_elift @ s_sepeqd (s_blockZeq2d eqmin1) @
--   syl6eqs s_block0_0 @ s_block0eq2d @ bi1i lesubeq0);

-- theorem unused_stack_hi:
--   $ unused_stack lo (sz + 2 ^ 12) == s_blockZ lo (2 ^ 12) *s (lo + 2 ^ 12) >=>. sz $ =
-- '(s_sepeq (s_blockZeq2 @ eqmin2 leaddid2) (s_block0eq2 pncan));

-- theorem s_dealloc_stack_lem:
--   $ s_mem P hi v *s unused_stack lo sz C_ unused_stack lo (sz + len v) $ =
-- (focus
--   '(_)
-- );

-- theorem s_dealloc_stack:
--   $ (lo + sz) >=>. n *s unused_stack lo sz C_ unused_stack lo (sz + n) $ =
-- (focus
--   '(eor _ _ leorle)
--   '(mpbii (s_sep_ss2 @ eqssr @ eqstr s_block0_A s_sepcom) @
--     sseqd (syl5eqs s_seplass @
--       s_sepeqd (s_block0eq1d @ syl5eq addass @ addeq2d pncan3) @
--         syl5eqsr unused_stack_hi @ unused_stackeq2d npcan) @
--     syl5eqsr unused_stack_hi @ unused_stackeq2d @ syl5eq addrass @ addeq1d npcan)
--   '(mpbird (sseq1d @ s_sepeq2d unused_stack_lo) @ mpi leorle @ eorda _ _)
-- );

-- --| `unused_stack_bd hi sz` means that there are at least `sz` bytes of stack
-- --| "above" `hi` (the top of the stack). Note that the stack grows down so these
-- --| unused bytes are at lower addresses than `hi`, and `hi` itself is not included.
-- --|
-- --| This means in particular that writing to any element up to `sz` bytes above `hi`
-- --| is safe, because we know it is either allocated or guarded.
-- @_ local def unused_stack_bd (lo hi sz): set =
-- $ ^s (lo + sz <= hi /\ lo <= hi) /\s s_blockS lo lo (hi - lo) $;

-- theorem unused_stack_le2:
--   $ sz2 <= sz -> unused_stack_bd hi sz C_ unused_stack_bd hi sz2 $ =
-- (named '(s_eximd @ syl s_anim1 @
--   sylibr s_lift_ss @ anim1d @ syl letr @ sylib leadd2 anl));

-- theorem s_mem_dealloc_stack_bd:
--   $ s_mem P hi v *s unused_stack_bd hi sz C_ unused_stack_bd (hi + len v) (sz + len v) $ =
-- (named '(mpbi (sseq1 s_exsep1) @ s_eximi @ a1i @ mpbir (sseq1 s_sep_anlift2) @
--   sstr (s_anim2a @ mpbiri s_mem_dealloc_stack @ sseq2d @
--     unused_stackeq2d @ syl addsub anr) @
--   s_anim1 @ mpbir s_lift_ss @
--   anim (bi1i @ bitr leadd1 (leeq1 addass)) @ mpi leaddid1 letr));

--| The null layout.
@_ local def L_emp: set = $ S\ lo, S\ a, S\ sz, (^e (a e. u64 /\ sz = 0)) $;

theorem L_emp_val: $ L_emp @' lo @' a @' sz == ^e (a e. u64 /\ sz = 0) $ =
(focus '(trud _ @ ! eqsid $ L_emp $) '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

--| A sequential composition of layouts.
@_ local def L_seq (L1 L2: set): set =
$ S\ lo, S\ a, S\ sz, (E.s sz1 e. u64, E.s sz2 e. u64,
   (^s (sz e. u64 /\ sz = sz1 + sz2) /\s
    L1 @' lo @' a @' sz1 *s L2 @' lo @' (a + sz1) @' sz2)) $;

--| The layout for a single value `v: List u8`.
@_ local def L_1 (v: nat): set = $ S\ lo, S\ a, S\ sz, (^s (sz = len v) /\s a >=> v) $;

theorem L_1_val: $ L_1 v @' lo @' a @' sz == ^s (sz = len v) /\s a >=> v $ =
(focus '(trud _ @ ! eqsid $ L_1 v $) '(rappsabed1 @ rappsabed1 @ rappsabed2 ,eqtac));

--| A padding layout.
@_ local def L_pad: set = $ S\ lo, S\ a, S\ sz, (a >=>.[lo] sz) $;

--| An overlapping composition of layouts.
@_ local def L_or (L1 L2: set): set =
$ S\ lo, S\ a, S\ sz, (E.s sz1 e. u64, E.s sz2 e. u64,
   (^s (sz = max sz1 sz2) /\s
    L1 @' lo @' a @' sz1 *s L_pad @' lo @' (a + sz1) @' (sz - sz1) \/s
    L2 @' lo @' a @' sz1 *s L_pad @' lo @' (a + sz2) @' (sz - sz2))) $;

--| An overlapping composition of layouts.
@_ local def stack_layout (sp n: nat) (L: set): set =
$ E.s lo e. _V, E.s sz e. _V, (
    ^s (lo + sz e. u64 /\ sp <= lo + sz /\ lo + 2 ^ 12 + n <= lo + sz) /\s
    RSP >->r (lo + sz - sp) *s L_seq L_pad L @' lo @' lo @' sz) $;

--| The portion of the layout that we always want to know in any hoare triple.
--| `main_layout c sp ip` means that the code `c` is at `text_start`,
--| the instruction pointer at `ip`, and the flags are assigned to an arbitrary value
--| (i.e. we are permitted to clobber them).
--| Additionally, the stack is laid out according to stack layout `L`
--| (see the `L_*` functions) with at least `n` spare bytes left in the stack frame;
--| `sp` is the value of the stack pointer relative to the stack layout.
@_ local def main_layout (c sp ip n L): set =
$ text_start >=>c c *s RIP>-> ip *s s_OK *s
  E.s fl e. Flags, flags>-> fl *s stack_layout sp n L $;

--| The correctness predicate for a function call.
--| * `T`: A global parameter, the correctness predicate on final IO
--| * `c`: A global parameter, the program code
--| * `ip`: The address of the function
--| * `P`: The function's precondition, arranged using a calling convention
--| * `Q`: The function's postcondition, also determined by a calling convention
--|
--| This says that if we were to call a function at location `ip`,
--| with inputs arranged according to `P`, then the function will successfully
--| terminate and the outputs will be arranged according to `Q`.
--|
--| Both `P` and `Q` are allowed to depend on common logical variables `vs`.
@_ local def func_ok (T c ip P Q): wff =
$ A. vs A. ret (ret e. u64 -> hoare T
    (main_layout c 8 ip (2 ^ 12) (L_1 (u64Bytes ret)) *s (P @' vs))
    (main_layout c 0 ret 8 L_emp *s (Q @' vs))) $;

--| The correctness predicate for a jump target.
--| * `T, c`: Global parameters
--| * `sp`: The value of the stack pointer (a function-global parameter)
--| * `fr`: The frame condition (a function-global parameter)
--| * `ip`: The address of the jump target
--| * `L`: The stack frame layout as of the jump
--| * `P`: The jump's precondition, arranged using a calling convention
--|
--| This says that if we were to jump to location `ip`,
--| with inputs arranged according to `L` and `P`, then the
--| program will eventually terminate. This is used as an available
--| hypothesis for every jump target in scope.
--|
--| Both `L` and `P` are allowed to depend on common logical variables `vs`.
@_ local def jump_ok (T c sp fr ip L P): wff =
$ s_ok (sn fr *s (main_layout c sp ip 8 L *s P)) T $;

-- @_ local def c_param (T: set) (c fr: nat) = $ Sum T (c <> fr) $;
-- @_ local def c_param_T (X: set) = $ Fst X $;
-- @_ local def c_param_c (X: set) = $ fst (lower (Snd X)) $;
-- @_ local def c_param_fr (X: set) = $ snd (lower (Snd X)) $;

-- local def compile_expr
--   (T: set) (c fr: nat) -- global parameters
--   (ip: nat) -- the current location of the instruction pointer
--   (L: set) -- the stack layout at this point
--   (P: set) = -- the precondition for flow into this point
-- $ s_ok (sn fr *s (main_layout c sp ip 8 L *s P)) T $;

-- A type ty consists of:
-- * a separating proposition [v : ty] which gives truth conditions for "v has type ty",
-- * a proposition `v e. |ty|` which describes the "duplicable core" of the type
-- * a set of values {v : ty} which gives the valid byte strings that can represent v.
--
-- A type may have no valid byte strings, in which case it is only usable for
-- ghost values.
-- The size of a type is the smallest `n` such that `A. l (l e. {v : ty} -> len l <= n)`.

@_ local def core_of (ty: set): set = $ {v | 0 e. Fst (ty @' v)} $;
@_ local def has_ty (v: nat) (ty: set): set =
$ ^s (v e. core_of ty) /\s Tail (Fst (ty @' v)) $;
@_ local def ty_Rep (v: nat) (ty: set): set = $ Snd (ty @' v) $;
@_ local def ty_rep (ty: set) (v l: nat): set =
$ ^s (l e. ty_Rep v ty) /\s has_ty v ty $;

--| An assignment of register `r` to value `v` of type `ty`.
@_ local def t_reg (r v: nat) (ty: set): set =
$ E.s n e. upto (suc 8), E.s a e. Bits (8 * n), (
  ^s (n <= 8) /\s r >->r a *s
  ty_rep ty v (toBytes n a)) $;

--| A memory allocation at `a` with value `v` of type `ty`.
@_ local def t_mem (a v: nat) (ty: set): set =
$ E.s l e. List u8, (a >=> l *s ty_rep ty v l) $;

@_ local def ty_u8: set = $ S\ v, Sum (ocasep (v e. u8) emp) (sn (v : 0)) $;
@_ local def ty_u16: set = $ S\ v, Sum (ocasep (v e. u16) emp) (sn (u16Bytes v)) $;
@_ local def ty_u32: set = $ S\ v, Sum (ocasep (v e. u32) emp) (sn (u32Bytes v)) $;
@_ local def ty_u64: set = $ S\ v, Sum (ocasep (v e. u64) emp) (sn (u64Bytes v)) $;
@_ local def ty_i8: set = $ S\ v, Sum (ocasep (v e. u8) emp) (sn (i8Bytes v)) $;
@_ local def ty_i16: set = $ S\ v, Sum (ocasep (v e. u16) emp) (sn (i16Bytes v)) $;
@_ local def ty_i32: set = $ S\ v, Sum (ocasep (v e. u32) emp) (sn (i32Bytes v)) $;
@_ local def ty_i64: set = $ S\ v, Sum (ocasep (v e. u64) emp) (sn (i64Bytes v)) $;
@_ local def ty_nat: set = $ S\ v, Sum (ocasep T. emp) 0 $;
@_ local def ty_int: set = $ S\ v, Sum (ocasep T. emp) 0 $;

--| The "duplicable core" of a type.
@_ local def ty_core (ty: set): set =
$ S\ v, Sum (ocasep (v e. core_of ty) emp) (ty_Rep v ty) $;

--| A singleton has the same representation as the underlying type, but
--| it only has one valid value.
@_ local def ty_sn (a: nat) (ty: set): set =
$ S\ v, Sum (ocasep (v = a /\ v e. core_of ty) (has_ty v ty)) (ty_Rep v ty) $;

-------------------------------------
-- Eliminating the bound variables --
-------------------------------------

--| The separating conjunction lifted over functions on `vs`.
@_ local def v_sep (P Q): set = $ S\ vs, (P @' vs *s Q @' vs) $;

@_ local def trim0 (n: nat): nat = $ lower ((\ i, n @ i) i^i Xp (Compl (sn 0)) _V) $;

--| The `n`th variable as a higher order function from the variable list to a value.
@_ local def vn (n: nat): set = $ \ vs, vs @ n $;

--| An assignment of register `r` to value `v` of type `ty`.
local def v_reg (r: hex) (v ty: set): set = $ S\ vs, t_reg r (v @ vs) (ty @' vs) $;

--| A memory allocation at `a` with value `v` of type `ty`.
@_ local def v_mem (a: nat) (v ty: set): set = $ S\ vs, t_mem a (v @ vs) (ty @' vs) $;

--| Asserts that the expression `v` has type `ty`.
@_ local def v_has_ty (v ty: set): set = $ S\ vs, has_ty (v @ vs) (ty @' vs) $;

--| Lift the singleton type to functions.
@_ local def v_ty_sn (a ty: set): set = $ S\ vs, ty_sn (a @ vs) (ty @' vs) $;

--| Lift addition to functions.
@_ local def v_add (a b: set): set = $ \ vs, a @ vs + b @ vs $;

--| Existential quantifier expressed without bound variables.
--| `v_ex i ty P` means there exists `v_i` such that `[v_i : ty] *s P[i/v_i]`.
--| Note that we are using explicit (named) variables here, not de Bruijn;
--| we clobber the previous value of `v_i` inside the scope.
@_ local def v_ex (i: nat) (ty P: set): set =
$ S\ vs, (E.s a e. _V, (has_ty a ty *s
  P @' trim0 (lower (write vs i a)))) $;

@_ local def v_ty_u32: set = $ S\ vs, ty_u32 $;

-- testing

-- local def progT = $ S\ i, {o | 2 + 2 = 4} $;
-- local def prog: nat = $0$;
-- local def adder: nat = $0$;

-- theorem CFG_ret
--   (hc: $ assembled c (s1 (ch xc x3)) ip ip2 $)
--   (hr: $ G -> ret e. u64 $)
--   (hj: $ G -> jump_ok T c 8 fr ret L_emp P $):
--   $ G -> jump_ok T c 0 fr ip (L_1 (u64Bytes ret)) P $ =
-- (focus
--   (have 'H '(s_code_assembled hc))
--   '(mpd hj @ syl hoare_frame_ok @ syl hoare_frame_r @
--     sylibr (hoareeq2 @ s_bisep11i @ s_bisep11i @ eqstr s_sepass s_sepcom) @
--     hoare_decode_step (a1i @ s_sepwl @ s_sepwl @ anli H) (a1i decodeRet0I) (a1i @ anri H) @
--     hoareCfgReq4g
--       (eqstr s_sepass @ eqstr3 (s_sepeq2 s_sepass) s_seplass)
--       (s_bisep11i @ eqstr (s_sepeq1 @ eqstr s_sepcom @
--         eqstr4 (s_sepeq2 s_sepcom) s_sepass) @ eqstr s_sepass s_seprass) @
--     syl hoareCfgR_frame @
--     hoareCfgReq3g s_exsep1 s_exsep1 @ sylib hoareCfgR_eexb @ !! iald lo @ a1d @
--     sylib (hoareCfgReq3 s_exsep1) @ sylib hoareCfgR_eexb @ !! iald sz @ a1d @
--     hoareCfgR_iexe ,eqtac (a1i elv) @
--     sylib (hoareCfgReq4 s_exsep1) @ hoareCfgR_iexe ,eqtac (a1i elv) _)
--   '(hoareCfgReq4g (eqstr _ s_sep_anlift2) s_sep_anlift2 _)
--   (focus
--     '(s_sepeq2 @ eqstr4 _ s_anlift_ass)
--     '(s_aneq2 @ s_bian1sep2i _))
--   (have 'H2 '(syl6eq u64Bytes_len anrr))
--   '(hoareCfgR_animd (iand (sylibr (eleq1 add0) (anwr anll)) @
--       mpbid (leeq1d H2) @ letrd (a1i leaddid2) (a1i leaddid1)) @
--     hoareCfgReq3g (eqstr s_sepass s_seplass) (eqstr s_sepass s_seplass) @

--     -- hoareCfgR_iexe ,eqtac (a1i elv) @
--     -- hoareCfgReq3g s_exsep1 s_exsep1 @ sylib hoareCfgR_eexb @ !! iald sz @ a1d @
--     -- hoareCfgR_iexe ,eqtac (a1i elv) @
--     -- hoareCfgReq3g
--     --   (eqstr s_sepass @ eqstr s_seplass @ s_sepeq2 s_sep_anlift2)
--     --   (eqstr s_sepass @ eqstr s_seplass @ s_sepeq2 s_sep_anlift2) @
--     sylc hoareCfgR_weakr (syl s_sep_weak2 @  _) @
--     hoare_xastRet0
--     -- hr (syl s_weak_anwr @ syl s_sepwl @ _)
--      _ _ _
-- ));

-- theorem th (vs)
--   (h1: $ G -> ret e. u64 $)
--   (h2: $ G -> jump_ok progT prog 0 fr ret L_emp
--     (v_ex x2
--         (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)
--         (v_reg x0 (vn x2) (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)) @'
--       vs) $):
--   $ G -> s_ok
--     (sn fr *s
--       (main_layout prog 8 adder (2 ^ 12) (L_1 (toBytes 8 ret)) *s
--         v_sep (v_reg x7 (vn x0) v_ty_u32) (v_reg x6 (vn x1) v_ty_u32) @' vs))
--     progT $ =
-- (focus
--   (have 'h $ G -> jump_ok $ 'h2)
--   );
-- theorem _:
--   $ func_ok progT prog adder
--       (v_sep
--         (v_reg x7 (vn x0) v_ty_u32)
--         (v_reg x6 (vn x1) v_ty_u32))
--       (v_ex x2 (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64)
--         (v_reg x0 (vn x2) (v_ty_sn (v_add (vn x0) (vn x1)) v_ty_u64))) $ =
-- (named '(ax_gen @ ax_gen @ ialda @ th anl anr));

-- (proc (adder {x : u32} {y : u32} : {ret : (sn {{x + y} : u64})})
--   (cast {(cast {x + y} (assert {{x + y} < {2 ^ 64}})) : u64}))
--
-- (proc (main : $ 2 + 2 = 4 $)
--   {(four h) := (adder 2 2)}
--   -- h: $ 2 + 2 = four $
--   {h2 := (assert {four = 4})}
--   -- h: $ 2 + 2 = four $, h2: $ four = 4 $
--   (return (entail h h2 eqtr)))

--| Constructs a cons of 16 elements represented as a perfect binary tree in `a`.
--| We use `cons16` nodes for storing lists of variable values with efficient lookup
--| (still linear time but with a better constant factor). Most functions won't have
--| more than 60-100 variables anyway so this should be fine, and if we need to do
--| better it's possible to make this logarithmic using binary random-access lists.
@_ local def cons16 (a l: nat): set =
$ ,(letrec ([(f n a x)
    @ if {n = 0} '(cons ,a ,x) (f {n - 1} '(fst ,a) @ f {n - 1} '(snd ,a) x)])
    (f 4 'a 'l)) $;

do {
  (def mmc-compiler (ref! (mmc-init)))
  (def mmc-reset
    (def c mmc-compiler)
    (fn () (set! c (mmc-init))))
  (def mmc-add
    (def c mmc-compiler)
    (fn xs (apply c '+ xs)))
  (def mmc-finish
    (def c mmc-compiler)
    (fn xs (apply c 'finish xs)))
  (def mmc-compiler)
  (def (mmc-compile x . xs)
    (apply mmc-add xs)
    (mmc-finish x))
};
