-- This include doesn't actually work, so use copy and paste
--| #include "peano.mm0"

-- Some additional list operations

-- all2 : (A -> B -> Bool) -> list A -> list B -> Bool
def all2 {x y .n: nat} (ph: wff x y) (l1 l2: nat): wff =
$ len l1 = len l2 /\ A. n A. x A. y
  (nth l1 n = suc x -> nth l2 n = suc y -> ph) $;

-- ex2 : (A -> B -> Bool) -> list A -> list B -> Bool
def ex2 {x y .n: nat} (ph: wff x y) (l1 l2: nat): wff =
$ len l1 = len l2 /\ E. n E. x E. y
  (nth l1 n = suc x /\ nth l2 n = suc y /\ ph) $;

-- map : (A -> B) -> list A -> list B
def map (F: set) (l: nat): nat;
theorem map0 (F: set): $ map F 0 = 0 $;
theorem mapS (F: set) (a l: nat):
  $ map F (a : l) = F @ a : map F l $;

-- ljoin : list (list A) -> list A
def ljoin (L: nat): nat;
theorem ljoin0: $ ljoin 0 = 0 $;
theorem ljoinS (l L: nat): $ ljoin (l : L) = l ++ ljoin L $;

-- The sort modifiers 'pure', 'strict', 'provable', 'free'
-- sPure : SortData -> Bool
def sPure     (n: nat): wff = $ true (pi11 n) $;
-- sStrict : SortData -> Bool
def sStrict   (n: nat): wff = $ true (pi12 n) $;
-- sProvable : SortData -> Bool
def sProvable (n: nat): wff = $ true (pi21 n) $;
-- sFree : SortData -> Bool
def sFree     (n: nat): wff = $ true (pi22 n) $;

-- A binder is either a bound variable with sort s, or a regular variable
-- with sort s and dependencies vs.
-- PBound : SortID -> Binder
def PBound (s: nat): nat = $ b0 s $;
-- PReg : SortID -> set VarID -> Binder
def PReg (s vs: nat): nat = $ b1 (s <> vs) $;

-- Get the sort of a binder.
-- binderSort : Binder -> SortID
def binderSort (x: nat): nat;
theorem binderSortBound (s: nat): $ binderSort (PBound s) = s $;
theorem binderSortReg (s vs: nat): $ binderSort (PReg s vs) = s $;

-- An s-expression, representing the terms and formulas. It can be either a
-- variable (v is a VarID) or an application of the term with TermID `f`
-- to arguments `x` (a list of s-expressions).
-- SVar : VarID -> SExpr
def SVar (v: nat): nat = $ b0 v $;
-- SApp : TermID -> list SExpr -> SExpr
def SApp (f x: nat): nat = $ b1 (f <> x) $;

-- The environment is composed of declarations, which come in a few types:
-- A `sort` declaration has an associated `SortData` with the sort modifiers.
-- Sorts are indexed by SortID and picked out by `getSD`.
-- DSort : SortData -> Decl
def DSort (sd: nat): nat = $ b0 (b0 (b0 sd)) $;
-- A `term` declaration has a list of binders, and a target type (a DepType,
-- which is a `(SortID, set VarID)` pair).
-- Terms are indexed by TermID and picked out by `getTerm`.
-- DTerm : Ctx -> DepType -> Decl
def DTerm (args ret: nat): nat = $ b0 (b0 (b1 (args <> ret))) $;
-- An `axiom` declaration has a list of binders, a list of hypotheses,
-- and a consequent.
-- Axioms are indexed by ThmID and picked out by `getThm`.
-- DAxiom : Ctx -> list SExpr -> SExpr -> Decl
def DAxiom (args hs ret: nat): nat = $ b0 (b1 (args <> hs <> ret)) $;
-- A `def` declaration is the same as a `term` except it also has an optional
-- definition component which lists the sorts of the dummy variables and the
-- definition's expression. The `sp` field indicates if this definition was
-- present in the specification (as opposed to being added during proof
-- checking).
-- Defs are indexed by TermID and picked out by `getTerm`.
-- DDef : Ctx -> DepType -> option (list SortID, SExpr) -> Bool -> Decl
def DDef (args ret def: nat) (sp: wff): nat =
  $ b1 (b0 (args <> ret <> def <> nat sp)) $;
-- A `theorem` declaration is exactly the same structure as an `axiom`, but
-- the interpretation is different - theorems require proofs, while axioms are
-- added in the spec.
-- Theorems are indexed by ThmID and picked out by `getThm`.
-- DThm : Ctx -> list SExpr -> SExpr -> Decl
def DThm (vs hs ret: nat): nat = $ b1 (b1 (vs <> hs <> ret)) $;

-- This function extracts the `SortData` for a sort given by `SortID`.
-- Because all declarations are intermingled in the environment, we must skip
-- past all the other declarations and count the sorts we pass.
-- getSD : Env -> SortID -> option SortData
def getSD (env n: nat): nat;
theorem getSD0 (n: nat): $ getSD 0 n = 0 $;
theorem getSDSort0 (sd e: nat): $ getSD (DSort sd : e) 0 = suc sd $;
theorem getSDSortS (sd e n: nat): $ getSD (DSort sd : e) (suc n) = getSD e n $;
theorem getSDTerm (a r e n: nat): $ getSD (DTerm a r : e) n = getSD e n $;
theorem getSDAxiom (a h r e n: nat): $ getSD (DAxiom a h r : e) n = getSD e n $;
theorem getSDDef (a r o e n: nat) (sp: wff):
  $ getSD (DDef a r o sp : e) n = getSD e n $;
theorem getSDThm (vs hs ret e n: nat):
  $ getSD (DThm vs hs ret : e) n = getSD e n $;

-- This function gets the term and definition data for a term. Here we have
-- a complication: The spec and the proof have incompatible numbering schemes
-- (because the proof wants to insert items between the spec's, but the spec
-- doesn't know about the proof). To resolve this, there are two disjoint
-- namespaces for TermIDs. The `b0 n` numbers are used for the spec, and `b1 n`
-- are additional terms added by the proof. The `sp` field indicates whether
-- a definition comes from the spec or the proof.
-- getTerm : Env -> TermID ->
--   option (Ctx, DepType, option (option (list SortID, SExpr)))
def getTerm (env n: nat): nat;
theorem getTerm0 (n: nat): $ getTerm 0 n = 0 $;
theorem getTermSort (sd e n: nat): $ getTerm (DSort sd : e) n = getTerm e n $;
theorem getTermTerm0 (a r e: nat):
  $ getTerm (DTerm a r : e) (b0 0) = suc (a <> r <> 0) $;
theorem getTermTermS0 (a r e n: nat):
  $ getTerm (DTerm a r : e) (b0 (suc n)) = getTerm e (b0 n) $;
theorem getTermTermS1 (a r e n: nat):
  $ getTerm (DTerm a r : e) (b1 n) = getTerm e (b1 n) $;
theorem getTermAxiom (a h r e n: nat):
  $ getTerm (DAxiom a h r : e) n = getTerm e n $;
theorem getTermDef0 (a r o e: nat) (sp: wff):
  $ sp -> getTerm (DDef a r o sp : e) (b0 0) = suc (a <> r <> suc o) $;
theorem getTermDefN0 (a r o e: nat) (sp: wff):
  $ ~sp -> getTerm (DDef a r o sp : e) (b1 0) = suc (a <> r <> suc o) $;
theorem getTermDefS0 (a r o e n: nat) (sp: wff):
  $ sp -> getTerm (DDef a r o sp : e) (b0 (suc n)) = getTerm e n $;
theorem getTermDefNS0 (a r o e n: nat) (sp: wff):
  $ ~sp -> getTerm (DDef a r o sp : e) (b1 (suc n)) = getTerm e n $;
theorem getTermDefS1 (a r o e n: nat) (sp: wff):
  $ sp -> getTerm (DDef a r o sp : e) (b1 n) = getTerm e (b1 n) $;
theorem getTermDefNS1 (a r o e n: nat) (sp: wff):
  $ ~sp -> getTerm (DDef a r o sp : e) (b0 n) = getTerm e (b0 n) $;
theorem getTermThm (vs hs ret e n: nat):
  $ getTerm (DThm vs hs ret : e) n = getTerm e n $;

-- This function extracts the definition information from `getTerm`.
-- getDef : Env -> TermID -> option (list SortID, SExpr)
def getDef (env n: nat): nat;
theorem getDef0 (env n: nat): $ getTerm env n = 0 -> getDef env n = 0 $;
theorem getDefS (env n a r o: nat):
  $ getTerm env n = suc (a <> r <> o) -> getDef env n = o $;

-- This function gets the data for an axiom or theorem by ThmID.
-- getThm : Env -> ThmID -> option (Ctx, list SExpr, SExpr)
def getThm (env n: nat): nat;
theorem getThm0 (n: nat): $ getThm 0 n = 0 $;
theorem getThmSort (sd e n: nat): $ getThm (DSort sd : e) n = getThm e n $;
theorem getThmTerm (a r e n: nat):
  $ getThm (DTerm a r : e) n = getThm e n $;
theorem getThmDef (a r o e n: nat) (sp: wff):
  $ getThm (DDef a r o sp : e) n = getThm e n $;
theorem getThmAxiom0 (a h r e: nat):
  $ getThm (DAxiom a h r : e) 0 = suc (a <> h <> r) $;
theorem getThmAxiomS (a h r e n: nat):
  $ getThm (DAxiom a h r : e) (suc n) = getThm e n $;
theorem getThmThm0 (a h r e: nat):
  $ getThm (DThm a h r : e) 0 = suc (a <> h <> r) $;
theorem getThmThmS (a h r e n: nat):
  $ getThm (DThm a h r : e) (suc n) = getThm e n $;

-- Is this ID a valid sort?
-- isSort : Env -> SortID -> Bool
def isSort (env s: nat): wff = $ getSD env s != 0 $;

-- Looks this variable up in the context, and reports whether it represents a
-- bound variable.
-- isBound : Ctx -> VarID -> Bool
def isBound (ctx x .s: nat): wff = $ E. s nth ctx x = suc (PBound s) $;

-- Checks if this a well formed dependent type in the context. A DepType is a
-- pair (SortID, set VarID) giving the sort and the variable dependencies.
-- DepType : Env -> Ctx -> DepType -> Bool
def DepType (env ctx ty .x: nat): wff =
$ isSort env (fst ty) /\ A. x (x e. snd ty -> isBound ctx x) $;

-- Checks if this a well formed context. A context can be extended with a bound
-- variable binder if the sort of the binder is not `strict`.
-- Note `Ctx = list Binder`.
-- Ctx : Env -> Ctx -> Bool
def Ctx (env ctx: nat): wff;
theorem Ctx0 (env: nat): $ Ctx env 0 $;
theorem CtxBound (env ctx s: nat) {sd: nat}: $ Ctx env (ctx |> PBound s) <->
  Ctx env ctx /\ E. sd (getSD env s = suc sd /\ ~ sStrict sd) $;
theorem CtxReg (env ctx s vs: nat): $ Ctx env (ctx |> PReg s vs) <->
  Ctx env ctx /\ DepType env ctx (s <> vs) $;

-- These mutually recursive functions check if an expression `e` is well-typed
-- with sort `s`, and that `e` is well-typed and valid for entry into a binder
-- `bi`. The main difference is that for an expression to be valid for a
-- BV binder, the expression must itself be a bound variable.
-- Expr : Env -> Ctx -> SExpr -> SortID -> Bool
def Expr (env ctx e s: nat): wff;
-- ExprBi : Env -> Ctx -> SExpr -> Binder -> Bool
def ExprBi (env ctx e bi: nat): wff;
theorem ExprVar (env ctx v s: nat) {bi: nat}: $ Expr env ctx (SVar v) s <->
  E. bi (nth ctx v = suc bi /\ binderSort bi = s) $;
theorem ExprApp (env ctx f xs s: nat) {args ret o x a: nat}:
  $ Expr env ctx (SApp f xs) s <-> E. args E. ret E. o
    ( getTerm env f = suc (args <> ret <> o) /\
      all2 x a (ExprBi env ctx x a) xs args /\
      s = fst ret ) $;
theorem ExprBiBound (env ctx e s: nat) {v: nat}:
  $ ExprBi env ctx e (PBound s) <->
    E. v (e = SVar v /\ nth ctx v = suc (PBound s)) $;
theorem ExprBiReg (env ctx e s vs: nat):
  $ ExprBi env ctx e (PReg s vs) <-> Expr env ctx e s $;

-- Is this a type correct expression of provable type? This is used to
-- typecheck expressions appearing in hypotheses and conclusions of
-- axiom/theorem.
-- ExprProv : Env -> Ctx -> SExpr -> Bool
def ExprProv (env ctx e .s .sd: nat): wff =
$ E. s E. sd (Expr env ctx e s /\ getSD env s = suc sd /\ sProvable sd) $;

-- A helper function to add dummy variables to the context.
-- appendDummies : Ctx -> list SortID -> Ctx
def appendDummies (ctx ds: nat): nat;
theorem appendDummies0 (ctx: nat): $ appendDummies ctx 0 = ctx $;
theorem appendDummiesS (ctx d ds: nat):
  $ appendDummies ctx (d : ds) =
    appendDummies (ctx |> PBound d) ds $;

-- Does this expression contain any occurrence of the variable `v`? This check
-- ignores bound variables, "metamath style". We use this stricter check for
-- verifying theorem applications.
-- HasVar : Ctx -> SExpr -> VarID -> Bool
def HasVar (ctx e v: nat): wff;
theorem HasVarBound (ctx u v s: nat):
  $ nth ctx u = suc (PBound s) -> (HasVar ctx (SVar u) v <-> u = v) $;
theorem HasVarReg (ctx u v s vs: nat):
  $ nth ctx u = suc (PReg s vs) -> (HasVar ctx (SVar u) v <-> v e. vs) $;
theorem HasVarApp (ctx f es v: nat) {e: nat}:
  $ HasVar ctx (SApp f es) v <-> E. e (e IN es /\ HasVar ctx e v) $;

-- Does this expression contain any _free_ occurrence of the variable `v`?
-- This is the more complex binder-respecting check. Intuitively, if
-- `term foo {x y: set} (ph: set x): set y;`, then `foo` binds occurrences of
-- `x` in `ph`, and adds a dependency on `y` regardless. We might write this
-- as `FV(foo x y ph) = (FV(ph) \ {x}) u {y}`, but the definition below is
-- for arbitrary binding structures.
-- Free : Env -> Ctx -> SExpr -> VarID -> Bool
def Free (env ctx e v: nat): wff;
theorem FreeVar (env ctx u v: nat):
  $ Free env ctx (SVar u) v <-> HasVar ctx (SVar u) v $;

-- A helper function for `Free`. This constructs the set `_V \ deps(a)` if `a`
-- is a regular argument and `(/)` if `a` is a bound argument.
-- MaybeFreeArgs : Env -> Binder -> VarID -> Bool
def MaybeFreeArgs (es a v .s .vs .u: nat): wff =
$ E. s E. vs (a = PReg s vs /\ ~(E. u (u e. vs /\ nth es u = suc (SVar v)))) $;
theorem FreeApp (env ctx f es args r rs o v: nat) {n e a u: nat}:
  $ getTerm env f = suc (args <> (r <> rs) <> o) ->
    (Free env ctx (SApp f es) v <->
      ex2 e a (Free env ctx e v /\ MaybeFreeArgs es a v) es args \/
      E. u (u e. rs /\ nth es u = suc (SVar v))) $;


-- Is this a valid term in the given environment? A term is valid if
-- the argument list is valid, the return type is valid, and the return sort
-- is not `pure` (because `pure` sorts are not allowed to have term
-- constructors).
-- TermOk : Env -> Ctx -> DepType -> Bool
def TermOk (env args ret .sd: nat): wff =
$ Ctx env args /\ DepType env args ret /\
  E. sd (getSD env (fst ret) = suc sd /\ ~ sPure sd) $;

-- Is this a valid definition in the given environment? A definition is valid
-- if it is a valid term, and the definition typechecks, and all free variables
-- are declared in the return type. (Note in particular that dummies cannot
-- appear in the return type dependencies, so this ensures that all dummies are
-- bound by the definition.)
-- DefOk : Env -> Ctx -> DepType -> Bool
def DefOk (env args ret ds e .ctx .v .s .sd: nat): wff =
$ TermOk env args ret /\ [ appendDummies args ds / ctx ]
  (Expr env ctx e (fst ret) /\ A. v (Free env ctx e v -> v e. snd ret \/
    E. sd E. s (nth ctx v = suc (PBound s) /\
      getSD env s = suc sd /\ sFree sd))) $;

-- Is this a valid declaration in the environment?
-- Decl : Env -> Decl -> Bool
def Decl (env d: nat): wff;
theorem DeclSort (env sd: nat): $ Decl env (DSort sd) $;
theorem DeclTerm (env args ret: nat):
  $ Decl env (DTerm args ret) <-> TermOk env args ret $;
theorem DeclAxiom (env args hs ret: nat) {x: nat}:
  $ Decl env (DAxiom args hs ret) <-> Ctx env args /\
    all {x | ExprProv env args x} (ret : hs) $;
theorem DeclDef (env args ret: nat) (sp: wff) {ds e o v: nat}:
  $ Decl env (DDef args ret o sp) <-> TermOk env args ret /\
    A. ds A. e (o = suc (ds <> e) -> DefOk env args ret ds e) $;
theorem DeclThm (env args hs ret: nat) {x: nat}:
  $ Decl env (DThm args hs ret) <->
    Ctx env args /\ all {x | ExprProv env args x} (ret : hs) $;

-- This defines a valid mm0 specification. These are well formed ASTs for which
-- we can assign a provability predicate.
-- Env : Env -> Bool
def Env (e: nat): wff;
theorem Env0: $ Env 0 $;
theorem EnvS (e s: nat): $ Env (e |> s) <-> Env e /\ Decl e s $;

------------------
-- Verification --
------------------

-- These are the different kinds of proof steps.

-- A StepSort says "proceed to the next declaration in the spec,
-- which is a `sort` declaration".
-- StepSort : ProofCmd
def StepSort: nat = $ b0 0 $;

-- A StepTerm says "proceed to the next declaration in the spec,
-- which is a `term` declaration".
-- StepTerm : ProofCmd
def StepTerm: nat = $ b0 1 $;

-- A StepAxiom says "proceed to the next declaration in the spec,
-- which is an `axiom`".
-- StepAxiom : ProofCmd
def StepAxiom: nat = $ b0 2 $;

-- A ProofDef adds and checks a new declaration. The proof provides the
-- signature and the value of the declaration (not optional this time).
-- If `st` is true then this declaration will be stepped in the spec, i.e.
-- we will check that the spec declared this declaration as well with the
-- same signature.
-- ProofDef : Ctx -> DepType -> list SortID -> SExpr -> Bool -> ProofCmd
def ProofDef (args ret ds val: nat) (st: wff): nat =
  $ b1 (b0 (args <> ret <> ds <> val <> nat st)) $;

-- A ProofThm adds and checks a new proof. The signature for the theorem is
-- given, followed by `uf: set TermID` which specifies which definitions in
-- the statement to unfold before starting the proof. The unfolding process
-- can produce new dummy variables; these are named after the variables in the
-- context and before the declared dummy variables. The final argument is the
-- proof expression itself.
-- ProofThm : Ctx -> list SExpr -> Sexpr -> set TermID ->
--   list SortID -> VExpr -> Bool -> ProofCmd
def ProofThm (args hs ret uf ds pf: nat) (st: wff): nat =
  $ b1 (b1 (args <> hs <> ret <> uf <> ds <> pf <> nat st)) $;


-- This helper function appends a new copy of the given dummy variable list
-- to the context, and also augments the substitution map with these variables.
-- buildSubst : Ctx -> list SExpr -> list SortID -> (Ctx, list SExpr)
def buildSubst (ctx es ds: nat): nat;
theorem buildSubst0 (ctx es: nat): $ buildSubst ctx es 0 = ctx <> es $;
theorem buildSubstS (ctx es d ds: nat): $ buildSubst ctx es (d : ds) =
  buildSubst (ctx |> PBound d) (es |> SVar (len ctx)) ds $;

-- This performs simultaneous substitution of the variables in `e` with the
-- expressions in `sub`.
-- substExpr : list SExpr -> SExpr => SExpr
def substExpr (sub: nat): set;
theorem substExprVar (sub v e: nat):
  $ nth sub v = suc e -> substExpr sub @ (SVar v) = e $;
theorem substExprApp {x: nat} (sub f es: nat):
  $ substExpr sub @ (SApp f es) = SApp f (map (substExpr sub) es) $;

-- These mutually recursive functions perform the unfolding operation on
-- a single expression and a list of expressions, changing the context as more
-- dummy copies are added. Unfolding is performed from the inside out, and
-- definitions are not unfolded more than once, so it runs by structural
-- recursion on the term. (This is a bit verbose because I'm doing state monad
-- stuff without the abstraction.)
-- unfold : Env -> Ctx -> set TermID -> list SExpr -> (Ctx, list SExpr)
def unfold (env ctx u es: nat): nat;
-- unfold1 : Env -> Ctx -> set TermID -> SExpr -> (Ctx, SExpr)
def unfold1 (env ctx u e: nat): nat;
theorem unfold1Var (env ctx u v: nat):
  $ unfold1 env ctx u (SVar v) = ctx <> SVar v $;
theorem unfold1AppN (env ctx ctx2 u f es es2: nat):
  $ (~f e. u \/ getDef env f = 0) ->
    unfold env ctx u es = ctx2 <> es2 ->
    unfold1 env ctx u (SApp f es) = ctx2 <> SApp f es2 $;
theorem unfold1App (env ctx ctx2 ctx3 u f es es2 es3 ud uv: nat):
  $ f e. u -> getDef env f = suc (ud <> uv) ->
    unfold env ctx u es = ctx2 <> es2 ->
    buildSubst ctx2 es2 ud = ctx3 <> es3 ->
    unfold1 env ctx u (SApp f es) = ctx3 <> substExpr es3 @ uv $;
theorem unfold0 (env ctx u: nat):
  $ unfold env ctx u 0 = ctx <> 0 $;
theorem unfoldS (env ctx ctx2 ctx3 e e2 es es2 u: nat):
  $ unfold env ctx u e = ctx2 <> e2 ->
    unfold env ctx2 u es = ctx3 <> es2 ->
    unfold env ctx u (e : es) = ctx3 <> (e : es2) $;

-- A VExpr is a proof term.
-- A VHyp is a hypothesis step - a term is asserted from the local context.
-- Indexing is relative to the list of hypotheses to the theorem.
-- VHyp : HypID -> VExpr
def VHyp (n: nat): nat = $ b0 n $;
-- A VThm is a theorem application - a step follows from previous steps by
-- application of a theorem. The arguments give the theorem to apply, the list
-- of substitutions of expressions for the variables, and the list of subproofs
-- for the hypotheses to the theorem.
-- VThm : ThmID -> list SExpr -> list VExpr -> VExpr
def VThm (t es ps: nat): nat = $ b1 (t <> es <> ps) $;

-- Given a context, which contains bound variables and regular variables with
-- dependencies, we can construct a disjoint variable list by making all
-- bound variables distinct from each other, and all regular variables disjoint
-- from all previous bound variables, except those that are present in the
-- type dependencies to the variable. This function expresses the list as a
-- predicate.
-- DV : Ctx -> VarID -> VarID -> Bool
def DV (ctx u v: nat): wff;
theorem DV0 (u v: nat): $ ~ DV 0 u v $;
theorem DVBound (ctx s u v: nat):
  $ DV (ctx |> PBound s) u v <->
    DV ctx u v \/ (isBound ctx u /\ v = len ctx) $;
theorem DVReg (ctx s vs u v: nat):
  $ DV (ctx |> PReg s vs) u v <->
    DV ctx u v \/ (isBound ctx u /\ ~ u e. vs /\ v = len ctx) $;

-- The main proof checking function. This typechecks a VExpr and determines the
-- SExpr that it represents. At a hypothesis step, this is just looking up the
-- nth element in the list, and at a theorem step, we get the theorem data,
-- check that all the substituting expressions match the binders they are going
-- in for, check that all the disjoint variable conditions of the theorem
-- are honored by the substitution, and then check recursively that the
-- subproofs are okay and the return is what it should be.
-- VerifyProof : Env -> Ctx -> list SExpr -> VExpr -> SExpr -> Bool
def VerifyProof (env ctx hs pf ret: nat): wff;
theorem VerifyProofHyp (env ctx hs n ret: nat):
  $ VerifyProof env ctx hs (VHyp n) ret <-> nth n hs = suc ret $;
theorem VerifyProofThm (env ctx hs t es ps ret: nat)
  {hs2 args args2 ret2 u v p h e a e1 e2: nat}:
  $ VerifyProof env ctx hs (VThm t es ps) ret <-> E. args2 E. hs2 E. ret2
    (getThm env t = suc (args2 <> hs2 <> ret2) /\
      all2 e a (ExprBi env ctx e a) es args2 /\
      A. u A. v (DV args2 u v -> A. e1 A. e2
        (nth es u = suc e1 -> nth es v = suc e2 ->
          ~ (HasVar ctx e1 u /\ HasVar ctx e2 v))) /\
      all2 p h (VerifyProof env ctx hs p (substExpr es @ h)) ps hs2 /\
      substExpr es @ ret2 = ret) $;

-- A theorem is valid if it has a good signature, and when you unfold the
-- definitions in the signature, the result can be verified with `VerifyProof`.
-- ProofOk : Env -> Ctx -> list SExpr -> SExpr ->
--   set TermID -> list SortID -> VExpr -> Bool
def ProofOk (env args hs ret uf ds pf .args2 .hs2 .ret2: nat): wff =
$ Decl env (DThm args hs ret) /\ E. args2 E. hs2 E. ret2
  (unfold env args uf (hs |> ret) = args2 <> (hs2 |> ret2) /\
   VerifyProof env (appendDummies args2 ds) hs2 pf ret2) $;

-- The main recursion for the proof judgment on an environment. Here `env` are
-- the declarations that have already been processed and `e` are the
-- declarations we are still stepping through. `p` is a proof object whose
-- existence entails provability of the environment.
-- Proof : Env -> list Decl -> list ProofCmd -> Bool
def Proof (env e p: nat): wff;
theorem Proof0 (env e p: nat): $ Proof env e 0 <-> e = 0 $;
theorem ProofStepSort (env e p: nat) {sd e2: nat}:
  $ Proof env e (StepSort : p) <-> E. sd E. e2
    (e = DSort sd : e2 /\ Proof (env |> DSort sd) e2 p) $;
theorem ProofStepTerm (env e p: nat) {a r e2: nat}:
  $ Proof env e (StepTerm : p) <-> E. a E. r E. e2
    (e = DTerm a r : e2 /\ Proof (env |> DTerm a r) e2 p) $;
theorem ProofStepAxiom (env e p: nat) {a h r e2: nat}:
  $ Proof env e (StepAxiom : p) <-> E. a E. h E. r E. e2
    (e = DAxiom a h r : e2 /\
     Proof (env |> DAxiom a h r) e2 p) $;
theorem ProofProofDefStep (env e p a r d v: nat) (st: wff) {o e2: nat}:
  $ st -> (Proof env e (ProofDef a r d v st : p) <->
      DefOk env a r d v /\ E. o E. e2
      ((o = 0 \/ o = suc (d <> v)) /\ e = DDef a r o T. : e2 /\
      Proof (env |> DDef a r (suc (d <> v)) T.) e2 p)) $;
theorem ProofProofDef (env e p a r d v: nat) (st: wff):
  $ ~st -> (Proof env e (ProofDef a r d v st : p) <->
      DefOk env a r d v /\
      Proof (env |> DDef a r (suc (d <> v)) F.) e p) $;
theorem ProofProofThmStep (env e p a h r u d q: nat) (st: wff) {e2: nat}:
  $ st -> (Proof env e (ProofThm a h r u d q st : p) <->
      ProofOk env a h r u d q /\
      E. e2 (e = DThm a h r : e2 /\ Proof (env |> DThm a h r) e2 p)) $;
theorem ProofProofThm (env e p a h r u d q: nat) (st: wff):
  $ ~st -> (Proof env e (ProofThm a h r u d q st : p) <->
      ProofOk env a h r u d q /\ Proof (env |> DThm a h r) e p) $;

-- A specification is provable if it has a proof, which entails
-- providing all the omitted definitions and proving all the theorems in the
-- file.
-- ValidEnv : Env -> Bool
def ValidEnv (env .p: nat): wff = $ E. p Proof 0 env p $;


-------------
-- Parsing --
-------------

-- The string preamble. This is used for interfacing with
-- the real world, making concrete inputs and outputs.
strict free sort hex;
term x0: hex; term x1: hex; term x2: hex; term x3: hex;
term x4: hex; term x5: hex; term x6: hex; term x7: hex;
term x8: hex; term x9: hex; term xa: hex; term xb: hex;
term xc: hex; term xd: hex; term xe: hex; term xf: hex;

strict free sort char;
term ch: hex > hex > char;

strict free sort string;
term s0: string;
term s1: char > string;
term sadd: string > string > string; infixr sadd: $'+$ prec 50;

def scons (c: char) (s: string): string = $ s1 c '+ s $;
infixr scons: $':$ prec 51;

-- Peano translation functions. The sorts `hex`, `char`, `string`
-- are closed classes, but we can embed them in `nat` as lists
-- of numbers less than 256, and prove theorems on `nat` instead.
-- We have to introduce some axioms to deal with the coercion
-- functions though.

def d11: nat = $suc 10$; prefix d11: $11$ prec max;
def d12: nat = $suc 11$; prefix d12: $12$ prec max;
def d13: nat = $suc 12$; prefix d13: $13$ prec max;
def d14: nat = $suc 13$; prefix d14: $14$ prec max;
def d15: nat = $suc 14$; prefix d15: $15$ prec max;
def d16: nat = $suc 15$; prefix d16: $16$ prec max;

term h2n: hex > nat; coercion h2n: hex > nat;
axiom h2n0: $ x0 = 0 $;   axiom h2n1: $ x1 = 1 $;
axiom h2n2: $ x2 = 2 $;   axiom h2n3: $ x3 = 3 $;
axiom h2n4: $ x4 = 4 $;   axiom h2n5: $ x5 = 5 $;
axiom h2n6: $ x6 = 6 $;   axiom h2n7: $ x7 = 7 $;
axiom h2n8: $ x8 = 8 $;   axiom h2n9: $ x9 = 9 $;
axiom h2na: $ xa = 10 $;  axiom h2nb: $ xb = 11 $;
axiom h2nc: $ xc = 12 $;  axiom h2nd: $ xd = 13 $;
axiom h2ne: $ xe = 14 $;  axiom h2nf: $ xf = 15 $;

term c2n: char > nat; coercion c2n: char > nat;
axiom c2nch (h1 h2: hex): $ ch h1 h2 = h1 * 16 + h2 $;

term s2n: string > nat; coercion s2n: string > nat;
axiom s2ns0: $ s0 = 0 $;
axiom s2ns1 (c: char): $ s1 c = c : 0 $;
axiom s2nsadd (s t: string): $ s '+ t = s ++ t $;

-- Definition of ASCII, or at least the part of it we need
def _nl:     char = $ ch x0 xa $; -- "\n" newline character
def _cr:     char = $ ch x0 xd $; -- "\r" carriage return
def __:      char = $ ch x2 x0 $; -- " " space
def _dollar: char = $ ch x2 x4 $; -- "$" dollar sign
def _lparen: char = $ ch x2 x8 $; -- "(" left parenthesis
def _rparen: char = $ ch x2 x9 $; -- ")" right parenthesis
def _ast:    char = $ ch x2 xa $; -- "*" asterisk / multiplication symbol
def _hyphen: char = $ ch x2 xd $; -- "-" hyphen / minus sign
def _dot:    char = $ ch x2 xe $; -- "." dot / period / full stop
def _colon:  char = $ ch x3 xa $; -- ":" colon
def _semi:   char = $ ch x3 xb $; -- ";" semicolon
def _equal:  char = $ ch x3 xd $; -- "=" equal sign
def _gt:     char = $ ch x3 xe $; -- ">" greater than, right arrow
def _under:  char = $ ch x5 xf $; -- "_" underscore (note: __ is space)
def _lbrace: char = $ ch x7 xb $; -- "{" left brace / curly bracket
def _rbrace: char = $ ch x7 xd $; -- "}" right brace / curly bracket

-- Don't really need capitals except as a range
def _0: char = $ ch x3 x0 $;
def _1: char = $ ch x3 x1 $;
def _2: char = $ ch x3 x2 $;
def _3: char = $ ch x3 x3 $;
def _4: char = $ ch x3 x4 $;
def _5: char = $ ch x3 x5 $;
def _6: char = $ ch x3 x6 $;
def _7: char = $ ch x3 x7 $;
def _8: char = $ ch x3 x8 $;
def _9: char = $ ch x3 x9 $;

-- Don't really need capitals except as a range
def _A: char = $ ch x4 x1 $;
def _Z: char = $ ch x5 xa $;

-- Most of the lowercase alphabet, used in keywords
def _a: char = $ ch x6 x1 $;
def _b: char = $ ch x6 x2 $;
def _c: char = $ ch x6 x3 $;
def _d: char = $ ch x6 x4 $;
def _e: char = $ ch x6 x5 $;
def _f: char = $ ch x6 x6 $;
def _h: char = $ ch x6 x8 $;
def _i: char = $ ch x6 x9 $;
def _l: char = $ ch x6 xc $;
def _m: char = $ ch x6 xd $;
def _n: char = $ ch x6 xe $;
def _o: char = $ ch x6 xf $;
def _p: char = $ ch x7 x0 $;
def _r: char = $ ch x7 x2 $;
def _s: char = $ ch x7 x3 $;
def _t: char = $ ch x7 x4 $;
def _u: char = $ ch x7 x5 $;
def _v: char = $ ch x7 x6 $;
def _x: char = $ ch x7 x8 $;
def _z: char = $ ch x7 xa $;

-- Now we define the lexer:

def prefix (s t .x: nat): wff = $ E. x s ++ x = t $;

def maxPrefix (A: set) (s: nat): nat;
theorem maxPrefix0 {x: nat} (A: set) (s: nat):
  $ ~ (E. x (prefix x s /\ x e. A)) -> maxPrefix A s = 0 $;
theorem maxPrefixS {x y t: nat} (A: set) (s: nat):
  $ E. x (prefix x s /\ x e. A) ->
    E. x E. t (x ++ t = s /\ x e. A /\
          A. y (prefix x y /\ prefix y s /\ y e. A -> y = x) /\
          maxPrefix A s = suc (x <> t)) $;

def regexStar (R: set) (.s .t .L .x .y: nat): set =
$ opab s t (E. L (all2 x y (x <> y e. R) L t /\ s = ljoin L)) $;
def regexApp (R S: set) (.z .a .b .x .y: nat): set =
$ {z | E. x E. y E. a E. b (x <> a e. R /\ y <> b e. S /\
    z = (x ++ y) <> (a <> b))} $;
infixr regexApp: $<+>$ prec 75;
def regexPlus (R: set) (.x: nat): set =
$ regexStar R i^i {x | snd x != 0} $;
def regexOpt (R: set) (.s .t .y: nat): set =
$ sn 0 u. opab s t (E. y (s <> y e. R /\ t = suc y)) $;

-- The set of whitespace characters
-- white : set char
def white: nat = $ __ ; sn _nl $;

def regexLineComment (.x .y: nat): set =
$ (\ x, _hyphen : _hyphen : x ++ _nl : 0) '' {x | all {y | y != _nl} x} $;

def whitespace (.c: nat): set =
$ ((\ c, c : 0) '' white) u. regexLineComment $;

def regexMath (.x .y: nat): set =
$ (\ x, _dollar : x ++ _dollar : 0) '' {x | all {y | y != _dollar} x} $;

def IdentStart (.c: nat): set =
$ {c | (_a <= c /\ c <= _z) \/ (_A <= c /\ c <= _Z) \/ c = _under} $;

def digits (.c: nat): set = $ {c | _0 <= c /\ c <= _9} $;

def IdentRest (.c: nat): set = $ IdentStart u. digits $;

def regexIdent (.s .x .y .t: nat): set =
$ {s | E. x E. t (s = x : t /\ x e. IdentStart /\ all IdentRest t)} $;

def isNumber (.s .x .y .t: nat): set =
$ sn _0 u. {s | E. x E. t (s = x : t /\
  _1 <= x /\ x <= _9 /\ all digits t)} $;

def symbols: nat =
$ _ast ; _dot ; _colon ; _semi ; _lparen ; _rparen ;
  _gt ; _lbrace ; _rbrace ; sn _equal $;

def TK (s: nat): nat = $ b0 s $;
def MATH (s: nat): nat = $ b1 s $;

def Tokenize (s: nat): set;
theorem Tokenize0: $ Tokenize 0 == sn 0 $;
theorem TokenizeWS (s x: nat):
  $ s e. whitespace -> Tokenize (s ++ x) == Tokenize x $;
theorem TokenizeIdent {t: nat} (s x r: nat):
  $ maxPrefix regexIdent s = suc (x <> r) ->
    Tokenize s == (\ t, TK x : t) '' Tokenize r $;
theorem TokenizeNumber {t: nat} (s x r: nat):
  $ maxPrefix isNumber s = suc (x <> r) ->
    Tokenize s == (\ t, TK x : t) '' Tokenize r $;
theorem TokenizeSymbol {t: nat} (c x: nat):
  $ c e. symbols -> Tokenize (c : x) == (\ t, TK (c : 0) : t) '' Tokenize x $;
theorem TokenizeMath {t: nat} (s x: nat):
  $ s e. regexMath -> Tokenize (s ++ x) == (\ t, MATH s : t) '' Tokenize x $;


-- Now the parser:

def regexMap (F R: set): set = $ cnv F o. R $;
infixr regexMap: $<@>$ prec 100;

def regexAppL (R S: set) (.x: nat): set = $ (\ x, fst x) <@> (R <+> S) $;
infixl regexAppL: $<+$ prec 77;

def regexAppR (R S: set) (.x: nat): set = $ (\ x, snd x) <@> (R <+> S) $;
infixr regexAppR: $+>$ prec 76;

def parseTk (tk: string): set = $ sn (TK tk <> 0) $;
def parseOptTk (tk: string): set = $ regexOpt (parseTk tk) $;
def parseCh (c: char): set = $ parseTk (s1 c) $;

def _pure: string = $ _p ': _u ': _r ': _e ': s0 $;
def _strict: string = $ _s ': _t ': _r ': _i ': _c ': _t ': s0 $;
def _provable: string = $ _p ': _r ': _o ': _v ': _a ': _b ': _l ': _e ': s0 $;
def _free: string = $ _f ': _r ': _e ': _e ': s0 $;

def parseSortData: set =
$ (parseOptTk _pure <+> parseOptTk _strict) <+>
  (parseOptTk _provable <+> parseOptTk _free) $;

def parseIdent_ (.s: nat): set = $ (\ s, TK s <> s) '' regexIdent $;
def parseIdent (.x: nat): set = $ parseIdent_ i^i {x | snd x != s1 _under} $;

def ASTSort (x: nat): nat = $ b0 (b0 (b0 x)) $;
def ASTTerm (x: nat): nat = $ b0 (b0 (b1 x)) $;
def ASTAxiom (x: nat): nat = $ b0 (b1 (b0 x)) $;
def ASTDef (x: nat): nat = $ b0 (b1 (b1 x)) $;
def ASTThm (x: nat): nat = $ b1 (b0 (b0 x)) $;
def ASTIO (out x: nat): nat = $ b1 (b0 (b1 (out <> x))) $;
def ASTNota (x: nat): nat = $ b1 (b1 x) $;

def _sort: string = $ _s ': _o ': _r ': _t ': s0 $;
def parseSort (.x: nat): set = $ (\ x, ASTSort x) <@>
  (parseSortData <+> parseTk _sort +> parseIdent <+ parseCh _semi) $;

def parseType (.x: nat): set = $ (\ x, b0 x) <@>
  (parseIdent <+> regexStar parseIdent) $;
def parseFmla (.s: nat): set = $ ran (\ s, MATH s <> b1 s) $;
def parseTypeFmla: set = $ parseType u. parseFmla $;

def parseDummyId (.x: nat): set =
$ (\ x, b0 x) <@> parseIdent_ u.
  (\ x, b1 x) <@> (parseCh _dot +> parseIdent) $;

-- This throws all binders into a common parsed representation.
-- {x: set}     goes to    (0, b0 "x", b0 ("set", []))
-- (x: set)     goes to    (1, b0 "x", b0 ("set", []))
-- (x: set y)   goes to    (1, b0 "x", b0 ("set", ["y"]))
-- (x: $foo$)   goes to    (1, b0 "x", b1 "foo")
-- (_: $foo$)   goes to    (1, b0 "_", b1 "foo")
-- (.x: set)    goes to    (1, b1 "x", b0 ("set", []))

def parseCurlyBinder (.x .z: nat): set =
$ (\ z, map (\ x, 0 <> x <> snd z) (fst z)) <@>
  (parseCh _lbrace +> regexStar parseDummyId <+>
    parseCh _colon +> parseTypeFmla <+ parseCh _rbrace) $;
def parseRegBinder (.x .z: nat): set =
$ (\ z, map (\ x, 1 <> x <> snd z) (fst z)) <@>
  (parseCh _lparen +> regexStar parseDummyId <+>
    parseCh _colon +> parseTypeFmla <+ parseCh _rparen) $;
def parseBinder (.x .y: nat): set = $ parseCurlyBinder u. parseRegBinder $;

def parseBinders (.x .z: nat): set =
$ (\ x, ljoin x) <@> regexStar parseBinder $;

def parseArrows: set =
$ regexStar (parseTypeFmla <+ parseCh _gt) <+> parseTypeFmla $;

def parseBindersAndArrows (.x .z: nat): set =
$ (\ x, (fst x ++ map (\ z, (1 <> b0 (s1 _under) <> z)) (pi21 x)) <> pi22 x) <@>
  (parseBinders <+> parseCh _colon +> parseArrows) $;

def parseSimple (tk: string): set =
$ parseTk tk +> parseIdent <+> parseBindersAndArrows <+ parseCh _semi $;

def _term: string = $ _t ': _e ': _r ': _m ': s0 $;
def parseTerm (.x: nat): set = $ (\ x, ASTTerm x) <@> parseSimple _term $;

def _axiom: string = $ _a ': _x ': _i ': _o ': _m ': s0 $;
def parseAxiom (.x: nat): set = $ (\ x, ASTAxiom x) <@> parseSimple _axiom $;

def _theorem: string = $ _t ': _h ': _e ': _o ': _r ': _e ': _m ': s0 $;
def parseThm (.x: nat): set = $ (\ x, ASTThm x) <@> parseSimple _theorem $;

def _def: string = $ _d ': _e ': _f ': s0 $;
def parseDef (.x: nat): set = $ (\ x, ASTDef x) <@>
  (parseTk _theorem +> parseIdent <+> parseBinders <+>
    parseCh _colon +> parseType <+>
    regexOpt (parseCh _equal +> parseFmla) <+ parseCh _semi) $;

def NotaDelim (x: nat): nat = $ b0 (b0 x) $;
def NotaInfix (x y: nat): nat = $ b0 (b1 (b0 (x <> y))) $;
def NotaPfx (x: nat): nat = $ b0 (b1 (b1 x)) $;
def NotaCoe (x: nat): nat = $ b1 (b0 x) $;
def NotaGen (x: nat): nat = $ b1 (b1 x) $;

def _delimiter: string =
$ _d ': _e ': _l ': _i ': _m ': _i ': _t ': _e ': _r ': s0 $;
def parseDelim (.x: nat): set = $ (\ x, NotaDelim x) <@>
  (parseTk _delimiter +> parseFmla <+ parseCh _semi) $;

def stoi (x: nat): nat;
theorem stoi0: $ stoi 0 = 0 $;
theorem stoiS (s x: nat): $ stoi (s |> x) = stoi s * 10 + (x - _0) $;

def parseNumber (.s: nat): set = $ (\ s, TK s <> stoi s) '' isNumber $;

def _max: string = $ _m ': _a ': _x ': s0 $;
def parsePrec (.x: nat): set = $ parseTk _max u. (\ x, suc x) <@> parseNumber $;

def _prec: string = $ _p ': _r ': _e ': _c ': s0 $;
def parseSimpleNota (tk: string): set =
$ parseTk tk +> parseIdent <+> parseCh _colon +> parseFmla <+>
    parseTk _prec +> parsePrec <+ parseCh _semi $;

def _infixl: string = $ _i ': _n ': _f ': _i ': _x ': _l ': s0 $;
def _infixr: string = $ _i ': _n ': _f ': _i ': _x ': _r ': s0 $;
def _prefix: string = $ _p ': _r ': _e ': _f ': _i ': _x ': s0 $;
def parseInfixl (.x: nat): set = $ (\ x, NotaInfix 0 x) <@> parseSimpleNota _infixl $;
def parseInfixr (.x: nat): set = $ (\ x, NotaInfix 1 x) <@> parseSimpleNota _infixr $;
def parsePfx (.x: nat): set = $ (\ x, NotaPfx x) <@> parseSimpleNota _prefix $;

def _coercion: string = $ _c ': _o ': _e ': _r ': _c ': _i ': _o ': _n ': s0 $;
def parseCoe (.x: nat): set = $ (\ x, NotaCoe x) <@>
  (parseTk _coercion +> parseIdent <+>
   parseCh _colon +> parseIdent <+>
   parseCh _gt +> parseIdent <+> parseCh _semi) $;

def parseLiteral (.x: nat): set =
$ ((\ x, b0 x) <@> (parseCh _lparen +> parseFmla <+>
    parseCh _colon +> parsePrec <+ parseCh _rparen)) u.
  ((\ x, b1 x) <@> parseIdent) $;

def _notation: string = $ _n ': _o ': _t ': _a ': _t ': _i ': _o ': _n ': s0 $;
def parseGenNota (.x: nat): set = $ (\ x, NotaCoe x) <@>
  (parseTk _notation +> parseIdent <+>
   parseBinders <+> parseCh _colon +> parseType <+>
   parseCh _equal +> regexPlus parseLiteral <+ parseCh _semi) $;

def parseNota (.x: nat): set = $ (\ x, ASTNota x) <@>
  (parseDelim u. parseInfixl u. parseInfixr u. parsePfx u.
    parseCoe u. parseGenNota) $;

def _input: string = $ _i ': _n ': _p ': _u ': _t ': s0 $;
def _output: string = $ _o ': _u ': _t ': _p ': _u ': _t ': s0 $;

def inputKinds: nat = $0$;
def outputKinds: nat = $0$;

def parseIO1 (tk: string) (k .x .s: nat): set =
$ parseTk tk +> (parseIdent i^i {x | snd x e. k}) <+>
  parseCh _colon +>
    regexStar (((\ s, TK s) <@> parseIdent) u. ran (\ s, MATH s <> MATH s))
    <+ parseCh _semi $;

def parseIO (.x: nat): set =
$ ((\ x, ASTIO 0 x) <@> parseIO1 _input inputKinds) u.
  ((\ x, ASTIO 1 x) <@> parseIO1 _output outputKinds) $;

def parseAST: set =
$ regexStar (parseSort u. parseTerm u. parseAxiom u.
    parseThm u. parseDef u. parseNota u. parseIO) $;

def parse (s .tks .ast: nat): set =
$ {ast | E. tks (tks e. Tokenize s /\ tks <> ast e. parseAST)} $;

--------------------
-- AST Navigation --
--------------------

def getTermMap (ast: nat): nat;
theorem getTermMap0: $ getTermMap 0 = 0 $;
theorem getTermMapTerm (ast t: nat):
  $ getTermMap (ast |> ASTTerm t) =
    (fst t <> b0 (card (getTermMap ast))) ; getTermMap ast $;
theorem getTermMapDef (t ast: nat):
  $ getTermMap (ast |> ASTDef t) =
    (fst t <> b0 (card (getTermMap ast))) ; getTermMap ast $;
theorem getTermMapOther {a: nat} (ast s: nat):
  $ ~(E. a s = ASTTerm a \/ s = ASTDef a) ->
    getTermMap (ast |> s) = getTermMap ast $;

def lookupTerm (eac t: nat): nat;
theorem lookupTermS {f: nat} (env ast ctx t s: nat):
  $ lookupTerm (env <> ast <> ctx) t = suc s <->
    E. f (t <> f e. getTermMap ast /\ getTerm env f = suc s) $;

def lookupVar (ctx x: nat): nat;
theorem lookupVar0 (x: nat): $ lookupVar 0 x = 0 $;
theorem lookupVarEq (bis c x t: nat):
  $ lookupVar (bis |> (c <> x <> t)) x = suc (len bis) $;
theorem lookupVarNe (bis c x y t: nat): $ y != x ->
  lookupVar (bis |> (c <> x <> t)) y = lookupVar bis y $;

------------------
-- Math Parsing --
------------------

def nonemptyNonwhite (.s .c: nat): set =
$ {s | s != 0 /\ all {c | ~c e. white} s} $;

def simpleTokenize (s: nat): nat;
theorem simpleTokenize0: $ simpleTokenize 0 = 0 $;
theorem simpleTokenizeWS (c s: nat):
  $ c e. white -> simpleTokenize (c : s) = simpleTokenize s $;
theorem simpleTokenizeTk {y c: nat} (c s x r: nat):
  $ maxPrefix nonemptyNonwhite s = suc (x <> r) ->
    simpleTokenize s = x : simpleTokenize r $;

def getDelimiters (ast: nat): nat;
theorem getDelimiters0: $ getDelimiters 0 = 0 $;
theorem getDelimitersDelim (ast d: nat):
  $ getDelimiters (ast |> ASTNota (NotaDelim (b1 d))) ==
    getDelimiters ast u. lmems (simpleTokenize d) $;
theorem getDelimitersOther {d: nat} (ast t: nat):
  $ ~(E. d t = ASTNota (NotaDelim (b1 d))) ->
    getDelimiters (ast |> t) = getDelimiters ast $;

def delimitersOk (ast .x .y: nat): wff =
$ A. x A. y (x e. getDelimiters ast -> y e. getDelimiters ast ->
  prefix x y -> x = y) $;

def tokenizeFmla (ast f: nat): nat;
theorem tokenizeFmla0 (ast: nat): $ tokenizeFmla ast 0 = 0 $;
theorem tokenizeFmlaWS (ast c s: nat):
  $ c e. white -> tokenizeFmla ast (c : s) = tokenizeFmla ast s $;
theorem tokenizeFmlaDelim (ast x s t: nat):
  $ delimitersOk ast -> x e. getDelimiters ast -> s e. nonemptyNonwhite ->
    tokenizeFmla ast (s ++ x ++ t) =
    tokenizeFmla ast s ++ x : tokenizeFmla ast t $;
theorem tokenizeFmlaNoDelim {l x r: nat} (ast s s1 t: nat):
  $ delimitersOk ast -> maxPrefix nonemptyNonwhite s = suc (s1 <> t) ->
    ~(E. l E. x E. r (x e. getDelimiters ast /\ s1 = l ++ x ++ r)) ->
    tokenizeFmla ast s = s1 : tokenizeFmla ast t $;

def getPfx (ast: nat): nat;
theorem getPfxEl {fmla: nat} (ast x c p: nat):
  $ x <> c <> p e. getPfx ast <-> E. fmla
    (ASTNota (NotaPfx (x <> b1 fmla <> p)) IN ast /\
     simpleTokenize fmla = c : 0) $;

def getInfix (ast r: nat): nat;
theorem getInfixEl {fmla: nat} (ast r x c p: nat):
  $ x <> c <> p e. getInfix ast r <-> E. fmla
    (ASTNota (NotaInfix r (x <> b1 fmla <> p)) IN ast /\
     simpleTokenize fmla = c : 0) $;

def getNota (ast: nat): nat;
theorem getNotaEl (ast x y: nat):
  $ x <> y e. getNota ast <-> ASTNota (NotaGen (x <> y)) IN ast $;

def getCoe (ast: nat): nat;
theorem getCoeEl (ast x y: nat):
  $ x <> y e. getCoe ast <-> ASTNota (NotaCoe (x <> y)) IN ast $;

def precle (m n: nat): wff; infixl precle: $<=p$ prec 50;
theorem precle02 (n: nat): $ n <=p 0 $;
theorem precle01 (m: nat): $ ~ 0 <=p suc m $;
theorem precleS (m n: nat): $ suc m <=p suc n <-> m <= n $;

def precSuc (n: nat): nat;
theorem precSuc0: $ precSuc 0 = 0 $;
theorem precSucS (n: nat): $ precSuc (suc n) = suc (suc n) $;

def litsPrec (lits q: nat): nat;
theorem litsPrec0 (q: nat): $ litsPrec 0 q = q $;
theorem litsPrecC (c p lits q: nat):
  $ litsPrec (b0 (c <> p) : lits) q = precSuc p $;
theorem litsPrecV (v lits q: nat):
  $ litsPrec (b1 v : lits) q = 0 $;

-- This is a more precise version of SExpr that allows reconstructing an
-- exact token string from a parse proof
def PTParens (x: nat): nat = $ b0 (b0 (b0 x)) $;
def PTVar (v: nat): nat = $ b0 (b0 (b1 v)) $;
def PTFunc (f x: nat): nat = $ b0 (b1 (f <> x)) $;
def PTPfx (f c x: nat): nat = $ b1 (b0 (b0 (f <> c <> x))) $;
def PTNota (f x: nat): nat = $ b1 (b0 (b1 (f <> x))) $;
def PTInfix (r f c x y: nat): nat =
  $ b1 (b1 (b0 (r <> f <> c <> (x : y : 0)))) $;
def PTCoe (f x: nat): nat = $ b1 (b1 (b1 (f <> x))) $;

def ptToStr (pt: nat): nat;
theorem ptToStrParens {s: nat} (e: nat):
  $ ptToStr (PTParens e) = s1 _lparen : ptToStr e ++ s1 _rparen : 0 $;
theorem ptToStrVar (v: nat): $ ptToStr (PTVar v) = v : 0 $;
theorem ptToStrFunc {s: nat} (f x: nat): $ ptToStr (PTFunc f x) =
  f : ljoin (map (\ s, ptToStr s) x) $;
theorem ptToStrPfx {s: nat} (f c x: nat): $ ptToStr (PTPfx f c x) =
  c : ljoin (map (\ s, ptToStr s) x) $;
theorem ptToStrInfix (r f c x y: nat):
  $ ptToStr (PTInfix r f c x y) = ptToStr x ++ c : ptToStr y $;
theorem ptToStrNota {y: nat} (f x: nat):
  $ ptToStr (PTNota f x) =
    ljoin (map (case (\ y, y : 0) (\ y, ptToStr y)) x) $;
theorem ptToStrCoe {y: nat} (f x: nat):
  $ ptToStr (PTCoe f x) = ptToStr x $;

def ptCheck (eac p pt e: nat): wff;
def ptCheckNotaLs (eac bis pts xs es p: nat): wff;

theorem ptCheckParens (eac p pt e: nat):
  $ ptCheck eac p (PTParens pt) e <->
    ptCheck eac (suc 0) pt e $;
theorem ptCheckVar {n: nat} (eac p v e: nat): $ ptCheck eac p (PTVar v) e <->
  E. n (lookupVar (pi22 eac) v = suc n /\ e = SVar n) $;
theorem ptCheckFunc {f2 td e2 x y: nat} (env ast ctx p f xs e: nat):
  $ ptCheck (env <> ast <> ctx) p (PTFunc f xs) e <->
    suc (2 ^ 10) <=p p /\ E. f2 E. td E. e2
    (f <> f2 e. getTermMap ast /\ getTerm env f = suc td /\
      len xs = len (fst td) /\
      all2 x y (ptCheck (env <> ast <> ctx) 0 x y) xs e2 /\
      e = SApp f2 e2) $;
theorem ptCheckPfx {l z f2 q es2 e2 x y: nat} (eac p f c xs e: nat):
  $ ptCheck eac p (PTPfx f c xs) e <->
    E. l E. z E. f2 E. q E. es2 E. e2 (xs = l |> z /\
      f <> f2 e. getTermMap (pi21 eac) /\
      f <> c <> q e. getPfx (pi21 eac) /\ q <=p p /\
      all2 x y (ptCheck eac 0 x y) l es2 /\ ptCheck eac q z e2 /\
      e = SApp f2 (es2 |> e2)) $;
theorem ptCheckInfix {f2 q e1 e2: nat} (eac p r f c x y e: nat):
  $ ptCheck eac p (PTInfix r f c x y) e <->
    E. f2 E. q E. e1 E. e2 (f <> f2 e. getTermMap (pi21 eac) /\
      f <> c <> q e. getInfix (pi21 eac) r /\ q <=p p /\
      ptCheck eac (if (r = 0) q (precSuc q)) x e1 /\
      ptCheck eac (if (r = 0) (precSuc q) q) y e2 /\
      e = SApp f2 (e1 : e2 : 0)) $;
theorem ptCheckNota {f2 bis ty c q lits es: nat} (eac p f xs e: nat):
  $ ptCheck eac p (PTNota f xs) e <->
    E. f2 E. bis E. ty E. c E. q E. lits E. es (
      f <> f2 e. getTermMap (pi21 eac) /\
      f <> bis <> ty <> (b0 (c <> q) : lits) e. getNota (pi21 eac) /\
      len xs = len es /\ ptCheckNotaLs eac bis lits xs es q /\
      e = SApp f2 es) $;
theorem ptCheckCoe {f2 y e2: nat} (eac p f x e: nat):
  $ ptCheck eac p (PTCoe f x) e <->
    E. f2 E. y E. e2 (f <> f2 e. getTermMap (pi21 eac) /\
      f <> y e. getCoe (pi21 eac) /\ ptCheck eac p x e2 /\
      e = SApp f2 e2) $;

theorem ptCheckNotaLs0 (eac bis xs es q: nat):
  $ ptCheckNotaLs eac bis 0 xs es q $;
theorem ptCheckNotaLsC (eac bis c p lits xs es q: nat):
  $ ptCheckNotaLs eac bis (b1 (c <> p) : lits) xs es q <->
    ptCheckNotaLs eac bis lits xs es q $;
theorem ptCheckNotaLsV {n x e: nat} (eac bis v lits xs es q: nat):
  $ ptCheckNotaLs eac bis (b0 v : lits) xs es q <->
    E. n E. x E. e (lookupVar bis v = suc n /\
      nth xs n = suc x /\ nth es n = suc e /\
      ptCheck eac (litsPrec lits q) x e /\
      ptCheckNotaLs eac bis lits xs es q) $;

def parseExpr (eac args f s .e .pt: nat): set =
$ {e | E. pt (ptToStr pt = f /\
  ptCheck eac 0 pt e /\ Expr (fst eac) args e s)} $;

def parseExprProv (eac args f .e .pt: nat): set =
$ {e | E. pt (ptToStr pt = f /\
  ptCheck eac 0 pt e /\ ExprProv (fst eac) args e)} $;

-----------------
-- Elaboration --
-----------------

-- Here we have to convert a parsed AST into an Env, and also
-- parse the math strings.

def getSortMap (ast: nat): nat;
theorem getSortMap0: $ getSortMap 0 = 0 $;
theorem getSortMapSort (ast sd x: nat):
  $ getSortMap (ast |> ASTSort (sd <> x)) =
    (x <> card (getSortMap ast)) ; getSortMap ast $;
theorem getSortMapOther {a: nat} (ast s: nat):
  $ ~(E. a s = ASTSort a) -> getSortMap (ast |> s) = getSortMap ast $;

def getSortID (ast x n: nat): wff = $ x <> n e. getSortMap ast $;

def splitDummies (bis: nat): nat;
theorem splitDummies0: $ splitDummies 0 = 0 $;
theorem splitDummiesL (bis bis1 bis2 c x t: nat): $
  splitDummies bis = bis1 <> bis2 ->
  splitDummies (bis |> (c <> b0 x <> t)) =
    (bis1 |> (c <> x <> t)) <> bis2 $;
theorem splitDummiesR (bis bis1 bis2 c x t: nat): $
  splitDummies bis = bis1 <> bis2 ->
  splitDummies (bis |> (c <> b1 x <> t)) = bis1 <> (bis2 |> (x <> t)) $;

def checkDummies (ds bis: nat): wff;
theorem checkDummies0 (bis: nat): $ checkDummies 0 bis <-> bis = 0 $;
theorem checkDummiesS {t2 bis2: nat} (bis x t ds: nat):
  $ checkDummies ((x <> t) : ds) bis <-> E. t2 E. bis2 (
      t = b0 (t2 <> 0) /\ checkDummies ds bis2 /\
      bis = (0 <> x <> t) : bis2) $;

def lookupVars (ctx .s .t: nat): set = $ opab s t (lookupVar ctx s = suc t) $;

def elabType (ast ctx s out .t .vs .t2 .vs2: nat): wff =
$ E. t E. vs E. t2 E. vs2 (s = b0 (t <> vs) /\ out = t2 <> vs2 /\
    t <> t2 e. getSortMap ast /\ vs2 == lookupVars ctx '' vs) $;

def elabTermBinder (ast ctx bi s: nat): wff;
theorem elabTermBinderFmla (ast ctx c x f s: nat):
  $ ~ elabTermBinder ast ctx (c <> x <> b1 f) s $;
theorem elabTermBinderBound {t2: nat} (ast ctx bi x t s: nat):
  $ elabTermBinder ast ctx (0 <> x <> b0 t) s <->
    E. t2 (elabType ast ctx t (t2 <> 0) /\ s = PBound t2) $;
theorem elabTermBinderReg {t2 vs2: nat} (ast ctx bi x t s: nat):
  $ elabTermBinder ast ctx (1 <> x <> b0 t) s <->
    E. t2 E. vs2 (elabType ast ctx t (t2 <> vs2) /\ s = PReg t2 vs2) $;

def elabTermBinders (ast ctx ctx2: nat): wff;
theorem elabTermBinders0 (ast ctx2: nat):
  $ elabTermBinders ast 0 ctx2 <-> ctx2 = 0 $;
theorem elabTermBindersS {ctx2 bi2: nat} (ast ctx bi ctx3: nat):
  $ elabTermBinders ast (ctx |> bi) ctx3 <->
    E. ctx2 (elabTermBinders ast ctx ctx2 /\
      elabTermBinder ast ctx bi bi2 /\ ctx3 = ctx2 |> bi2) $;

def elabFmla (env ast ctx args f e s .f2: nat): wff =
$ E. f2 (f = b1 f2 /\ parseExpr (env <> ast <> ctx) args f2 s == sn e) $;

def elabFmlaProv (env ast ctx args f e .f2: nat): wff =
$ E. f2 (f = b1 f2 /\ parseExprProv (env <> ast <> ctx) args f2 == sn e) $;

def elabHyps (env ast ctx args hyps hyps2 .hyp .hyp2 .x .f: nat): wff =
$ all2 hyp hyp2 (E. x E. f (hyp = 1 <> b0 x <> f /\
    elabFmlaProv env ast ctx args f hyp2)) hyps hyps2 $;

def elabDefO (env ast ctx s ds o o2: nat): wff;
theorem elabDefO0 (env ast ctx s ds o2: nat):
  $ elabDefO env ast ctx s ds 0 o2 <-> ds = 0 /\ o2 = 0 $;
theorem elabDefOS {args2 e: nat} (env ast ctx s ds f o2: nat):
  $ elabDefO env ast ctx s ds (suc f) o2 <-> E. args2 E. e (
      elabTermBinders ast (ctx ++ ds) args2 /\
      elabFmla env ast (ctx ++ ds) args2 f e s /\
      o2 = suc (ds <> e)) $;

def Elaborate (ast: nat): set;
theorem Elaborate0: $ Elaborate 0 == sn 0 $;
theorem ElaborateSort {e: nat} (ast sd x: nat):
  $ Elaborate (ast |> ASTSort (sd <> x)) ==
    (\ e, e |> DSort sd) '' Elaborate ast $;
theorem ElaborateTerm {e ctx args ret2: nat} (ast x bis ret e2: nat):
  $ e2 e. Elaborate (ast |> ASTTerm (x <> bis <> ret)) <->
    E. e E. ctx E. args E. ret2 (e e. Elaborate ast /\
      splitDummies bis = ctx <> 0 /\
      elabTermBinders ast ctx args /\
      elabType ast ctx ret ret2 /\
      e2 = e |> DTerm args ret2) $;
theorem ElaborateAxiom
  {e ctx hyps hyps2 args ret2: nat} (ast x bis ret e2: nat):
  $ e2 e. Elaborate (ast |> ASTAxiom (x <> bis <> ret)) <->
    E. e E. ctx E. hyps E. hyps2 E. args E. ret2 (e e. Elaborate ast /\
      splitDummies bis = (ctx ++ hyps) <> 0 /\
      elabTermBinders ast ctx args /\
      elabHyps e ast ctx args hyps hyps2 /\
      elabFmlaProv e ast ctx args ret ret2 /\
      e2 = e |> DAxiom args hyps2 ret2) $;
theorem ElaborateDef {e ctx ds ret2 ctx2 args o2: nat} (ast x bis ret o e2: nat):
  $ e2 e. Elaborate (ast |> ASTDef (x <> bis <> ret <> o)) <->
    E. e E. ctx E. ds E. ret2 E. ctx2 E. args E. o2 (
      e e. Elaborate ast /\
      splitDummies bis = ctx <> ds /\
      elabType ast ctx ret ret2 /\
      checkDummies ds ctx2 /\
      elabTermBinders ast ctx args /\
      elabDefO e ast ctx (fst ret2) ctx2 o o2 /\
      e2 = e |> DDef args ret2 o2 T.) $;
theorem ElaborateThm
  {e ctx hyps hyps2 args ret2: nat} (ast x bis ret e2: nat):
  $ e2 e. Elaborate (ast |> ASTThm (x <> bis <> ret)) <->
    E. e E. ctx E. hyps E. hyps2 E. args E. ret2 (e e. Elaborate ast /\
      splitDummies bis = (ctx ++ hyps) <> 0 /\
      elabTermBinders ast ctx args /\
      elabHyps e ast ctx args hyps hyps2 /\
      elabFmlaProv e ast ctx args ret ret2 /\
      e2 = e |> DThm args hyps2 ret2) $;
theorem ElaborateNota (ast n: nat):
  $ Elaborate (ast |> ASTNota n) == Elaborate ast $;
theorem ElaborateIO (ast out n: nat):
  $ Elaborate (ast |> ASTIO out n) == Elaborate ast $;

def Valid (s .ast .e: nat): wff =
$ E. ast E. e (ast e. parse s /\ e e. Elaborate ast /\ ValidEnv e) $;
