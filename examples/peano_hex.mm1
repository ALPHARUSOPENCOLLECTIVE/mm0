import "peano.mm1";

-- The string preamble. This is used for interfacing with
-- the real world, making concrete inputs and outputs.
strict free sort hex;
term x0: hex; term x1: hex; term x2: hex; term x3: hex;
term x4: hex; term x5: hex; term x6: hex; term x7: hex;
term x8: hex; term x9: hex; term xa: hex; term xb: hex;
term xc: hex; term xd: hex; term xe: hex; term xf: hex;

strict free sort char;
term ch: hex > hex > char;

strict free sort string;
term s0: string;
term s1: char > string;
term sadd: string > string > string; infixr sadd: $'+$ prec 51;

def scons (c: char) (s: string): string = $ s1 c '+ s $;
infixr scons: $':$ prec 53;

-- Peano translation functions. The sorts `hex`, `char`, `string`
-- are closed classes, but we can embed them in `nat` as lists
-- of numbers less than 256, and prove theorems on `nat` instead.
-- We have to introduce some axioms to deal with the coercion
-- functions though.

def d11: nat = $suc 10$; prefix d11: $11$ prec max;
def d12: nat = $suc 11$; prefix d12: $12$ prec max;
def d13: nat = $suc 12$; prefix d13: $13$ prec max;
def d14: nat = $suc 13$; prefix d14: $14$ prec max;
def d15: nat = $suc 14$; prefix d15: $15$ prec max;
def d16: nat = $suc 15$; prefix d16: $16$ prec max;

term h2n: hex > nat; coercion h2n: hex > nat;
axiom h2n0: $ x0 = 0 $;   axiom h2n1: $ x1 = 1 $;
axiom h2n2: $ x2 = 2 $;   axiom h2n3: $ x3 = 3 $;
axiom h2n4: $ x4 = 4 $;   axiom h2n5: $ x5 = 5 $;
axiom h2n6: $ x6 = 6 $;   axiom h2n7: $ x7 = 7 $;
axiom h2n8: $ x8 = 8 $;   axiom h2n9: $ x9 = 9 $;
axiom h2na: $ xa = 10 $;  axiom h2nb: $ xb = 11 $;
axiom h2nc: $ xc = 12 $;  axiom h2nd: $ xd = 13 $;
axiom h2ne: $ xe = 14 $;  axiom h2nf: $ xf = 15 $;

-- This allows us to prove facts about hex digits by case analysis.
-- It is not provable from the above axioms because the fact that the "hex"
-- sort has only the given 16 constructors is only observable from outside the theory.
axiom h2nlt (h: hex): $ h < 16 $;

term c2n: char > nat; coercion c2n: char > nat;
axiom c2nch (h1 h2: hex): $ ch h1 h2 = h1 * 16 + h2 $;
axiom c2nlt (c: char): $ c < 16 * 16 $;

term s2n: string > nat; coercion s2n: string > nat;
axiom s2ns0: $ s0 = 0 $;
axiom s2ns1 (c: char): $ s1 c = c : 0 $;
axiom s2nsadd (s t: string): $ s '+ t = s ++ t $;

local def hex (a: nat) (x: hex): nat = $ a * 16 + x $;
infixl hex: $:x$ prec 120;

theorem c2nhex (h1 h2: hex): $ ch h1 h2 = h1 :x h2 $ = 'c2nch;

do {
  (def (map-16 v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 va vb vc vd ve vf) @ fn (n)
    (if {n < 8}
      (if {n < 4}
        (match n [0 v0] [1 v1] [2 v2] [3 v3])
        (match n [4 v4] [5 v5] [6 v6] [7 v7]))
      (if {n < 12}
        (match n [8 v8] [9 v9] [10 va] [11 vb])
        (match n [12 vc] [13 vd] [14 ve] [15 vf]))))
  (def hexstrings (map ->string '(0 1 2 3 4 5 6 7 8 9 a b c d e f)))
  (def (on-hexstrings f) (apply map-16 (map f hexstrings)))
  (def hexstring @ on-hexstrings @ fn (s) s)
  (def hexdigit @ on-hexstrings @ fn (s) (atom-app 'x s))
  (def h2nn @ on-hexstrings @ fn (s) (atom-app 'h2n s))
  (def (->hex n)
    (if {n >= 16} (list 'hex (->hex {n // 16}) (hexdigit {n % 16}))
      '(h2n ,(hexdigit n))))
  (def ->expr @ match-fn [(? number? e) (->hex e)] [e e])
  (def hexdigit->number
    (def m
      @ letrec ([(f n) @ if {n < 16} '((,(hexdigit n) ,n) . ,(f {n + 1})) ()])
      (apply atom-map (f 0)))
    (fn (x) (lookup m x)))
  (def hex->number @ match-fn
    ['(c2n ,e) (hex->number e)]
    ['(ch ,e1 ,e2) {{(hex->number e1) * 16} + (hex->number e2)}]
    ['(hex ,e1 ,e2) {{(hex->number e1) * 16} + (hex->number e2)}]
    [e (hexdigit->number e)])
  (def nz-hexnat? @ match-fn
    ['()])
};

-- Defines e.g. theorem deca: $ 10 = xa $; for all n < 16, accessible as (decn 10)
do {
  (def (dn n) (atom-app 'd @ ->string n))
  (def decn @ on-hexstrings @ fn (n)
    @ let ([xn (atom-app 'x n)] [i (hex->number xn)]
           [dn '(,(dn i))] [xn '(h2n (,xn))] [name (atom-app 'dec n)])
    (add-thm! name () () '(eq ,dn ,xn) () @ fn ()
      '(() (eqcomi ,xn ,dn (,(h2nn i)))))
    name)
};

-- Defines e.g. theorem decsuca: $ suc xa = xb $; for all n < 15, accessible as (decsucn 10)
theorem decsuc_lem (h1: $ h2n a = d $) (h2: $ h2n b = suc d $): $ suc a = b $ = '(eqtr4 (suceq h1) h2);
do {
  (def decsucn @ on-hexstrings @ fn (s)
    @ let ([xi (atom-app 'x s)] [i (hex->number xi)])
    @ if {i < 15}
    @ let ([j {i + 1}] [xi '(,xi)] [xj '(,(hexdigit j))] [name (atom-app 'decsuc s)])
    (add-thm! name () () '(eq (suc (h2n ,xi)) (h2n ,xj)) () @ fn ()
      @ let ([di '(,(dn i))] [sdi '(suc ,di)])
      '(() (decsuc_lem ,xi ,xj ,di (,(h2nn i))
        (:conv (eq (h2n ,xj) ,sdi) (eq (h2n ,xj) (:sym (:unfold ,(dn j) () ,sdi))) (,(h2nn j))))))
    name)
};

-- Defines e.g. theorem declt4a: $ x4 < xa $; for all a < b <= 15, accessible as (decltn 4 10)
theorem declt_lem (a b: hex) (h: $ suc a = b $): $ a < b $ = '(mpbi (lteq2 h) ltsucid);
do {
  (def (decltn m n) @ if {m < n} (atom-app 'declt (hexstring m) (hexstring n)))
  (begin
    (def (f a b g)
      @ let ([xa (hexdigit a)] [xb (hexdigit b)] [name (decltn a b)])
      (add-thm! name () () '(lt (h2n (,xa)) (h2n (,xb))) () g)
      name)
    (for 0 15 @ fn (a) (def b {a + 1}) @ f a b @ fn ()
      '(() (declt_lem (,(hexdigit a)) (,(hexdigit b)) (,(decsucn a)))))
    (for 0 14 @ fn (a) @ for {a + 1} 15 @ fn (b) (def c {b + 1}) @ f a c @ fn ()
      (def (h a) '(h2n (,(hexdigit a))))
      '(() (lttri ,(h a) ,(h b) ,(h c) (,(decltn a b)) (,(decltn b c))))))
};
