delimiter $ ( [ { ~ , $
          $ } ] ) , $;
strict provable sort wff;
term im (ph ps: wff): wff; infixr im: $->$ prec 25;
term not (ph: wff): wff; prefix not: $~$ prec 40;

axiom ax_1 (ph ps: wff): $ ph -> ps -> ph $;
axiom ax_2 (ph ps ch: wff): $ (ph -> ps -> ch) -> (ph -> ps) -> ph -> ch $;
axiom ax_3 (ph ps: wff): $ (~ph -> ~ps) -> ps -> ph $;
axiom ax_mp (ph ps: wff): $ ph $ > $ ph -> ps $ > $ ps $;

do {
  (set-timeout 500)
  (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
  (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
  (def (rev l) (foldl l () (fn (l a) (cons a l))))
  (def (verb e) (list ':verb e))
  (def (exact e) (refine (verb e)))
  (def refine-extra-args-orig refine-extra-args)
  (def (refine-extra-args refine p . ps)
    (foldl ps p
      (fn (acc p2)
        (refine (list 'ax_mp (verb p2) (verb acc))))))
  (def (result) (hd (get-goals)))
  (def (target) (goal-type (result)))
};

theorem a1i (h: $ b $): $ a -> b $ = '(ax_1 h);
theorem a2i (h: $ a -> b -> c $): $ (a -> b) -> (a -> c) $ = '(ax_2 h);
theorem mpd (h1: $ a -> b $) (h2: $ a -> b -> c $): $ a -> c $ = '(ax_2 h2 h1);
theorem mpi (h1: $ b $) (h2: $ a -> b -> c $): $ a -> c $ = '(mpd (a1i h1) h2);
theorem id: $ a -> a $ = '(mpd (! ax_1 _ a) ax_1);
theorem idd: $ a -> b -> b $ = '(a1i id);
theorem syl (h1: $ a -> b $) (h2: $ b -> c $): $ a -> c $ = '(mpd h1 (a1i h2));
theorem a1d (h: $ a -> b $): $ a -> c -> b $ = '(syl h ax_1);
theorem a2d (h: $ a -> b -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl h ax_2);
theorem a3d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl h ax_3);
theorem sylc (h1: $ a -> b $) (h2: $ a -> c $) (h: $ b -> c -> d $): $ a -> d $ = '(mpd h2 (syl h1 h));
theorem syld (h1: $ a -> b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(mpd h1 (a2d (a1d h2)));
theorem syl5 (h1: $ b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syld (a1i h1) h2);
theorem syl6 (h1: $ a -> b -> c $) (h2: $ c -> d $): $ a -> b -> d $ = '(syld h1 (a1i h2));
theorem imim2: $ (b -> c) -> (a -> b) -> (a -> c) $ = '(a2d ax_1);
theorem imim2i (h: $ b -> c $): $ (a -> b) -> (a -> c) $ = '(imim2 h);
theorem imim2d (h: $ a -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl h imim2);
theorem absurd: $ ~a -> a -> b $ = '(a3d ax_1);
theorem com12 (h: $ a -> b -> c $): $ b -> a -> c $ = '(syl ax_1 (a2i h));
theorem absurdr: $ a -> ~a -> b $ = '(com12 absurd);
theorem imim1: $ (a -> b) -> (b -> c) -> (a -> c) $ = '(com12 imim2);
theorem imim1i (h: $ a -> b $): $ (b -> c) -> (a -> c) $ = '(imim1 h);
theorem imim1d (h: $ a -> b -> c $): $ a -> (c -> d) -> (b -> d) $ = '(syl h imim1);
theorem imimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $):
  $ a -> (c -> d) -> (b -> e) $ = '(syld (imim1d h1) (imim2d h2));
theorem imidm: $ (a -> a -> b) -> a -> b $ = '(a2i (com12 id));
theorem contra: $ (~a -> a) -> a $ = '(imidm (a3d (a2i absurd)));
theorem dne: $ ~~a -> a $ = '(syl absurd contra);
theorem inot: $ (a -> ~a) -> ~a $ = '(syl (imim1 dne) contra);
theorem con2: $ (a -> ~b) -> (b -> ~a) $ = '(a3d (syl5 dne id));
theorem notnot1: $ a -> ~~a $ = '(con2 id);
theorem con3: $ (a -> b) -> (~b -> ~a) $ = '(syl (imim2i notnot1) con2);
theorem con1: $ (~a -> b) -> (~b -> a) $ = '(a3d (imim2i notnot1));
theorem cases (h1: $ a -> b $) (h2: $ ~a -> b $): $ b $ = '(contra (syl (con1 h2) h1));
theorem casesd (h1: $ a -> b -> c $) (h2: $ a -> ~b -> c $): $ a -> c $ =
'(cases (com12 h1) (com12 h2));
theorem con1d (h: $ a -> ~b -> c $): $ a -> ~c -> b $ = '(syl h con1);
theorem con2d (h: $ a -> b -> ~c $): $ a -> c -> ~b $ = '(syl h con2);
theorem con3d (h: $ a -> b -> c $): $ a -> ~c -> ~b $ = '(syl h con3);
theorem con4d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl h ax_3);
theorem mt (h1: $ ~a $) (h2: $ b -> a $): $ ~b $ = '(con3 h2 h1);
theorem mtd (h1: $ a -> ~b $) (h2: $ a -> c -> b $): $ a -> ~c $ = '(mpd h1 (con3d h2));
theorem mt2d (h1: $ a -> c $) (h2: $ a -> b -> ~c $): $ a -> ~b $ = '(sylc h2 h1 con2);

def an (a b: wff): wff = $ ~(a -> ~b) $;
infixl an: $/\$ prec 35;

theorem anl: $ a /\ b -> a $ = '(con1 absurd);
theorem anr: $ a /\ b -> b $ = '(con1 ax_1);
theorem ian: $ a -> b -> a /\ b $ = '(syl (com12 id) con2);
theorem iand (h1: $ a -> b $) (h2: $ a -> c $): $ a -> b /\ c $ = '(sylc h1 h2 ian);
theorem iani (h1: $ a $) (h2: $ b $): $ a /\ b $ = '(ian h1 h2);
theorem anwl (h: $ a -> c $): $ a /\ b -> c $ = '(syl anl h);
theorem anwr (h: $ b -> c $): $ a /\ b -> c $ = '(syl anr h);
theorem imp (h: $ a -> b -> c $): $ a /\ b -> c $ = '(sylc anl anr h);
theorem exp (h: $ a /\ b -> c $): $ a -> b -> c $ = '(syl6 ian h);
theorem impcom (h: $ a -> b -> c $): $ b /\ a -> c $ = '(imp (com12 h));
theorem expcom (h: $ a /\ b -> c $): $ b -> a -> c $ = '(com12 (exp h));
theorem animd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b /\ d -> c /\ e $ =
'(exp (iand (imp (syl5 anl h1)) (imp (syl5 anr h2))));
theorem anim1d (h: $ a -> b -> c $): $ a -> b /\ d -> c /\ d $ = '(animd h idd);
theorem anim2d (h: $ a -> c -> d $): $ a -> b /\ c -> b /\ d $ = '(animd idd h);
theorem ancom: $ a /\ b -> b /\ a $ = '(iand anr anl);
theorem casesda (h1: $ a /\ b -> c $) (h2: $ a /\ ~b -> c $): $ a -> c $ =
'(casesd (exp h1) (exp h2));
theorem inotda (h: $ a /\ b -> ~b $): $ a -> ~b $ = '(syl (exp h) inot);

def iff (a b: wff): wff = $ (a -> b) /\ (b -> a) $;
infixl iff: $<->$ prec 20;

theorem bi1: $ (a <-> b) -> a -> b $ = 'anl;
theorem bi1i (h: $ a <-> b $): $ a -> b $ = '(bi1 h);
theorem bi1d (h: $ a -> (b <-> c) $): $ a -> b -> c $ = '(syl h bi1);
theorem bi2: $ (a <-> b) -> b -> a $ = 'anr;
theorem bi2i (h: $ a <-> b $): $ b -> a $ = '(bi2 h);
theorem bi2d (h: $ a -> (b <-> c) $): $ a -> c -> b $ = '(syl h bi2);
theorem ibii (h1: $ a -> b $) (h2: $ b -> a $): $ a <-> b $ = '(iani h1 h2);
theorem ibid (h1: $ a -> b -> c $) (h2: $ a -> c -> b $): $ a -> (b <-> c) $ = '(iand h1 h2);
theorem biid: $ a <-> a $ = '(ibii id id);
theorem biidd: $ a -> (b <-> b) $ = '(a1i biid);
theorem mpbi (h1: $ a $) (h2: $ a <-> b $): $ b $ = '(bi1i h2 h1);
theorem mpbir (h1: $ a $) (h2: $ b <-> a $): $ b $ = '(bi2i h2 h1);
theorem mpbid (h1: $ a -> b $) (h2: $ a -> (b <-> c) $): $ a -> c $ = '(mpd h1 (bi1d h2));
theorem mpbird (h1: $ a -> b $) (h2: $ a -> (c <-> b) $): $ a -> c $ = '(mpd h1 (bi2d h2));
theorem mpbii (h1: $ b $) (h2: $ a -> (b <-> c) $): $ a -> c $ = '(mpbid (a1i h1) h2);
theorem mpbiri (h1: $ b $) (h2: $ a -> (c <-> b) $): $ a -> c $ = '(mpbird (a1i h1) h2);
theorem mtbi (h1: $ ~a $) (h2: $ a <-> b $): $ ~b $ = '(mt h1 (bi2 h2));
theorem mtbir (h1: $ ~a $) (h2: $ b <-> a $): $ ~b $ = '(mt h1 (bi1 h2));
theorem con1b: $ (~a <-> b) -> (~b <-> a) $ = '(ibid (con1d bi1) (con2d bi2));
theorem con2b: $ (a <-> ~b) -> (b <-> ~a) $ = '(ibid (con2d bi1) (con1d bi2));
theorem con3b: $ (a <-> b) -> (~a <-> ~b) $ = '(ibid (con3d bi2) (con3d bi1));
theorem con4b: $ (~a <-> ~b) -> (a <-> b) $ = '(ibid (con4d bi2) (con4d bi1));
theorem notnot: $ a <-> ~~a $ = '(ibii notnot1 dne);
theorem bithd (h1: $ a -> b $) (h2: $ a -> c $): $ a -> (b <-> c) $ = '(ibid (a1d h2) (a1d h1));
theorem binthd (h1: $ a -> ~b $) (h2: $ a -> ~c $): $ a -> (b <-> c) $ = '(syl (bithd h1 h2) con4b);
theorem bicom: $ (a <-> b) -> (b <-> a) $ = '(ibid bi2 bi1);
theorem bicomd (h: $ a -> (b <-> c) $): $ a -> (c <-> b) $ = '(syl h bicom);
theorem bitrd (h1: $ a -> (b <-> c) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ =
'(ibid (syld (bi1d h1) (bi1d h2)) (syld (bi2d h2) (bi2d h1)));
theorem bitr3d (h1: $ a -> (c <-> b) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (bicomd h1) h2);
theorem bitr4d (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> c) $): $ a -> (b <-> d) $ = '(bitrd h1 (bicomd h2));
theorem bitr: $ (a <-> b) -> (b <-> c) -> (a <-> c) $ = '(exp (bitrd anl anr));
theorem bitr3: $ (b <-> a) -> (b <-> c) -> (a <-> c) $ = '(exp (bitr3d anl anr));
theorem bitr4: $ (a <-> b) -> (c <-> b) -> (a <-> c) $ = '(exp (bitr4d anl anr));
theorem sylib (h1: $ a -> b $) (h2: $ b <-> c $): $ a -> c $ = '(syl h1 (bi1i h2));
theorem sylibr (h1: $ a -> b $) (h2: $ c <-> b $): $ a -> c $ = '(syl h1 (bi2i h2));
theorem sylbi (h1: $ a <-> b $) (h2: $ b -> c $): $ a -> c $ = '(syl (bi1i h1) h2);
theorem sylbir (h1: $ b <-> a $) (h2: $ b -> c $): $ a -> c $ = '(syl (bi2i h1) h2);
theorem syl5bb (h1: $ b <-> c $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (a1i h1) h2);
theorem syl6bb (h1: $ a -> (b <-> c) $) (h2: $ c <-> d $): $ a -> (b <-> d) $ = '(bitrd h1 (a1i h2));
theorem syl5bi (h1: $ b <-> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syl5 (bi1 h1) h2);
theorem syl6ibr (h1: $ a -> b -> c $) (h2: $ d <-> c $): $ a -> b -> d $ = '(syl6 h1 (bi2 h2));
theorem bitr3g (h1: $ a -> (b <-> c) $) (h2: $ b <-> d $) (h3: $ c <-> e $):
  $ a -> (d <-> e) $ = '(syl5bb (bicom h2) (syl6bb h1 h3));
theorem bitr4g (h1: $ a -> (b <-> c) $) (h2: $ d <-> b $) (h3: $ e <-> c $):
  $ a -> (d <-> e) $ = '(syl5bb h2 (syl6bb h1 (bicom h3)));
theorem bitr3gi (h1: $ a <-> b $) (h2: $ a <-> c $) (h3: $ b <-> d $): $ c <-> d $ = '(bitr3 h2 (bitr h1 h3));
theorem bitr4gi (h1: $ a <-> b $) (h2: $ c <-> a $) (h3: $ d <-> b $): $ c <-> d $ = '(bitr h2 (bitr4 h1 h3));
theorem impbi (h: $ a -> (b <-> c) $): $ a /\ b -> c $ = '(imp (bi1d h));
theorem impbir (h: $ a -> (c <-> b) $): $ a /\ b -> c $ = '(imp (bi2d h));
theorem notbi: $ (a <-> b) -> (~a <-> ~b) $ = 'con3b;
theorem notbii (h: $ a <-> b $): $ ~a <-> ~b $ = '(notbi h);
theorem notbid (h: $ a -> (b <-> c) $): $ a -> (~b <-> ~c) $ = '(syl h notbi);
theorem imbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b -> d <-> c -> e) $ =
'(ibid (imimd (bi2d h1) (bi1d h2)) (imimd (bi1d h1) (bi2d h2)));
theorem imbi1d (h: $ a -> (b <-> c) $): $ a -> (b -> d <-> c -> d) $ = '(imbid h biidd);
theorem imbi2d (h: $ a -> (c <-> d) $): $ a -> (b -> c <-> b -> d) $ = '(imbid biidd h);
theorem imbi1i (h: $ a <-> b $): $ a -> c <-> b -> c $ = '(imbi1d id h);
theorem imbi2i (h: $ b <-> c $): $ a -> b <-> a -> c $ = '(imbi2d id h);
theorem imbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a -> c <-> b -> d $ = '(bitr (imbi1i h1) (imbi2i h2));
theorem anbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b /\ d <-> c /\ e) $ =
'(ibid (animd (bi1d h1) (bi1d h2)) (animd (bi2d h1) (bi2d h2)));
theorem anbi1d (h: $ a -> (b <-> c) $): $ a -> (b /\ d <-> c /\ d) $ = '(anbid h biidd);
theorem anbi2d (h: $ a -> (c <-> d) $): $ a -> (b /\ c <-> b /\ d) $ = '(anbid biidd h);
theorem anbi1i (h: $ a <-> b $): $ a /\ c <-> b /\ c $ = '(anbi1d id h);
theorem anbi2i (h: $ b <-> c $): $ a /\ b <-> a /\ c $ = '(anbi2d id h);
theorem bibid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> ((b <-> d) <-> (c <-> e)) $ =
'(anbid (imbid h1 h2) (imbid h2 h1));
theorem bibi1d (h: $ a -> (b <-> c) $): $ a -> ((b <-> d) <-> (c <-> d)) $ = '(bibid h biidd);
theorem bibi2d (h: $ a -> (c <-> d) $): $ a -> ((b <-> c) <-> (b <-> d)) $ = '(bibid biidd h);
theorem bibi: $ (a <-> b) -> (c <-> d) -> ((a <-> c) <-> (b <-> d)) $ = '(exp (bibid anl anr));

def or (a b: wff): wff = $ ~a -> b $;
infixl or: $\/$ prec 30;

theorem orl: $ a -> a \/ b $ = 'absurdr;
theorem orr: $ b -> a \/ b $ = 'ax_1;
theorem eori (h1: $ a -> c $) (h2: $ b -> c $): $ a \/ b -> c $ =
'(casesd (a1i h1) (imim2i h2));
theorem eord (h1: $ a -> b -> d $) (h2: $ a -> c -> d $):
  $ a -> b \/ c -> d $ = '(com12 (eori (com12 h1) (com12 h2)));
theorem orld (h: $ a -> b $): $ a -> b \/ c $ = '(syl h orl);
theorem orrd (h: $ a -> c $): $ a -> b \/ c $ = '(syl h orr);
theorem eor: $ (a -> c) -> (b -> c) -> a \/ b -> c $ = '(exp (eord anl anr));
theorem orimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b \/ d -> c \/ e $ =
'(eord (syl6 h1 orl) (syl6 h2 orr));
theorem orim1d (h: $ a -> b -> c $): $ a -> b \/ d -> c \/ d $ = '(orimd h idd);
theorem orim2d (h: $ a -> c -> d $): $ a -> b \/ c -> b \/ d $ = '(orimd idd h);
theorem orbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b \/ d <-> c \/ e) $ =
'(ibid (orimd (bi1d h1) (bi1d h2)) (orimd (bi2d h1) (bi2d h2)));
theorem orbi1d (h: $ a -> (b <-> c) $): $ a -> (b \/ d <-> c \/ d) $ = '(orbid h biidd);
theorem orbi2d (h: $ a -> (c <-> d) $): $ a -> (b \/ c <-> b \/ d) $ = '(orbid biidd h);
theorem orbi1i (h: $ a <-> b $): $ a \/ c <-> b \/ c $ = '(orbi1d id h);
theorem orbi2i (h: $ b <-> c $): $ a \/ b <-> a \/ c $ = '(orbi2d id h);
theorem orbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a \/ c <-> b \/ d $ = '(bitr (orbi1i h1) (orbi2i h2));
theorem orcom: $ a \/ b -> b \/ a $ = 'con1;
theorem notan2: $ ~(a /\ b) <-> a -> ~b $ = '(bicom notnot);
theorem notan: $ ~(a /\ b) <-> (~a \/ ~b) $ = '(bitr notan2 (imbi1i notnot));
theorem notor: $ ~(a \/ b) <-> (~a /\ ~b) $ = '(con1b (bitr4 notan (orbii notnot notnot)));
theorem em: $ p \/ ~p $ = 'id;

abstract def ifp (p a b: wff): wff = $ p /\ a \/ ~p /\ b $;

theorem ifpbid (h1: $ G -> (p <-> q) $) (h2: $ G -> (a <-> c) $) (h3: $ G -> (b <-> d) $):
  $ G -> (ifp p a b <-> ifp q c d) $ = '(orbid (anbid h1 h2) (anbid (notbid h1) h3));
theorem ifpbi1d (h: $ G -> (p <-> q) $): $ G -> (ifp p a b <-> ifp q a b) $ = '(ifpbid h biidd biidd);
theorem ifpbi2d (h: $ G -> (a <-> b) $): $ G -> (ifp p a c <-> ifp p b c) $ = '(ifpbid biidd h biidd);
theorem ifpbi3d (h: $ G -> (b <-> c) $): $ G -> (ifp p a b <-> ifp p a c) $ = '(ifpbid biidd biidd h);

pub theorem ifptrue (p a b: wff): $ p -> (ifp p a b <-> a) $ =
'(ibid (eord (a1i anr) (syl5 anl absurdr)) (exp orl));
pub theorem ifpfalse (p a b: wff): $ ~p -> (ifp p a b <-> b) $ =
'(ibid (eord (syl5 anl absurd) (a1i anr)) (exp orr));

term wtru: wff; prefix wtru: $T.$ prec max;
axiom tru: $ T. $;
def fal: wff = $ ~T. $; prefix fal: $F.$ prec max;

theorem trud (h: $ T. -> a $): $ a $ = '(h tru);
theorem notfal: $ ~F. $ = '(notnot1 tru);
theorem efal: $ F. -> a $ = '(absurd notfal);

sort nat;
term al {x: nat} (ph: wff x): wff; prefix al: $A.$ prec 40;

def ex {x: nat} (ph: wff x): wff = $ ~(A. x ~ph) $;
prefix ex: $E.$ prec 40;

term eq (a b: nat): wff; infixl eq: $=$ prec 50;

axiom ax_gen (ph: wff) {x: nat}: $ ph $ > $ A. x ph $;
axiom ax_4 {x: nat} (ph ps: wff x): $ A. x (ph -> ps) -> A. x ph -> A. x ps $;
axiom ax_5 {x: nat} (ph: wff): $ ph -> A. x ph $;
axiom ax_6 (a: nat) {x: nat}: $ E. x x = a $;
axiom ax_7 (a b c: nat): $ a = b -> a = c -> b = c $;
axiom ax_10 {x: nat} (ph: wff x): $ ~(A. x ph) -> A. x ~ (A. x ph) $;
axiom ax_11 {x y: nat} (ph: wff x y): $ A. x A. y ph -> A. y A. x ph $;
axiom ax_12 {x y: nat} (ph: wff y): $ A. y ph -> A. x (x = y -> ph) $;

theorem alimi (a b: wff x) (h: $ a -> b $): $ A. x a -> A. x b $ = '(ax_4 (ax_gen h));
theorem albii (a b: wff x) (h: $ a <-> b $): $ A. x a <-> A. x b $ =
'(ibii (alimi (bi1i h)) (alimi (bi2i h)));
theorem alimd (G: wff) (a b: wff x) (h: $ G -> a -> b $):
  $ G -> A. x a -> A. x b $ = '(syl (syl h ax_5) ax_4);
theorem albid (G: wff) (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (A. x a <-> A. x b) $ = '(ibid (alimd (bi1d h)) (alimd (bi2d h)));
theorem alan (a b: wff x): $ A. x (a /\ b) <-> A. x a /\ A. x b $ =
'(ibii (iand (alimi anl) (alimi anr)) (imp (syl (alimi ian) ax_4)));
theorem exim (a b: wff x): $ A. x (a -> b) -> E. x a -> E. x b $ =
'(syl (syl (alimi con3) ax_4) con3);
theorem eximi (a b: wff x) (h: $ a -> b $): $ E. x a -> E. x b $ = '(exim (ax_gen h));
theorem exbid (G: wff) (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (E. x a <-> E. x b) $ = '(notbid (albid (notbid h)));
theorem exbii (a b: wff x) (h: $ a <-> b $):
  $ E. x a <-> E. x b $ = '(notbi (albii (notbi h)));
theorem iex (a: wff x): $ a -> E. x a $ =
'(syl (syl (!! ax_5 y) ax_12) (mpi ax_6 exim));
theorem alnex (a: wff x): $ A. x ~a <-> ~(E. x a) $ = 'notnot;
theorem alex (a: wff x): $ A. x a <-> ~(E. x ~a) $ =
'(bitr (albii notnot) alnex);
theorem exnal (a: wff x): $ E. x ~a <-> ~(A. x a) $ = '(con2b alex);
theorem eal (a: wff x): $ A. x a -> a $ = '(ax_3 (sylib iex exnal));
theorem iald (a: wff) (b: wff x) (h: $ a -> b $): $ a -> A. x b $ = '(syl ax_5 (alimi h));
theorem exor (a b: wff x): $ E. x (a \/ b) <-> E. x a \/ E. x b $ =
'(bitr (notbii (bitr (albii notor) alan)) notan);
theorem eximd (G) (a b: wff x) (h: $ G -> a -> b $): $ G -> E. x a -> E. x b $ = '(syl (iald h) exim);

local def nf {x: nat} (a: wff x): wff = $ A. x (a -> A. x a) $;
prefix nf: $F/$ prec 10;

theorem nfv: $ F/ x a $ = '(ax_gen ax_5);
theorem nfi (a: wff x) (h: $ F/ x a $): $ a -> A. x a $ = '(eal h);
theorem nfri (a: wff x) (h: $ a -> A. x a $): $ F/ x a $ = '(ax_gen h);
theorem nfbii (a b: wff x) (h: $ a <-> b $): $ (F/ x a) <-> (F/ x b) $ = '(albii (imbii h (albii h)));
theorem nfx (a b: wff x) (h1: $ a <-> b $) (h2: $ F/ x b $): $ F/ x a $ = '(bi2i (nfbii h1) h2);
theorem nfal1 (a: wff x): $ F/ x A. x a $ = '(ax_gen ax_5);
theorem nfal (a: wff x y) (h: $ F/ x a $): $ F/ x A. y a $ =
'(nfri (syl (alimi (nfi h)) ax_11));
theorem nfnot (a: wff x) (h: $ F/ x a $): $ F/ x ~a $ =
'(nfri (con1 (syl (eximi (nfi h)) (syl (con1 (!! ax_10 x)) eal))));
theorem nfim (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a -> b $ =
'(nfri (cases
   (syl6 (com12 id) (syl (nfi h2) (alimi ax_1)))
   (a1d (syl (nfi (nfnot h1)) (alimi absurd)))));
theorem nfan (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a /\ b $ = '(nfnot (nfim h1 (nfnot h2)));
theorem nfor (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a \/ b $ = '(nfim (nfnot h1) h2);
theorem nfbi (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a <-> b $ = '(nfan (nfim h1 h2) (nfim h2 h1));
theorem nfex1 (a: wff x): $ F/ x E. x a $ = '(nfnot nfal1);
theorem nfex (a: wff x y) (h: $ F/ x a $): $ F/ x E. y a $ = '(nfnot (nfal (nfnot h)));

theorem ialdh (a b: wff x) (h1: $ F/ x a $) (h2: $ a -> b $): $ a -> A. x b $ =
'(syl (nfi h1) (alimi h2));
theorem eexh (a b: wff x) (h1: $ F/ x b $) (h2: $ a -> b $): $ E. x a -> b $ =
'(con1 (ialdh (nfnot h1) (con3 h2)));
theorem eex (a: wff x) (b: wff) (h: $ a -> b $): $ E. x a -> b $ = '(eexh nfv h);
theorem eexdh (a b c: wff x) (h1: $ F/ x a $) (h2: $ F/ x c $)
  (h3: $ a -> b -> c $): $ a -> E. x b -> c $ =
'(con1d (exp (ialdh (nfan h1 (nfnot h2)) (imp (con3d h3)))));
theorem eexd (a: wff) (b: wff x) (c: wff)
  (h: $ a -> b -> c $): $ a -> E. x b -> c $ = '(eexdh nfv nfv h);
theorem eexda (a: wff) (b: wff x) (c: wff)
  (h: $ a /\ b -> c $): $ a -> E. x b -> c $ = '(eexd (exp h));
theorem eexb (a: wff x) (b: wff): $ (E. x a -> b) <-> A. x (a -> b) $ =
'(ibii (ialdh (nfim nfex1 nfv) (imim1i iex)) (eexdh nfal1 nfv eal));
theorem ealeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ =
'(eexh (nfim nfal1 h) (syl6 (alimd (bi1d e)) eal) ax_6);
theorem iexeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(con2 (ealeh (nfnot h) (notbid e)));
theorem eale (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ = '(ealeh nfv e);
theorem iexe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(iexeh nfv e);

theorem eqtr3: $ b = a -> b = c -> a = c $ = 'ax_7;
theorem eqid: $ a = a $ = '(!! eex x (imidm ax_7) ax_6);
theorem eqcom: $ a = b -> b = a $ = '(mpi eqid ax_7);
theorem eqtr: $ a = b -> b = c -> a = c $ = '(syl eqcom ax_7);
theorem eqtr4: $ a = b -> c = b -> a = c $ = '(syl5 eqcom eqtr);
theorem eqeq1: $ a = b -> (a = c <-> b = c) $ = '(ibid eqtr3 eqtr);
theorem eqeq2: $ b = c -> (a = b <-> a = c) $ = '(ibid (com12 eqtr) (com12 eqtr4));
theorem eqeq1d (h: $ G -> a = b $): $ G -> (a = c <-> b = c) $ = '(syl h eqeq1);
theorem eqeq2d (h: $ G -> b = c $): $ G -> (a = b <-> a = c) $ = '(syl h eqeq2);
theorem eqeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a = c <-> b = d) $ = '(bitrd (eqeq1d h1) (eqeq2d h2));
theorem eqeq: $ a = b -> c = d -> (a = c <-> b = d) $ = '(exp (eqeqd anl anr));
theorem eqtr3d (h1: $ G -> b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc h1 h2 eqtr3);
theorem eqidd: $ G -> a = a $ = '(a1i eqid);
theorem eqcomd (h: $ G -> a = b $): $ G -> b = a $ = '(syl h eqcom);
theorem eqtrd (h1: $ G -> a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc h1 h2 eqtr);
theorem eqtr4d (h1: $ G -> a = b $) (h2: $ G -> c = b $): $ G -> a = c $ = '(sylc h1 h2 eqtr4);
theorem syl5eq (h1: $ a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtrd (a1i h1) h2);
theorem syl5eqr (h1: $ b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtr3d (a1i h1) h2);
theorem syl6eq (h1: $ G -> a = b $) (h2: $ b = c $): $ G -> a = c $ = '(eqtrd h1 (a1i h2));
theorem syl6eqr (h1: $ G -> a = b $) (h2: $ c = b $): $ G -> a = c $ = '(eqtr4d h1 (a1i h2));
theorem eqtr4g (h1: $ G -> a = b $) (h2: $ c = a $) (h3: $ d = b $):
  $ G -> c = d $ = '(syl5eq h2 (syl6eqr h1 h3));

theorem cbvalh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ =
'(ibii (ialdh (nfal h1) (eale e))
  (ialdh (nfal h2) (eale (bicomd (syl eqcom e)))));
theorem cbval (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ = '(cbvalh nfv nfv e);

theorem cbvexh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ =
'(notbi (cbvalh (nfnot h1) (nfnot h2) (notbid e)));
theorem cbvex (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ = '(cbvexh nfv nfv e);

def ne (a b: nat): wff = $ ~ a = b $; infixl ne: $!=$ prec 50;

theorem neeq1: $ a = b -> (a != c <-> b != c) $ = '(notbid eqeq1);
theorem neeq2: $ b = c -> (a != b <-> a != c) $ = '(notbid eqeq2);
theorem neeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a != c <-> b != d) $ = '(notbid (eqeqd h1 h2));
theorem necom: $ a != b -> b != a $ = '(con3 eqcom);

def sb (a: nat) {x .y: nat} (ph: wff x): wff =
  $ A. y (y = a -> A. x (x = y -> ph)) $;
notation sb (a x ph) = ($[$:30) a ($/$:0) x ($]$:0) ph;

theorem sbeq (a: nat) (b: wff x): $ x = a -> (b <-> [a / x] b) $ =
'(ibid (exp (!! iald y (a1d (syl (anwr ax_5) ax_12))))
  (mpi ax_6 (eexd (exp (syl5 eal (syld (com12 (imim1i anr))
    (syl (imp eqtr4) (com12 eal))))))));
theorem nfsb1 (a: nat) (b: wff x): $ F/ x [a / x] b $ =
'(!! nfal _ y (nfim nfv nfal1));
theorem nfsb (a: nat) (b: wff x) (h: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ y (nfim nfv (nfal (nfim nfv h))));
theorem sbeq1d (G: wff) (a b: nat) (c: wff x)
  (h: $ G -> a = b $): $ G -> ([a / x] c <-> [b / x] c) $ =
'(!! albid y (imbi1d (eqeq2d h)));
theorem sbeq2d (G: wff) (a: nat x) (b c: wff x)
  (h: $ G -> (b <-> c) $): $ G -> ([a / x] b <-> [a / x] c) $ =
'(!! albid y (imbi2d (albid (imbi2d h))));

theorem sbeht (a: nat) (b c: wff x) (h: $ F/ x c $):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ =
'(eexh (nfim nfal1 (nfbi nfsb1 nfv))
  (exp (bitr3d (anwl sbeq) (impcom eal))) ax_6);
theorem sbeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeht h (ax_gen e));
theorem sbet (a: nat) (b: wff x) (c: wff):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ = '(sbeht nfv);
theorem sbe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeh nfv e);
theorem dfsb2 (a: nat) (b: wff x): $ [a / x] b <-> A. x (x = a -> b) $ =
'(ibii
  (mpi (!! ax_6 y) (eexd (syl eal (a2i (alimd (imim1d (com12 eqtr4)))))))
  (iald (com12 (alimd (imim1d (com12 eqtr))))));
theorem dfsb3 (a: nat) (b: wff x): $ [a / x] b <-> E. x (x = a /\ b) $ =
'(sbeh nfex1 (syl (syl5bb (bitr4 (albii notan2) dfsb2) (bicomd sbeq)) con2b));
theorem sbco (a: nat x) (b: wff x):
  $ [a / y] [y / x] b <-> [a / x] b $ = '(bitr dfsb2 (albii (imbi2i dfsb2)));
theorem sbid (a: wff x): $ [x / x] a <-> a $ =
'(ibii (mpi (!! ax_6 y) (eexd (syl eal (a2i (syl eqcom (com12 eal))))))
  (iald (com12 (bi1d (syl6bb (syl eqcom sbeq) dfsb2)))));
theorem cbvsbh (a: nat) (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ =
'(!! albii z (imbi2i (cbvalh (nfim nfv h1) (nfim nfv h2) (imbid (eqeq1) e))));
theorem cbvsb (a: nat) (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ = '(cbvsbh nfv nfv e);

theorem aleqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ A. x (x = a -> p) <-> q $ = '(bitr3 dfsb2 (sbe e));
theorem exeqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ E. x (x = a /\ p) <-> q $ = '(bitr3 dfsb3 (sbe e));
theorem cbvals (p: wff x): $ A. x p <-> A. y ([y / x] p) $ = '(cbvalh nfv nfsb1 sbeq);
theorem cbvexs (p: wff x): $ E. x p <-> E. y ([y / x] p) $ = '(cbvexh nfv nfsb1 sbeq);
theorem cbvald (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (A. x p <-> A. y q) $ =
'(bitrd (a1i cbvals) (albid (syl (iald (exp h)) sbet)));
theorem cbvexd (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (E. x p <-> E. y q) $ =
'(bitrd (a1i cbvexs) (exbid (syl (iald (exp h)) sbet)));

strict sort set;
term ab {x: nat} (p: wff x): set;
notation ab {x: nat} (p: wff x): set = (${$:max) x ($|$:0) p ($}$:0);
term el: nat > set > wff; infixl el: $e.$ prec 50;
axiom elab (a: nat) {x: nat} (p: wff x):
  $ a e. {x | p} <-> [a / x] p $;
axiom ax_8 (a b: nat) (A: set): $ a = b -> a e. A -> b e. A $;

def eqs (A B: set) {.x: nat}: wff = $ A. x (x e. A <-> x e. B) $;
infixl eqs: $==$ prec 50;

theorem eqsid: $ A == A $ = '(!! ax_gen x biid);
theorem eqscom: $ A == B -> B == A $ = '(!! alimi x bicom);
theorem eqstr: $ A == B -> B == C -> A == C $ = '(syl (!! alimi x bitr) ax_4);
theorem eqstr3: $ B == A -> B == C -> A == C $ = '(syl eqscom eqstr);
theorem eqstr4: $ A == B -> C == B -> A == C $ = '(syl5 eqscom eqstr);
theorem eqseq1: $ A == B -> (A == C <-> B == C) $ = '(ibid eqstr3 eqstr);
theorem eqseq2: $ B == C -> (A == B <-> A == C) $ = '(ibid (com12 eqstr) (com12 eqstr4));
theorem eqseq1d (h: $ G -> A == B $): $ G -> (A == C <-> B == C) $ = '(syl h eqseq1);
theorem eqseq2d (h: $ G -> B == C $): $ G -> (A == B <-> A == C) $ = '(syl h eqseq2);
theorem eqseqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> (A == C <-> B == D) $ = '(bitrd (eqseq1d h1) (eqseq2d h2));
theorem eqseq: $ A == B -> C == D -> (A == C <-> B == D) $ = '(exp (eqseqd anl anr));
theorem eqstr3d (h1: $ G -> B == A $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc h1 h2 eqstr3);
theorem eqsidd: $ G -> A == A $ = '(a1i eqsid);
theorem eqscomd (h: $ G -> A == B $): $ G -> B == A $ = '(syl h eqscom);
theorem eqstrd (h1: $ G -> A == B $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc h1 h2 eqstr);
theorem eqstr4d (h1: $ G -> A == B $) (h2: $ G -> C == B $): $ G -> A == C $ = '(sylc h1 h2 eqstr4);

theorem eleq1: $ a = b -> (a e. A <-> b e. A) $ = '(ibid ax_8 (syl eqcom ax_8));
theorem eleq2: $ A == B -> (a e. A <-> a e. B) $ = 'eal;
theorem eleq1d (h: $ G -> a = b $): $ G -> (a e. A <-> b e. A) $ = '(syl h eleq1);
theorem eleq2d (h: $ G -> A == B $): $ G -> (a e. A <-> a e. B) $ = '(syl h eleq2);
theorem eleqd (h1: $ G -> a = b $) (h2: $ G -> A == B $):
  $ G -> (a e. A <-> b e. B) $ = '(bitrd (eleq1d h1) (eleq2d h2));

theorem abeq (p q: wff x): $ A. x (p <-> q) -> {x | p} == {x | q} $ =
'(!! iald y (bitr4g (ealeh (nfbi nfsb1 nfsb1) (bibid sbeq sbeq)) elab elab));
theorem abeqd (G: wff) (p q: wff x)
  (h: $ G -> (p <-> q) $): $ G -> {x | p} == {x | q} $ = '(syl (iald h) abeq);
theorem eqri {x} (h: $ x e. A <-> x e. B $): $ A == B $ = '(ax_gen h);
theorem eqrd (G) {x} (h: $ G -> (x e. A <-> x e. B) $): $ G -> A == B $ = '(iald h);
theorem cbvabh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ =
'(!! eqri z (bitr4gi (cbvsbh h1 h2 e) elab elab));
theorem cbvab (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ = '(cbvabh nfv nfv e);
theorem cbvabs (p: wff x): $ {x | p} == {y | [y / x] p} $ = '(cbvabh nfv nfsb1 sbeq);
theorem cbvabd (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> {x | p} == {y | q} $ =
'(eqstrd (a1i cbvabs) (abeqd (syl (iald (exp h)) sbet)));
theorem elab2 (a: nat x) (p: wff x): $ a e. {x | p} <-> [a / x] p $ =
'(bitr (bitr (eleq2 (cbvabh nfv nfsb1 sbeq)) elab) (!! sbco x y));
theorem elabe (a: nat x) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ a e. {x | p} <-> q $ = '(bitr elab2 (sbe e));
theorem abid (p: wff x): $ x e. {x | p} <-> p $ = '(bitr elab2 sbid);
theorem abid2: $ {x | x e. A} == A $ = '(!! eqri y (elabe eleq1));

def Inter (A B: set) (.x: nat): set = $ {x | x e. A /\ x e. B} $;
infixl Inter: $i^i$ prec 70;

theorem ineqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> A i^i C == B i^i D $ = '(!! abeqd x (anbid (eleq2d h1) (eleq2d h2)));

def Union (A B: set) (.x: nat): set = $ {x | x e. A \/ x e. B} $;
infixl Union: $u.$ prec 65;

theorem uneqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> A u. C == B u. D $ = '(!! abeqd x (orbid (eleq2d h1) (eleq2d h2)));

def Univ (.x: nat): set = $ {x | T.} $; prefix Univ: $V$ prec max;

local def nfs {x: nat} (A: set x): wff = $ A. y (F/ x y e. A) $;
prefix nfs: $FS/$ prec 10;
local def nfn {x: nat} (a: nat x): wff = $ A. y (F/ x y = a) $;
prefix nfn: $FN/$ prec 10;

theorem nfsv: $ FS/ x A $ = '(!! ax_gen y nfv);
theorem nfnv: $ FN/ x a $ = '(!! ax_gen y nfv);
theorem nfsri {x y} (A: set x) (h: $ F/ x y e. A $): $ FS/ x A $ = '(ax_gen h);
theorem nfnri {x y} (a: nat x) (h: $ F/ x y = a $): $ FN/ x a $ = '(ax_gen h);
theorem nfel2 (a: nat) (A: set x) (h: $ FS/ x A $): $ F/ x a e. A $ = '(eal h);
theorem nfeq (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ F/ x a = b $ =
'(nfx (bicom (!! exeqe y eqeq1)) (nfex (nfan (eal h1) (eal h2))));
theorem nfel (a: nat x) (A: set x) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ F/ x a e. A $ =
'(nfx (bicom (!! exeqe y eleq1)) (nfex (nfan (eal h1) (eal h2))));
theorem nfab1 (p: wff x): $ FS/ x {x | p} $ = '(!! nfsri _ y (nfx elab nfsb1));
theorem nfab (p: wff y) (h: $ F/ x p $): $ FS/ x {y | p} $ = '(!! nfsri _ z (nfx elab (nfsb h)));
theorem nfeqs (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ F/ x A == B $ =
'(!! nfal _ y (nfbi (nfel2 h1) (nfel2 h2)));
theorem nfnlem {y} (a c: nat x) (e: $ y = a -> b = c $) (h: $ FN/ x a $): $ FN/ x c $ =
'(!! nfnri _ z (nfx (bicom (exeqe (eqeq2d e))) (nfex (nfan (nfeq nfnv h) nfv))));

theorem abeqb (p q: wff x): $ A. x (p <-> q) <-> {x | p} == {x | q} $ =
'(ibii abeq (ialdh (nfeqs nfab1 nfab1) (sylib eleq2 (bibi abid abid))));

def sbs (a: nat) {x .y: nat} (A: set x): set = $ {y | [a / x] y e. A} $;
notation sbs (a: nat) {x: nat} (A: set x): set =
  ($S[$:70) a ($/$:0) x ($]$:0) A;

theorem elsbs (a b: nat) (A: set x): $ b e. S[a / x] A <-> [a / x] b e. A $ =
'(bitr (!! elab y) (sbe (sbeq2d eleq1)));
theorem sbseq (a: nat) (A: set x): $ x = a -> A == S[a / x] A $ =
'(!! eqrd y (syl6bb sbeq (bicom elsbs)));
theorem nfsbs1 (a: nat) (A: set x): $ FS/ x S[a / x] A $ =
'(!! nfsri _ y (nfx elsbs nfsb1));
theorem nfsbs (a: nat) (A: set x y) (h: $ FS/ x A $): $ FS/ x S[a / y] A $ =
'(!! nfsri _ z (nfx elsbs (nfsb (nfel2 h))));
theorem sbseq2d (G: wff) (a: nat x) (A B: set x)
  (h: $ G -> A == B $): $ G -> S[a / x] A == S[a / x] B $ =
'(!! abeqd y (sbeq2d (eleq2d h)));

term d0: nat; prefix d0: $0$ prec max;
term suc: nat > nat;

def d1:  nat = $suc 0$; prefix d1:  $1$  prec max;
def d2:  nat = $suc 1$; prefix d2:  $2$  prec max;
def d3:  nat = $suc 2$; prefix d3:  $3$  prec max;
def d4:  nat = $suc 3$; prefix d4:  $4$  prec max;
def d5:  nat = $suc 4$; prefix d5:  $5$  prec max;
def d6:  nat = $suc 5$; prefix d6:  $6$  prec max;
def d7:  nat = $suc 6$; prefix d7:  $7$  prec max;
def d8:  nat = $suc 7$; prefix d8:  $8$  prec max;
def d9:  nat = $suc 8$; prefix d9:  $9$  prec max;
def d10: nat = $suc 9$; prefix d10: $10$ prec max;

axiom peano1 (a: nat): $ suc a != 0 $;
axiom peano2 (a b: nat): $ suc a = suc b <-> a = b $;
axiom peano5 {x: nat} (ph: wff x):
  $ [0 / x] ph -> A. x (ph -> [suc x / x] ph) -> A. x ph $;

theorem d1ne0: $ 1 != 0 $ = 'peano1;
theorem suceq: $ a = b -> suc a = suc b $ = '(bi2 peano2);
theorem suceqd (h: $ G -> a = b $): $ G -> suc a = suc b $ = '(syl h suceq);
theorem nfsuc (a: nat x) (h: $ FN/ x a $): $ FN/ x suc a $ = '(!! nfnlem _ y suceq h);

theorem ind {x y} (a) (px: wff x) (p0 pa: wff) (py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ p0 $) (h2: $ py -> ps $): $ pa $ =
'(eale ha (peano5
  (mpbir h1 (sbe h0))
  (mpbir (ax_gen (syl h2 (bi2i (sbe hs))))
    (cbvalh nfv (nfim nfv nfsb1) (imbid hy (sbeq1d suceq))))));

theorem exsuc (a: nat): $ a != 0 <-> E. x suc x = a $ =
'(ibii
  (! ind y z _ $ y != 0 -> E. x suc x = y $ _ _ _ _
    (imbid (notbid eqeq1) (exbid eqeq2)) (imbid (notbid eqeq1) (exbid eqeq2))
    (imbid (notbid eqeq1) (exbid eqeq2)) (imbid (notbid eqeq1) (exbid eqeq2))
    (absurdr eqid) (a1i (a1i (iexe (eqeq1d suceq) eqid))))
  (eex (mpbii peano1 neeq1)));

term the: set > nat;
axiom theid {x: nat} (A: set) (a: nat): $ A == {x | x = a} -> the A = a $;
axiom the0 {x y: nat} (A: set): $ ~E. y A == {x | x = y} -> the A = 0 $;

theorem theeqd (h: $ G -> A == B $): $ G -> the A = the B $ =
'(! casesd _ $ E. y A == {x | x = y} $ _
  (eexda (eqtr4d (anwr theid) (syl (imp (syl h eqstr3)) theid)))
  (exp (eqtr4d (anwr the0) (syl (impbi (notbid (exbid (eqseq1d h)))) the0))));
theorem eqthed {x} (h: $ G -> (x e. A <-> x = a) $): $ G -> the A = a $ =
'(syl (eqrd (syl6bb h (bicom (elabe eqeq1)))) (!! theid z));
theorem eqtheabd (p: wff x) (h: $ G -> (p <-> x = a) $): $ G -> the {x | p} = a $ =
'(!! eqthed y (syl5bb elab
  (syl (iald h) (ealeh (nfbi nfsb1 nfv) (bibid sbeq eqeq1)))));

theorem eqtheb: $ a = the A <-> (A == {x | x = a} \/ ~E. y A == {x | x = y} /\ a = 0) $ =
'(ibii
  (casesda
    (imp (eexd (exp (orld (mpbird anr
      (syl (eqtrd anl (anwr theid)) (eqseq2d (abeqd eqeq2))))))))
    (orrd (iand anr (eqtrd anl (anwr the0)))))
  (eor (eqcomd theid) (eqtrd anr (anwl (eqcomd the0)))));

theorem nfthe (A: set x) (h: $ FS/ x A $): $ FN/ x the A $ =
'(!! nfnri _ y (nfx (!! eqtheb u v)
  (nfor (nfeqs h nfsv) (nfan (nfnot (nfex (nfeqs h nfsv))) nfv))));

def sbn (a: nat) {x .y: nat} (b: nat x): nat = $ the {y | [a / x] y = b} $;
notation sbn (a: nat) {x: nat} (b: nat x): nat =
  ($N[$:70) a ($/$:0) x ($]$:0) b;

theorem sbneq (a: nat) (b: nat x): $ x = a -> b = N[a / x] b $ =
'(eqcomd (!! eqthed y (syl5bb (!! elabe z (sbeq2d eqeq1)) (bicomd sbeq))));
theorem nfsbn1 (a: nat) (b: nat x): $ FN/ x N[a / x] b $ =
'(nfthe (!! nfab _ y nfsb1));
theorem nfsbn (a: nat) (b: nat x y) (h: $ FN/ x b $): $ FN/ x N[a / y] b $ =
'(nfthe (!! nfab _ y (nfsb (nfeq nfnv h))));
theorem sbneq2d (G: wff) (a b c: nat x)
  (h: $ G -> b = c $): $ G -> N[a / x] b = N[a / x] c $ =
'(theeqd (!! cbvabd y z (sbeq2d (eqeqd anr (anwl h)))));

term add: nat > nat > nat; infixl add: $+$ prec 65;
term mul: nat > nat > nat; infixl mul: $*$ prec 70;

axiom addeq (a b c d: nat): $ a = b -> c = d -> a + c = b + d $;
axiom muleq (a b c d: nat): $ a = b -> c = d -> a * c = b * d $;
axiom add0 (a: nat): $ a + 0 = a $;
axiom addS (a b: nat): $ a + suc b = suc (a + b) $;
axiom mul0 (a: nat): $ a * 0 = 0 $;
axiom mulS (a b: nat): $ a * suc b = a * b + a $;

theorem addeq1: $ a = b -> a + c = b + c $ = '(mpi eqid addeq);
theorem muleq1: $ a = b -> a * c = b * c $ = '(mpi eqid muleq);
theorem addeq2: $ a = b -> c + a = c + b $ = '(addeq eqid);
theorem muleq2: $ a = b -> c * a = c * b $ = '(muleq eqid);
theorem addeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a + c = b + d $ = '(sylc h1 h2 addeq);
theorem muleqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a * c = b * d $ = '(sylc h1 h2 muleq);

theorem add02: $ a + 0 = a $ = 'add0;
theorem add01: $ 0 + a = a $ =
'(! ind x y _ $ 0 + x = x $ _ _ _ _
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  add0 (syl5eq addS suceq));

theorem addS2: $ a + suc b = suc (a + b) $ = 'addS;
theorem addS1: $ suc a + b = suc (a + b) $ =
'(! ind x y _ $ suc a + x = suc (a + x) $ _ _ _ _
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqtr4 add0 (suceq add0))
  (syl5eq addS (suceqd (syl6eqr id addS))));

theorem add12: $ a + 1 = suc a $ = '(eqtr addS (suceq add0));
theorem add11: $ 1 + a = suc a $ = '(eqtr addS1 (suceq add01));

theorem addcom: $ a + b = b + a $ =
'(! ind x y _ $ a + x = x + a $ _ _ _ _
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqtr4 add0 add01) (eqtr4g suceq addS addS1));

theorem addass: $ (a + b) + c = a + (b + c) $ =
'(! ind x y _ $ (a + b) + x = a + (b + x) $ _ _ _ _
  (eqeqd addeq2 (syl addeq2 addeq2)) (eqeqd addeq2 (syl addeq2 addeq2))
  (eqeqd addeq2 (syl addeq2 addeq2)) (eqeqd addeq2 (syl addeq2 addeq2))
  (eqtr4 add0 (addeq2 add0))
  (eqtr4g suceq addS (eqtr (addeq2 addS) addS)));

theorem add32: $ (a + b) + c = (a + c) + b $ =
'(eqtr addass (eqtr4 (addeq2 addcom) addass));

theorem addcan1: $ a + c = b + c <-> a = b $ =
'(! ind x y _ $ a + x = b + x <-> a = b $ _ _ _ _
  (bibi1d (eqeqd addeq2 addeq2)) (bibi1d (eqeqd addeq2 addeq2))
  (bibi1d (eqeqd addeq2 addeq2)) (bibi1d (eqeqd addeq2 addeq2))
  (eqeq add0 add0) (syl5bb (bitr (eqeq addS addS) peano2) id));
theorem addcan2: $ a + b = a + c <-> b = c $ =
'(bitr (eqeq addcom addcom) addcan1);

theorem mul02: $ a * 0 = 0 $ = 'mul0;
theorem mul01: $ 0 * a = 0 $ =
'(! ind x y _ $ 0 * x = 0 $ _ _ _ _
  (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2)
  mul0 (syl5eq (eqtr mulS add0) id));

theorem mulSl: $ suc a * b = a * b + b $ =
'(! ind x y _ $ suc a * x = a * x + x $ _ _ _ _
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqtr4 mul0 (eqtr add0 mul0))
  (eqtr4g addeq1 mulS (eqtr (addeq1 mulS)
    (eqtr addS (eqtr4 (suceq add32) addS)))));

theorem mulcom: $ a * b = b * a $ =
'(! ind x y _ $ a * x = x * a $ _ _ _ _
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqtr4 mul0 mul01) (eqtr4g addeq1 mulS mulSl));

theorem mulid1: $ a * 1 = a $ = '(eqtr mulS (eqtr (addeq1 mul0) add01));
theorem mulid2: $ 1 * a = a $ = '(eqtr mulcom mulid1);

theorem muladd: $ a * (b + c) = a * b + a * c $ =
'(! ind x y _ $ a * (b + x) = a * b + a * x $ _ _ _ _
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqtr4 (muleq2 add0) (eqtr (addeq2 mul0) add0))
  (eqtr4g addeq1 (eqtr (muleq2 addS) mulS) (eqtr4 (addeq2 mulS) addass)));

theorem addmul: $ (a + b) * c = a * c + b * c $ =
'(eqtr mulcom (eqtr muladd (addeq mulcom mulcom)));

theorem mulass: $ (a * b) * c = a * (b * c) $ =
'(! ind x y _ $ (a * b) * x = a * (b * x) $ _ _ _ _
  (eqeqd muleq2 (syl muleq2 muleq2)) (eqeqd muleq2 (syl muleq2 muleq2))
  (eqeqd muleq2 (syl muleq2 muleq2)) (eqeqd muleq2 (syl muleq2 muleq2))
  (eqtr4 mul0 (eqtr (muleq2 mul0) mul0))
  (eqtr4g addeq1 mulS (eqtr (muleq2 mulS) muladd)));

def sub (a b: nat): nat = $ the {x | b + x = a} $;
infixl sub: $-$ prec 65;

theorem subeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a - c = b - d $ =
'(theeqd (!! cbvabd x y (eqeqd (addeqd (anwl h2) anr) (anwl h1))));
theorem subeq: $ a = b -> c = d -> a - c = b - d $ = '(exp (subeqd anl anr));
theorem subeq1: $ a = b -> a - c = b - c $ = '(mpi eqid subeq);
theorem subeq2: $ a = b -> c - a = c - b $ = '(subeq eqid);

theorem eqsub2: $ a + b = c -> c - a = b $ =
'(!! eqthed x (syl5bb (!! elabe y (eqeq1d addeq2)) (syl6bb (bicomd eqeq2) addcan2)));
theorem eqsub1: $ a + b = c -> c - b = a $ = '(sylbi (eqeq1 addcom) eqsub2);
theorem pncan: $ a + b - b = a $ = '(eqsub1 eqid);
theorem pncan2: $ a + b - a = b $ = '(eqsub2 eqid);
theorem sub02: $ a - 0 = a $ = '(eqsub1 add0);

def le (a b .x: nat): wff = $ E. x a + x = b $;
infixl le: $<=$ prec 50;

theorem dfle: $ a <= b <-> E. x a + x = b $ = '(!! cbvex y x (eqeq1d addeq2));

theorem leeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> (a <= c <-> b <= d) $ =
'(!! cbvexd x y (eqeqd (addeqd (anwl h1) anr) (anwl h2)));
theorem leeq: $ a = b -> c = d -> (a <= c <-> b <= d) $ = '(exp (leeqd anl anr));
theorem leeq1: $ a = b -> (a <= c <-> b <= c) $ = '(mpi eqid leeq);
theorem leeq2: $ b = c -> (a <= b <-> a <= c) $ = '(leeq eqid);

theorem leid: $ a <= a $ = '(!! iexe x (eqeq1d addeq2) add0);
theorem eqle: $ a = b -> a <= b $ = '(mpbii leid leeq2);
theorem eqler: $ a = b -> b <= a $ = '(syl eqcom eqle);

theorem pncan3: $ a <= b -> a + (b - a) = b $ =
'(!! eex x (mpbii (addeq2 pncan2) (eqeqd (syl subeq1 addeq2) id)));
theorem npcan: $ b <= a -> a - b + b = a $ = '(syl5eq addcom pncan3);

theorem leaddid2: $ a <= a + b $ = '(!! iexe x (eqeq1d addeq2) eqid);
theorem leaddid1: $ a <= b + a $ = '(mpbi leaddid2 (leeq eqid addcom));

theorem lesucid: $ a <= suc a $ = '(mpbi leaddid2 (leeq2 add12));

theorem le01: $ 0 <= a $ = '(mpbi leaddid1 (leeq2 add0));

theorem leadd1: $ a <= b <-> a + c <= b + c $ =
'(bitr dfle (!! exbii x (bitr3 addcan1 (eqeq1 add32))));
theorem leadd2: $ b <= c <-> a + b <= a + c $ = '(bitr leadd1 (leeq addcom addcom));
theorem lesuc: $ a <= b <-> suc a <= suc b $ = '(bitr leadd1 (leeq add12 add12));

theorem letrd (h1: $ G -> a <= b $) (h2: $ G -> b <= c $): $ G -> a <= c $ =
'(mpd h1 (!! eexda x (mpd (anwl h2) (!! eexda y (syl
  (syl5eqr addass (eqtrd (syl (anwl anr) addeq1) anr))
  (!! iexe z (eqeq1d addeq2)))))));

theorem letr: $ a <= b -> b <= c -> a <= c $ = '(exp (letrd anl anr));

theorem leasymd (h1: $ G -> a <= b $) (h2: $ G -> b <= a $): $ G -> a = b $ =
(focus
  '(mpd h1 (!! eexda x (! casesda _ $ x = 0 $ _ _ _)))
  (focus
    '(syl5eqr add0 (eqtr3d (anwr addeq2) (anwl anr))))
  (focus
    '(imp (syl5bi exsuc (!! eexda y _)))
    '(mpd (anwl (anwl h2)) (!! eexda z _))
    '(sylc (a1i peano1) _ absurd)
    '(syl5eqr addS1 (eqtrd (syl (anwl anr) addeq1) (sylib _ addcan2)))
    '(eqtr4g (eqtrd (syl (anwl (anwl anr)) addeq1) anr) (eqcom addass) add0)));

theorem leasym: $ a <= b -> b <= a -> a = b $ = '(exp (leasymd anl anr));

theorem le02: $ a <= 0 <-> a = 0 $ = '(ibii (mpi le01 leasym) eqle);

def lt (a b: nat): wff = $ suc a <= b $;
infixl lt: $<$ prec 50;

theorem lteqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> (a < c <-> b < d) $ =
'(leeqd (suceqd h1) h2);
theorem lteq: $ a = b -> c = d -> (a < c <-> b < d) $ = '(exp (lteqd anl anr));
theorem lteq1: $ a = b -> (a < c <-> b < c) $ = '(mpi eqid lteq);
theorem lteq2: $ b = c -> (a < b <-> a < c) $ = '(lteq eqid);

theorem ltletr: $ a < b -> b <= c -> a < c $ = 'letr;
theorem ltletrd (h1: $ G -> a < b $) (h2: $ G -> b <= c $): $ G -> a < c $ = '(letrd h1 h2);

theorem ltle: $ a < b -> a <= b $ = '(letrd (a1i lesucid) id);
theorem ltled (h: $ G -> a < b $): $ G -> a <= b $ = '(syl h ltle);

theorem lelttr: $ a <= b -> b < c -> a < c $ = '(sylbi lesuc letr);
theorem lelttrd (h1: $ G -> a <= b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc h1 h2 lelttr);

theorem lttr: $ a < b -> b < c -> a < c $ = '(syl ltle lelttr);
theorem lttrd (h1: $ G -> a < b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc h1 h2 lttr);

theorem ltsucid: $ a < suc a $ = 'leid;

theorem lt01: $ 0 < a <-> a != 0 $ = '(bitr4 (!! exbii x (eqeq1 add11)) exsuc);
theorem lt02: $ ~ a < 0 $ = '(con3 (bi1 le02) peano1);
theorem lt01S: $ 0 < suc a $ = '(mpbir peano1 lt01);

theorem ltadd1: $ a < b <-> a + c < b + c $ = '(bitr leadd1 (leeq1 addS1));
theorem ltadd2: $ b < c <-> a + b < a + c $ = '(bitr ltadd1 (lteq addcom addcom));
theorem ltsuc: $ a < b <-> suc a < suc b $ = '(bitr ltadd1 (lteq add12 add12));
theorem leltsuc: $ a <= b <-> a < suc b $ = 'lesuc;

theorem ltirr: $ ~ a < a $ = '(mtbi lt02 (bitr ltadd1 (lteq add01 add01)));
theorem ltne: $ a < b -> a != b $ = '(mpi ltirr (con3d (com12 (bi1d lteq1))));
theorem ltner: $ a < b -> b != a $ = '(syl ltne necom);

theorem d0lt1: $ 0 < 1 $ = 'lt01S;
theorem d0lt2: $ 0 < 2 $ = 'lt01S;
theorem d1lt2: $ 1 < 2 $ = '(mpbi d0lt1 ltsuc);
theorem lt12: $ a < 1 <-> a = 0 $ = '(bitr3 leltsuc le02);

theorem nlesubeq0: $ ~b <= a -> a - b = 0 $ =
(focus
  '(syl (con3 (eximi (sylbir abeqb _))) (!! the0 x y))
  '(mpbiri eqid (eale (bibid (eqeq1d addeq2) eqeq1))));

theorem subleid: $ a - b <= a $ =
'(cases (mpbii leaddid2 (syl npcan leeq2)) (mpbiri le01 (syl nlesubeq0 leeq1)));

theorem leloe: $ a <= b <-> a < b \/ a = b $ =
'(ibii (!! eex x (casesd
    (exp (orrd (syl5eqr add0 (eqtr3d (anwr addeq2) anl))))
    (syl5bi exsuc (!! eexda y (orld (mpbii leaddid2
      (syl (syl5eq (eqtr4 addS1 addS2) (eqtrd (anwr addeq2) anl)) leeq2)))))))
  (eor ltle eqle));

theorem ltlene: $ a < b <-> a <= b /\ a != b $ =
'(ibii (iand ltle ltne) (imp (con1d (bi1 leloe))));
theorem ltlenle: $ a < b <-> a <= b /\ ~b <= a $ =
'(ibii (iand ltle (mtd (a1i ltirr) ltletr))
  (sylibr (iand anl (anwr (con3 eqler))) ltlene));

theorem ltorle: $ a < b \/ b <= a $ =
'(! ind x y _ $ a < x \/ x <= a $ _ _ _ _
  (orbid lteq2 leeq1) (orbid lteq2 leeq1) (orbid lteq2 leeq1) (orbid lteq2 leeq1)
  (orr le01)
  (eor (orld (mpi ltsucid lttr))
    (syl5 (con3 (bi1 lesuc)) (exp (bi2 ltlenle)))));
theorem leorlt: $ a <= b \/ b < a $ = '(orcom ltorle);

theorem ltnle: $ a < b <-> ~b <= a $ = '(ibii (sylbi ltlenle anr) leorlt);
theorem lenlt: $ a <= b <-> ~b < a $ = '(con2b ltnle);
theorem ltnlt: $ a < b -> ~b < a $ = '(sylbi ltnle (con3 ltle));
theorem leorle: $ a <= b \/ b <= a $ = '(syl leorlt ltle);

theorem sub01: $ 0 - a = 0 $ =
'(cases (sylbi le02 (syl6eq subeq2 sub02)) nlesubeq0);

theorem pnpcan2: $ (a + c) - (b + c) = a - b $ =
'(cases
  (syl (syl5eqr addass (syl npcan addeq1)) eqsub1)
  (eqtr4d (sylbi (notbi leadd1) nlesubeq0) nlesubeq0));

theorem pnpcan: $ (a + b) - (a + c) = b - c $ = '(eqtr (subeq addcom addcom) pnpcan2);
theorem subSS: $ suc a - suc b = a - b $ = '(eqtr3 (subeq add12 add12) pnpcan2);

abstract def if (p: wff) (a b: nat): nat = $ the {n | ifp p (n = a) (n = b)} $;

theorem ifeqd (h1: $ G -> (p <-> q) $) (h2: $ G -> a = c $) (h3: $ G -> b = d $):
  $ G -> if p a b = if q c d $ =
'(theeqd (!! cbvabd x y
  (ifpbid (anwl h1) (eqeqd anr (anwl h2)) (eqeqd anr (anwl h3)))));
theorem ifeq1d (h: $ G -> (p <-> q) $): $ G -> if p a b = if q a b $ = '(ifeqd h eqidd eqidd);
theorem ifeq2d (h: $ G -> a = b $): $ G -> if p a c = if p b c $ = '(ifeqd biidd h eqidd);
theorem ifeq3d (h: $ G -> b = c $): $ G -> if p a b = if p a c $ = '(ifeqd biidd eqidd h);

pub theorem iftrue (p: wff) (a b: nat): $ p -> if p a b = a $ = '(!! eqtheabd n ifptrue);
pub theorem iffalse (p: wff) (a b: nat): $ ~p -> if p a b = b $ = '(!! eqtheabd n ifpfalse);

theorem ifid: $ if p a a = a $ = '(cases iftrue iffalse);

def true (n: nat): wff = $ n != 0 $;
def bool (n: nat): wff = $ n < 2 $;
def nat (p: wff): nat = $ if p 1 0 $;

theorem trueeq: $ a = b -> (true a <-> true b) $ = 'neeq1;
theorem booleq: $ a = b -> (bool a <-> bool b) $ = 'lteq1;
theorem nateq: $ (p <-> q) -> nat p = nat q $ = '(ifeqd id eqidd eqidd);

theorem true1: $ true 1 $ = 'd1ne0;
theorem true0: $ ~ true 0 $ = '(notnot1 eqid);

theorem bool0: $ bool 0 $ = 'd0lt2;
theorem bool1: $ bool 1 $ = 'd1lt2;
theorem bool01: $ bool n <-> n = 0 \/ n = 1 $ =
'(bitr3 leltsuc (bitr leloe (orbi1i lt12)));

theorem truenat: $ true (nat p) <-> p $ =
'(ibii (con1 iffalse) (mpbiri d1ne0 (syl iftrue neeq1)));
theorem nattrue: $ bool n -> nat (true n) = n $ =
'(sylbi bool01 (eor
  (eqtr4d (syl trueeq nateq) (syl6eqr id (iffalse true0)))
  (eqtr4d (syl trueeq nateq) (syl6eqr id (iftrue true1)))));

def min (a b: nat): nat = $ if (a < b) a b $;
def max (a b: nat): nat = $ if (a < b) b a $;

theorem mineqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> min a c = min b d $ = '(ifeqd (lteqd h1 h2) h1 h2);
theorem maxeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> max a c = max b d $ = '(ifeqd (lteqd h1 h2) h2 h1);

theorem mineq1: $ a <= b -> min a b = a $ =
'(sylbi leloe (eor iftrue (syl6eq (ifeq3d eqcom) ifid)));
theorem maxeq2: $ a <= b -> max a b = b $ =
'(sylbi leloe (eor iftrue (syl6eq (ifeq3d id) ifid)));

theorem mincom: $ min a b = min b a $ =
'(cases (eqtr4d iftrue (syl ltnlt iffalse)) (eqtr4d iffalse (sylbir lenlt mineq1)));
theorem maxcom: $ max a b = max b a $ =
'(cases (eqtr4d iftrue (syl ltnlt iffalse)) (eqtr4d iffalse (sylbir lenlt maxeq2)));

theorem mineq2: $ b <= a -> min a b = b $ = '(syl5eq mincom mineq1);
theorem maxeq1: $ b <= a -> max a b = a $ = '(syl5eq maxcom maxeq2);

theorem minle1: $ min a b <= a $ =
'(cases (syl iftrue eqle) (mpbird (bi2 lenlt) (syl iffalse leeq1)));
theorem minle2: $ min a b <= b $ = '(mpbi minle1 (leeq1 mincom));
theorem lemin: $ a <= min b c <-> a <= b /\ a <= c $ =
'(ibii (iand (mpi minle1 letr) (mpi minle2 letr)) (casesda
  (mpbird (anwl anl) (anwr (syl iftrue leeq2)))
  (mpbird (anwl anr) (anwr (syl iffalse leeq2)))));

theorem lemax1: $ a <= max a b $ =
'(cases (mpbird ltle (syl iftrue leeq2)) (syl iffalse eqler));
theorem lemax2: $ b <= max a b $ = '(mpbi lemax1 (leeq2 maxcom));
theorem maxle: $ max a b <= c <-> a <= c /\ b <= c $ =
'(ibii (iand (letr lemax1) (letr lemax2)) (casesda
  (mpbird (anwl anr) (anwr (syl iftrue leeq1)))
  (mpbird (anwl anl) (anwr (syl iffalse leeq1)))));

abstract def pr (a b: nat): nat; infixr pr: $<>$ prec 54;
abstract def fst (a: nat): nat;
abstract def snd (a: nat): nat;

pub theorem fstpr (a b: nat): $ fst (a <> b) = a $;
pub theorem sndpr (a b: nat): $ snd (a <> b) = b $;
pub theorem fstsnd (a: nat): $ fst a <> snd a = a $;

pub theorem fst0: $ fst 0 = 0 $;
pub theorem snd0: $ snd 0 = 0 $;
pub theorem pr0: $ 0 <> 0 = 0 $;

def pi11 (n: nat): nat = $ fst (fst n) $;
def pi12 (n: nat): nat = $ snd (fst n) $;
def pi21 (n: nat): nat = $ fst (snd n) $;
def pi22 (n: nat): nat = $ snd (snd n) $;
def pi221 (n: nat): nat = $ fst (pi22 n) $;
def pi222 (n: nat): nat = $ snd (pi22 n) $;

abstract def rec (z: nat) {x: nat} (s: nat x) (n: nat): nat;
pub theorem rec0 (z: nat) {x: nat} (s: nat x): $ rec z x s 0 = z $;
pub theorem recS (z: nat) {x: nat} (s: nat x) (n: nat):
  $ rec z x s (suc n) = N[rec z x s n / x] s $;

abstract def pow (a b: nat): nat; infixr pow: $^$ prec 80;
pub theorem pow0 (a: nat): $ a ^ 0 = 1 $;
pub theorem powS (a b: nat): $ a ^ suc b = a * a ^ b $;

abstract def div (a b: nat): nat; infixl div: $//$ prec 70;
abstract def mod (a b: nat): nat; infixl mod: $%$ prec 70;
pub theorem div0 (a: nat): $ a // 0 = 0 $;
pub theorem divmod (a b: nat): $ b * (a // b) + a % b = a $;
pub theorem modlt (a b: nat): $ b != 0 -> a % b < a $;

def dvd (a b .c: nat): wff = $ E. c c * a = b $;

def b0 (n: nat): nat = $ n + n $;
def b1 (n: nat): nat = $ suc (b0 n) $;
def odd (n: nat): wff = $ n % 2 = 1 $;

def shl (a n: nat): nat = $ a * 2 ^ n $;
def shr (a n: nat): nat = $ a // 2 ^ n $;

def nel (a b: nat): wff = $ odd (shr a b) $;
def ns (a .x: nat): set = ${x | nel x a}$; coercion ns: nat > set;
pub theorem axext {x: nat} (a b: nat): $ a == b -> a = b $;
pub theorem extlt (a b: nat): $ a e. b -> a < b $;
pub theorem nel0 (a: nat): $ ~ a e. 0 $;

def finite (A: set) (.n: nat): wff = $ E. n n == A $;

def lower (A: set) (.n: nat): nat = $ the {n | n == A} $;

abstract def sn (a: nat): nat;
pub theorem elsn (a b: nat): $ a e. sn b <-> a = b $;

abstract def ins (a b: nat): nat; infixr ins: $;$ prec 84;
pub theorem elins (a b c: nat): $ a e. ins b c <-> a = b \/ a e. c $;

def upto (n: nat): nat = $ 2 ^ n - 1 $;
pub theorem elupto (k n: nat): $ k e. upto n <-> k < n $;

def Bool: nat = $ 0 ; sn 1 $;
def Option (A: set) (.n: nat): set = $ {n | n = 0 \/ n - 1 e. A} $;

def subset (A B: set) (.x: nat): wff = $ A. x (x e. A -> x e. B) $;
infixl subset: $C_$ prec 50;

def Power (A: set) (.x: nat): set = $ {x | x C_ A} $;
def power (a: nat): nat = $ lower (Power a) $;

abstract def card (s: nat): nat;
pub theorem card0: $ card 0 = 0 $;
pub theorem cardS (a s: nat): $ ~a e. s -> card (a ; s) = suc (card s) $;

def cons (a b: nat): nat = $ suc (a <> b) $; infixr cons: $:$ prec 90;

abstract def sep (n: nat) (A: set): nat;
pub theorem elsep (n: nat) (A: set) (a: nat):
  $ a e. sep n A <-> a e. n /\ a e. A $;

def isfun (A: set) (.a .b .b2: nat): wff =
$ A. a A. b A. b2 (a <> b e. A -> a <> b2 e. A -> b = b2) $;

def opab {x y .z: nat} (ph: wff x y): set =
$ {z | E. x E. y (z = x <> y /\ ph)} $;

def Xp (A B: set) (.x .y .z: nat): set = $ opab x y (x e. A /\ y e. B) $;

def Dom (A: set) (.x .y: nat): set = $ {x | E. y x <> y e. A} $;
def Ran (A: set) (.x .y: nat): set = $ {y | E. x x <> y e. A} $;

def Im (F A: set) (.x .y: nat): set = $ {y | E. x (x e. A /\ x <> y e. F)} $;
infixl Im: $''$ prec 80;

def cnv (A: set) (.x .y: nat): set = $ opab x y (y <> x e. A) $;

def comp (F G: set) (.x .y .z: nat): set =
$ opab x z (E. y (x <> y e. G /\ y <> z e. F)) $;
infixr comp: $o.$ prec 90;

def res (A: set) (n: nat): nat = $ sep (lower (Xp n V)) A $;
infixl res: $|`$ prec 55;
pub theorem elres (n a b: nat) (A: set):
  $ isfun A -> (a <> b e. A |` n <-> a e. n /\ a <> b e. A) $;

def Arrow (A B: set) (.f: nat): set =
$ {f | isfun f /\ Dom f == A /\ Ran f C_ B} $;

def lam {x .p: nat} (a: nat x): set = ${p | E. x p = x <> a}$;
notation lam {x: nat} (a: nat x): set = ($\$:30) x ($,$:0) a;

def app (F: set) (x .y: nat): nat = $ the {y | x <> y e. F} $;
infixl app: $@$ prec 200;

def write (f x y .a .b: nat): nat =
  $ lower (opab a b (a <> b e. f /\ a != x \/ a = x /\ b = y)) $;
pub theorem writeEq (f x y: nat): $ write f x y @ x = y $;
pub theorem writeNe (f x y a: nat): $ a != x -> write f x y @ a = f @ a $;

abstract def srec {x: nat} (s: nat x): set;
pub theorem srecval {x y: nat} (s: nat x) (n: nat):
  $ srec x s @ n = N[srec x s |` upto n / x] s $;

abstract def srecp (A: set): set;
pub theorem srecpval (A: set) (n: nat):
  $ n e. srecp A <-> n <> sep n (srecp A) e. A $;

def case (A B: set) (.n: nat): set =
  $ \ n, if (odd n) (B @ (n // 2)) (A @ (n // 2)) $;
pub theorem casel (A B: set) (n: nat): $ case A B @ (b0 n) = A @ n $;
pub theorem caser (A B: set) (n: nat): $ case A B @ (b1 n) = B @ n $;

abstract def Sum (A B: set): set;
pub theorem Suml (A B: set) (n: nat): $ b0 n e. Sum A B <-> n e. A $;
pub theorem Sumr (A B: set) (n: nat): $ b1 n e. Sum A B <-> n e. B $;

abstract def all (A: set) (n: nat): wff;
pub theorem all0 (A: set): $ all A 0 $;
pub theorem allS (A: set) (a b: nat): $ all A (a : b) <-> a e. A /\ all A b $;

def List (A: set) (.n: nat): set = $ {n | all A n} $;

abstract def in (a l: nat): wff; infixl in: $IN$ prec 50;
pub theorem id0 (a: nat): $ ~ a IN 0 $;
pub theorem inS (a b l: nat): $ a IN (b : l) <-> a = b \/ a IN l $;

abstract def lmems (l: nat): nat;
pub theorem ellmems (a l: nat): $ a e. lmems l <-> a IN l $;

abstract def lrec (z: nat) (S: set) (n: nat): nat;
pub theorem lrec0 (z: nat) (S: set): $ lrec z S 0 = z $;
pub theorem lrecS (z: nat) (S: set) (a b: nat):
  $ lrec z S (a : b) = S @ (a <> lrec z S b) $;

abstract def len (l: nat): nat;
pub theorem len0: $ len 0 = 0 $;
pub theorem lenS (a b: nat): $ len (a : b) = suc (len b) $;

def Array (A: set) (n .l: nat): set = $ {l | l e. List A /\ len l = n} $;

abstract def snoc (l a: nat): nat; infixl snoc: $|>$ prec 85;
pub theorem snoc0 (a: nat): $ 0 |> a = a : 0 $;
pub theorem snocS (a b c: nat): $ (a : b) |> c = a : (b |> c) $;
pub theorem snoclt (a b: nat): $ a < a |> b $;

abstract def append (l1 l2: nat): nat; infixl append: $++$ prec 85;
pub theorem append0 (a: nat): $ 0 ++ a = a $;
pub theorem appendS (a b c: nat): $ (a : b) ++ c = a : (b ++ c) $;

abstract def nth (n l: nat): nat;
pub theorem nth0 (n: nat): $ nth n 0 = 0 $;
pub theorem nthZ (a l: nat): $ nth 0 (a : l) = suc a $;
pub theorem nthS (n a l: nat): $ nth (suc n) (a : l) = nth n l $;

abstract def repeat (a n: nat): nat;
pub theorem repeat0 (a: nat): $ repeat a 0 = 0 $;
pub theorem repeatS (a n: nat): $ repeat a (suc n) = a : repeat a n $;

def sublistAt (n l l2 .l1 .l3: nat): wff =
$ E. l1 E. l3 (l = l1 ++ l2 ++ l3 /\ len l1 = n) $;
