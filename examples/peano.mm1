delimiter $ ( [ { ~ $
          $ } ] ) , $;
strict provable sort wff;
term im (ph ps: wff): wff; infixr im: $->$ prec 25;
term not (ph: wff): wff; prefix not: $~$ prec 40;

axiom ax_1 (ph ps: wff): $ ph -> ps -> ph $;
axiom ax_2 (ph ps ch: wff): $ (ph -> ps -> ch) -> (ph -> ps) -> ph -> ch $;
axiom ax_3 (ph ps: wff): $ (~ph -> ~ps) -> ps -> ph $;
axiom ax_mp (ph ps: wff): $ ph $ > $ ph -> ps $ > $ ps $;

do {
  (set-timeout 500)
  (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
  (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
  (def (rev l) (foldl l () (fn (l a) (cons a l))))
  (def (verb e) (list ':verb e))
  (def (exact e) (refine (verb e)))
  (def refine-extra-args-orig refine-extra-args)
  (def (refine-extra-args refine p . ps) @
    foldl ps p @ fn (acc p2) @
      refine @ list 'ax_mp (verb p2) (verb acc))
  (def (result) (hd (get-goals)))
  (def (target) (goal-type (result)))
};

theorem a1i (h: $ b $): $ a -> b $ = '(ax_1 h);
theorem a2i (h: $ a -> b -> c $): $ (a -> b) -> (a -> c) $ = '(ax_2 h);
theorem mpd (h1: $ a -> b $) (h2: $ a -> b -> c $): $ a -> c $ = '(ax_2 h2 h1);
theorem mpi (h1: $ b $) (h2: $ a -> b -> c $): $ a -> c $ = '(mpd (a1i h1) h2);
theorem id: $ a -> a $ = '(mpd (! ax_1 _ a) ax_1);
theorem idd: $ a -> b -> b $ = '(a1i id);
theorem syl (h1: $ a -> b $) (h2: $ b -> c $): $ a -> c $ = '(mpd h1 (a1i h2));
theorem rsyl (h1: $ b -> c $) (h2: $ a -> b $): $ a -> c $ = '(syl h2 h1);
theorem a1d (h: $ a -> b $): $ a -> c -> b $ = '(syl h ax_1);
theorem a2d (h: $ a -> b -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl h ax_2);
theorem a3d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl h ax_3);
theorem sylc (h1: $ a -> b $) (h2: $ a -> c $) (h: $ b -> c -> d $): $ a -> d $ = '(mpd h2 (syl h1 h));
theorem syld (h1: $ a -> b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(mpd h1 @ a2d @ a1d h2);
theorem syl5 (h1: $ b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syld (a1i h1) h2);
theorem syl6 (h1: $ a -> b -> c $) (h2: $ c -> d $): $ a -> b -> d $ = '(syld h1 (a1i h2));
theorem imim2: $ (b -> c) -> (a -> b) -> (a -> c) $ = '(a2d ax_1);
theorem imim2i (h: $ b -> c $): $ (a -> b) -> (a -> c) $ = '(imim2 h);
theorem imim2d (h: $ a -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl h imim2);
theorem absurd: $ ~a -> a -> b $ = '(a3d ax_1);
theorem com12 (h: $ a -> b -> c $): $ b -> a -> c $ = '(syl ax_1 (a2i h));
theorem com23 (h: $ a -> b -> c -> d $): $ a -> c -> b -> d $ = '(syl h @ com12 @ imim2d @ com12 id);
theorem absurdr: $ a -> ~a -> b $ = '(com12 absurd);
theorem imim1: $ (a -> b) -> (b -> c) -> (a -> c) $ = '(com12 imim2);
theorem imim1i (h: $ a -> b $): $ (b -> c) -> (a -> c) $ = '(imim1 h);
theorem imim1d (h: $ a -> b -> c $): $ a -> (c -> d) -> (b -> d) $ = '(syl h imim1);
theorem imimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $):
  $ a -> (c -> d) -> (b -> e) $ = '(syld (imim1d h1) (imim2d h2));
theorem imidm: $ (a -> a -> b) -> a -> b $ = '(a2i (com12 id));
theorem contra: $ (~a -> a) -> a $ = '(imidm (a3d (a2i absurd)));
theorem dne: $ ~~a -> a $ = '(syl absurd contra);
theorem inot: $ (a -> ~a) -> ~a $ = '(syl (imim1 dne) contra);
theorem con2: $ (a -> ~b) -> (b -> ~a) $ = '(a3d (syl5 dne id));
theorem notnot1: $ a -> ~~a $ = '(con2 id);
theorem con3: $ (a -> b) -> (~b -> ~a) $ = '(syl (imim2i notnot1) con2);
theorem con1: $ (~a -> b) -> (~b -> a) $ = '(a3d (imim2i notnot1));
theorem cases (h1: $ a -> b $) (h2: $ ~a -> b $): $ b $ = '(contra (syl (con1 h2) h1));
theorem casesd (h1: $ a -> b -> c $) (h2: $ a -> ~b -> c $): $ a -> c $ =
'(cases (com12 h1) (com12 h2));
theorem con1d (h: $ a -> ~b -> c $): $ a -> ~c -> b $ = '(syl h con1);
theorem con2d (h: $ a -> b -> ~c $): $ a -> c -> ~b $ = '(syl h con2);
theorem con3d (h: $ a -> b -> c $): $ a -> ~c -> ~b $ = '(syl h con3);
theorem con4d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl h ax_3);
theorem mt (h1: $ ~a $) (h2: $ b -> a $): $ ~b $ = '(con3 h2 h1);
theorem mtd (h1: $ a -> ~b $) (h2: $ a -> c -> b $): $ a -> ~c $ = '(mpd h1 @ con3d h2);
theorem mt2d (h1: $ a -> c $) (h2: $ a -> b -> ~c $): $ a -> ~b $ = '(sylc h2 h1 con2);

def an (a b: wff): wff = $ ~(a -> ~b) $;
infixl an: $/\$ prec 35;

theorem anl: $ a /\ b -> a $ = '(con1 absurd);
theorem anr: $ a /\ b -> b $ = '(con1 ax_1);
theorem ian: $ a -> b -> a /\ b $ = '(syl (com12 id) con2);
theorem iand (h1: $ a -> b $) (h2: $ a -> c $): $ a -> b /\ c $ = '(sylc h1 h2 ian);
theorem anld (h: $ a -> b /\ c $): $ a -> b $ = '(syl h anl);
theorem anrd (h: $ a -> b /\ c $): $ a -> c $ = '(syl h anr);
theorem iani (h1: $ a $) (h2: $ b $): $ a /\ b $ = '(ian h1 h2);
theorem anwl (h: $ a -> c $): $ a /\ b -> c $ = '(syl anl h);
theorem anwr (h: $ b -> c $): $ a /\ b -> c $ = '(syl anr h);
theorem anll: $ a /\ b /\ c -> a $ = '(anwl anl);
theorem anlr: $ a /\ b /\ c -> b $ = '(anwl anr);
theorem anrl: $ a /\ (b /\ c) -> b $ = '(anwr anl);
theorem anrr: $ a /\ (b /\ c) -> c $ = '(anwr anr);
theorem anwll (h: $ a -> d $): $ a /\ b /\ c -> d $ = '(anwl (anwl h));
theorem anw3l (h: $ a -> e $): $ a /\ b /\ c /\ d -> e $ = '(anwll (anwl h));
theorem an3l: $ a /\ b /\ c /\ d -> a $ = '(anwll anl);
theorem anllr: $ a /\ b /\ c /\ d -> b $ = '(anwll anr);
theorem imp (h: $ a -> b -> c $): $ a /\ b -> c $ = '(sylc anl anr h);
theorem exp (h: $ a /\ b -> c $): $ a -> b -> c $ = '(syl6 ian h);
theorem impcom (h: $ a -> b -> c $): $ b /\ a -> c $ = '(imp (com12 h));
theorem expcom (h: $ a /\ b -> c $): $ b -> a -> c $ = '(com12 (exp h));
theorem sylan (h1: $ a -> b $) (h2: $ a -> c $)
  (h: $ b /\ c -> d $): $ a -> d $ = '(syl (iand h1 h2) h);
theorem animd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b /\ d -> c /\ e $ =
'(exp (iand (imp (syl5 anl h1)) (imp (syl5 anr h2))));
theorem anim1d (h: $ a -> b -> c $): $ a -> b /\ d -> c /\ d $ = '(animd h idd);
theorem anim2d (h: $ a -> c -> d $): $ a -> b /\ c -> b /\ d $ = '(animd idd h);
theorem ancom: $ a /\ b -> b /\ a $ = '(iand anr anl);
theorem an32s (h: $ a /\ b /\ c -> d $): $ a /\ c /\ b -> d $ =
'(sylan (iand anll anr) anlr h);
theorem casesda (h1: $ a /\ b -> c $) (h2: $ a /\ ~b -> c $): $ a -> c $ =
'(casesd (exp h1) (exp h2));
theorem inotda (h: $ a /\ b -> ~b $): $ a -> ~b $ = '(syl (exp h) inot);

def iff (a b: wff): wff = $ (a -> b) /\ (b -> a) $;
infixl iff: $<->$ prec 20;

theorem bi1: $ (a <-> b) -> a -> b $ = 'anl;
theorem bi1i (h: $ a <-> b $): $ a -> b $ = '(bi1 h);
theorem bi1d (h: $ a -> (b <-> c) $): $ a -> b -> c $ = '(syl h bi1);
theorem bi2: $ (a <-> b) -> b -> a $ = 'anr;
theorem bi2i (h: $ a <-> b $): $ b -> a $ = '(bi2 h);
theorem bi2d (h: $ a -> (b <-> c) $): $ a -> c -> b $ = '(syl h bi2);
theorem ibii (h1: $ a -> b $) (h2: $ b -> a $): $ a <-> b $ = '(iani h1 h2);
theorem ibid (h1: $ a -> b -> c $) (h2: $ a -> c -> b $): $ a -> (b <-> c) $ = '(iand h1 h2);
theorem ibida (h1: $ a /\ b -> c $) (h2: $ a /\ c -> b $): $ a -> (b <-> c) $ = '(ibid (exp h1) (exp h2));
theorem biid: $ a <-> a $ = '(ibii id id);
theorem biidd: $ a -> (b <-> b) $ = '(a1i biid);
theorem mpbi (h1: $ a $) (h2: $ a <-> b $): $ b $ = '(bi1i h2 h1);
theorem mpbir (h1: $ a $) (h2: $ b <-> a $): $ b $ = '(bi2i h2 h1);
theorem mpbid (h1: $ a -> b $) (h2: $ a -> (b <-> c) $): $ a -> c $ = '(mpd h1 (bi1d h2));
theorem mpbird (h1: $ a -> b $) (h2: $ a -> (c <-> b) $): $ a -> c $ = '(mpd h1 (bi2d h2));
theorem mpbii (h1: $ b $) (h2: $ a -> (b <-> c) $): $ a -> c $ = '(mpbid (a1i h1) h2);
theorem mpbiri (h1: $ b $) (h2: $ a -> (c <-> b) $): $ a -> c $ = '(mpbird (a1i h1) h2);
theorem mtbi (h1: $ ~a $) (h2: $ a <-> b $): $ ~b $ = '(mt h1 (bi2 h2));
theorem mtbir (h1: $ ~a $) (h2: $ b <-> a $): $ ~b $ = '(mt h1 (bi1 h2));
theorem mtbid (h1: $ a -> ~b $) (h2: $ a -> (b <-> c) $): $ a -> ~c $ = '(mtd h1 (bi2d h2));
theorem mtbird (h1: $ a -> ~b $) (h2: $ a -> (c <-> b) $): $ a -> ~c $ = '(mtd h1 (bi1d h2));
theorem con1b: $ (~a <-> b) -> (~b <-> a) $ = '(ibid (con1d bi1) (con2d bi2));
theorem con2b: $ (a <-> ~b) -> (b <-> ~a) $ = '(ibid (con2d bi1) (con1d bi2));
theorem con3b: $ (a <-> b) -> (~a <-> ~b) $ = '(ibid (con3d bi2) (con3d bi1));
theorem con4b: $ (~a <-> ~b) -> (a <-> b) $ = '(ibid (con4d bi2) (con4d bi1));
theorem notnot: $ a <-> ~~a $ = '(ibii notnot1 dne);
theorem bithd (h1: $ a -> b $) (h2: $ a -> c $): $ a -> (b <-> c) $ = '(ibid (a1d h2) (a1d h1));
theorem binthd (h1: $ a -> ~b $) (h2: $ a -> ~c $): $ a -> (b <-> c) $ = '(syl (bithd h1 h2) con4b);
theorem bicom: $ (a <-> b) -> (b <-> a) $ = '(ibid bi2 bi1);
theorem bicomd (h: $ a -> (b <-> c) $): $ a -> (c <-> b) $ = '(syl h bicom);
theorem bitrd (h1: $ a -> (b <-> c) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ =
'(ibid (syld (bi1d h1) (bi1d h2)) (syld (bi2d h2) (bi2d h1)));
theorem bitr3d (h1: $ a -> (c <-> b) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (bicomd h1) h2);
theorem bitr4d (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> c) $): $ a -> (b <-> d) $ = '(bitrd h1 (bicomd h2));
theorem bitr: $ (a <-> b) -> (b <-> c) -> (a <-> c) $ = '(exp (bitrd anl anr));
theorem bitr3: $ (b <-> a) -> (b <-> c) -> (a <-> c) $ = '(exp (bitr3d anl anr));
theorem bitr4: $ (a <-> b) -> (c <-> b) -> (a <-> c) $ = '(exp (bitr4d anl anr));
theorem sylib (h1: $ a -> b $) (h2: $ b <-> c $): $ a -> c $ = '(syl h1 (bi1i h2));
theorem sylibr (h1: $ a -> b $) (h2: $ c <-> b $): $ a -> c $ = '(syl h1 (bi2i h2));
theorem sylbi (h1: $ a <-> b $) (h2: $ b -> c $): $ a -> c $ = '(syl (bi1i h1) h2);
theorem sylbir (h1: $ b <-> a $) (h2: $ b -> c $): $ a -> c $ = '(syl (bi2i h1) h2);
theorem syl5bb (h1: $ b <-> c $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (a1i h1) h2);
theorem syl6bb (h1: $ a -> (b <-> c) $) (h2: $ c <-> d $): $ a -> (b <-> d) $ = '(bitrd h1 (a1i h2));
theorem syl5bi (h1: $ b <-> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syl5 (bi1 h1) h2);
theorem syl6ibr (h1: $ a -> b -> c $) (h2: $ d <-> c $): $ a -> b -> d $ = '(syl6 h1 (bi2 h2));
theorem bitr3g (h1: $ a -> (b <-> c) $) (h2: $ b <-> d $) (h3: $ c <-> e $):
  $ a -> (d <-> e) $ = '(syl5bb (bicom h2) (syl6bb h1 h3));
theorem bitr4g (h1: $ a -> (b <-> c) $) (h2: $ d <-> b $) (h3: $ e <-> c $):
  $ a -> (d <-> e) $ = '(syl5bb h2 (syl6bb h1 (bicom h3)));
theorem bitr3gi (h1: $ a <-> b $) (h2: $ a <-> c $) (h3: $ b <-> d $): $ c <-> d $ = '(bitr3 h2 (bitr h1 h3));
theorem bitr4gi (h1: $ a <-> b $) (h2: $ c <-> a $) (h3: $ d <-> b $): $ c <-> d $ = '(bitr h2 (bitr4 h1 h3));
theorem impbi (h: $ a -> (b <-> c) $): $ a /\ b -> c $ = '(imp (bi1d h));
theorem impbir (h: $ a -> (c <-> b) $): $ a /\ b -> c $ = '(imp (bi2d h));
theorem notbi: $ (a <-> b) -> (~a <-> ~b) $ = 'con3b;
theorem notbii (h: $ a <-> b $): $ ~a <-> ~b $ = '(notbi h);
theorem notbid (h: $ a -> (b <-> c) $): $ a -> (~b <-> ~c) $ = '(syl h notbi);
theorem imbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b -> d <-> c -> e) $ =
'(ibid (imimd (bi2d h1) (bi1d h2)) (imimd (bi1d h1) (bi2d h2)));
theorem imbi1d (h: $ a -> (b <-> c) $): $ a -> (b -> d <-> c -> d) $ = '(imbid h biidd);
theorem imbi2d (h: $ a -> (c <-> d) $): $ a -> (b -> c <-> b -> d) $ = '(imbid biidd h);
theorem imbi1i (h: $ a <-> b $): $ a -> c <-> b -> c $ = '(imbi1d id h);
theorem imbi2i (h: $ b <-> c $): $ a -> b <-> a -> c $ = '(imbi2d id h);
theorem imbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a -> c <-> b -> d $ = '(bitr (imbi1i h1) (imbi2i h2));
theorem anbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b /\ d <-> c /\ e) $ =
'(ibid (animd (bi1d h1) (bi1d h2)) (animd (bi2d h1) (bi2d h2)));
theorem anbi1d (h: $ a -> (b <-> c) $): $ a -> (b /\ d <-> c /\ d) $ = '(anbid h biidd);
theorem anbi2d (h: $ a -> (c <-> d) $): $ a -> (b /\ c <-> b /\ d) $ = '(anbid biidd h);
theorem anbi1i (h: $ a <-> b $): $ a /\ c <-> b /\ c $ = '(anbi1d id h);
theorem anbi2i (h: $ b <-> c $): $ a /\ b <-> a /\ c $ = '(anbi2d id h);
theorem bibid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> ((b <-> d) <-> (c <-> e)) $ =
'(anbid (imbid h1 h2) (imbid h2 h1));
theorem bibi1d (h: $ a -> (b <-> c) $): $ a -> ((b <-> d) <-> (c <-> d)) $ = '(bibid h biidd);
theorem bibi2d (h: $ a -> (c <-> d) $): $ a -> ((b <-> c) <-> (b <-> d)) $ = '(bibid biidd h);
theorem bibi: $ (a <-> b) -> (c <-> d) -> ((a <-> c) <-> (b <-> d)) $ = '(exp (bibid anl anr));

def or (a b: wff): wff = $ ~a -> b $;
infixl or: $\/$ prec 30;

theorem orl: $ a -> a \/ b $ = 'absurdr;
theorem orr: $ b -> a \/ b $ = 'ax_1;
theorem eori (h1: $ a -> c $) (h2: $ b -> c $): $ a \/ b -> c $ =
'(casesd (a1i h1) (imim2i h2));
theorem eord (h1: $ a -> b -> d $) (h2: $ a -> c -> d $):
  $ a -> b \/ c -> d $ = '(com12 (eori (com12 h1) (com12 h2)));
theorem orld (h: $ a -> b $): $ a -> b \/ c $ = '(syl h orl);
theorem orrd (h: $ a -> c $): $ a -> b \/ c $ = '(syl h orr);
theorem eor: $ (a -> c) -> (b -> c) -> a \/ b -> c $ = '(exp (eord anl anr));
theorem orimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b \/ d -> c \/ e $ =
'(eord (syl6 h1 orl) (syl6 h2 orr));
theorem orim1d (h: $ a -> b -> c $): $ a -> b \/ d -> c \/ d $ = '(orimd h idd);
theorem orim2d (h: $ a -> c -> d $): $ a -> b \/ c -> b \/ d $ = '(orimd idd h);
theorem orbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b \/ d <-> c \/ e) $ =
'(ibid (orimd (bi1d h1) (bi1d h2)) (orimd (bi2d h1) (bi2d h2)));
theorem orbi1d (h: $ a -> (b <-> c) $): $ a -> (b \/ d <-> c \/ d) $ = '(orbid h biidd);
theorem orbi2d (h: $ a -> (c <-> d) $): $ a -> (b \/ c <-> b \/ d) $ = '(orbid biidd h);
theorem orbi1i (h: $ a <-> b $): $ a \/ c <-> b \/ c $ = '(orbi1d id h);
theorem orbi2i (h: $ b <-> c $): $ a \/ b <-> a \/ c $ = '(orbi2d id h);
theorem orbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a \/ c <-> b \/ d $ = '(bitr (orbi1i h1) (orbi2i h2));
theorem orcom: $ a \/ b -> b \/ a $ = 'con1;
theorem notan2: $ ~(a /\ b) <-> a -> ~b $ = '(bicom notnot);
theorem notan: $ ~(a /\ b) <-> (~a \/ ~b) $ = '(bitr notan2 (imbi1i notnot));
theorem notor: $ ~(a \/ b) <-> (~a /\ ~b) $ = '(con1b (bitr4 notan (orbii notnot notnot)));
theorem em: $ p \/ ~p $ = 'id;

abstract def ifp (p a b: wff): wff = $ p /\ a \/ ~p /\ b $;

theorem ifpbid (h1: $ G -> (p <-> q) $) (h2: $ G -> (a <-> c) $) (h3: $ G -> (b <-> d) $):
  $ G -> (ifp p a b <-> ifp q c d) $ = '(orbid (anbid h1 h2) (anbid (notbid h1) h3));
theorem ifpbi1d (h: $ G -> (p <-> q) $): $ G -> (ifp p a b <-> ifp q a b) $ = '(ifpbid h biidd biidd);
theorem ifpbi2d (h: $ G -> (a <-> b) $): $ G -> (ifp p a c <-> ifp p b c) $ = '(ifpbid biidd h biidd);
theorem ifpbi3d (h: $ G -> (b <-> c) $): $ G -> (ifp p a b <-> ifp p a c) $ = '(ifpbid biidd biidd h);

pub theorem ifptrue (p a b: wff): $ p -> (ifp p a b <-> a) $ =
'(ibid (eord (a1i anr) (syl5 anl absurdr)) (exp orl));
pub theorem ifpfalse (p a b: wff): $ ~p -> (ifp p a b <-> b) $ =
'(ibid (eord (syl5 anl absurd) (a1i anr)) (exp orr));

term wtru: wff; prefix wtru: $T.$ prec max;
axiom tru: $ T. $;
def fal: wff = $ ~T. $; prefix fal: $F.$ prec max;

theorem trud (h: $ T. -> a $): $ a $ = '(h tru);
theorem notfal: $ ~F. $ = '(notnot1 tru);
theorem efal: $ F. -> a $ = '(absurd notfal);

sort nat;
term al {x: nat} (ph: wff x): wff; prefix al: $A.$ prec 40;

def ex {x: nat} (ph: wff x): wff = $ ~(A. x ~ph) $;
prefix ex: $E.$ prec 40;

term eq (a b: nat): wff; infixl eq: $=$ prec 50;

axiom ax_gen (ph: wff) {x: nat}: $ ph $ > $ A. x ph $;
axiom ax_4 {x: nat} (ph ps: wff x): $ A. x (ph -> ps) -> A. x ph -> A. x ps $;
axiom ax_5 {x: nat} (ph: wff): $ ph -> A. x ph $;
axiom ax_6 (a: nat) {x: nat}: $ E. x x = a $;
axiom ax_7 (a b c: nat): $ a = b -> a = c -> b = c $;
axiom ax_10 {x: nat} (ph: wff x): $ ~(A. x ph) -> A. x ~ (A. x ph) $;
axiom ax_11 {x y: nat} (ph: wff x y): $ A. x A. y ph -> A. y A. x ph $;
axiom ax_12 {x y: nat} (ph: wff y): $ A. y ph -> A. x (x = y -> ph) $;

theorem alimi (a b: wff x) (h: $ a -> b $): $ A. x a -> A. x b $ = '(ax_4 (ax_gen h));
theorem iald (a: wff) (b: wff x) (h: $ a -> b $): $ a -> A. x b $ = '(syl ax_5 (alimi h));
theorem albi (a b: wff x): $ A. x (a <-> b) -> (A. x a <-> A. x b) $ =
'(ibid (rsyl ax_4 @ alimi bi1) (rsyl ax_4 @ alimi bi2));
theorem albii (a b: wff x) (h: $ a <-> b $): $ A. x a <-> A. x b $ = '(albi @ ax_gen h);
theorem alimd (G: wff) (a b: wff x) (h: $ G -> a -> b $):
  $ G -> A. x a -> A. x b $ = '(rsyl ax_4 @ rsyl ax_5 h);
theorem albid (G: wff) (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (A. x a <-> A. x b) $ = '(rsyl albi @ iald h);
theorem alan (a b: wff x): $ A. x (a /\ b) <-> A. x a /\ A. x b $ =
'(ibii (iand (alimi anl) (alimi anr)) (imp (syl (alimi ian) ax_4)));
theorem exim (a b: wff x): $ A. x (a -> b) -> E. x a -> E. x b $ =
'(syl (syl (alimi con3) ax_4) con3);
theorem eximi (a b: wff x) (h: $ a -> b $): $ E. x a -> E. x b $ = '(exim (ax_gen h));
theorem exbi (a b: wff x): $ A. x (a <-> b) -> (E. x a <-> E. x b) $ =
'(notbid @ rsyl albi @ alimi notbi);
theorem exbid (G: wff) (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (E. x a <-> E. x b) $ = '(rsyl exbi @ iald h);
theorem exbii (a b: wff x) (h: $ a <-> b $):
  $ E. x a <-> E. x b $ = '(exbi @ ax_gen h);
theorem iex (a: wff x): $ a -> E. x a $ =
'(syl (syl (!! ax_5 y) ax_12) (mpi ax_6 exim));
theorem alnex (a: wff x): $ A. x ~a <-> ~(E. x a) $ = 'notnot;
theorem ngen (a: wff x) (h: $ ~a $): $ ~E. x a $ = '(notnot1 (ax_gen h));
theorem alex (a: wff x): $ A. x a <-> ~(E. x ~a) $ =
'(bitr (albii notnot) alnex);
theorem exnal (a: wff x): $ E. x ~a <-> ~(A. x a) $ = '(con2b alex);
theorem eal (a: wff x): $ A. x a -> a $ = '(ax_3 (sylib iex exnal));
theorem exor (a b: wff x): $ E. x (a \/ b) <-> E. x a \/ E. x b $ =
'(bitr (notbii (bitr (albii notor) alan)) notan);
theorem eximd (G) (a b: wff x) (h: $ G -> a -> b $): $ G -> E. x a -> E. x b $ = '(syl (iald h) exim);

local def nf {x: nat} (a: wff x): wff = $ A. x (a -> A. x a) $;
prefix nf: $F/$ prec 10;

theorem nfv: $ F/ x a $ = '(ax_gen ax_5);
theorem nfi (a: wff x) (h: $ F/ x a $): $ a -> A. x a $ = '(eal h);
theorem nfri (a: wff x) (h: $ a -> A. x a $): $ F/ x a $ = '(ax_gen h);
theorem nfbii (a b: wff x) (h: $ a <-> b $): $ (F/ x a) <-> (F/ x b) $ = '(albii (imbii h (albii h)));
theorem nfx (a b: wff x) (h1: $ a <-> b $) (h2: $ F/ x b $): $ F/ x a $ = '(bi2i (nfbii h1) h2);
theorem nfal1 (a: wff x): $ F/ x A. x a $ = '(ax_gen ax_5);
theorem nfal (a: wff x y) (h: $ F/ x a $): $ F/ x A. y a $ =
'(nfri (syl (alimi (nfi h)) ax_11));
theorem nfnot (a: wff x) (h: $ F/ x a $): $ F/ x ~a $ =
'(nfri (con1 (syl (eximi (nfi h)) (syl (con1 (!! ax_10 x)) eal))));
theorem nfim (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a -> b $ =
'(nfri @ cases
   (syl6 (com12 id) @ syl (nfi h2) @ alimi ax_1)
   (a1d @ syl (nfi (nfnot h1)) @ alimi absurd));
theorem nfan (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a /\ b $ = '(nfnot (nfim h1 (nfnot h2)));
theorem nfor (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a \/ b $ = '(nfim (nfnot h1) h2);
theorem nfbi (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a <-> b $ = '(nfan (nfim h1 h2) (nfim h2 h1));
theorem nfex1 (a: wff x): $ F/ x E. x a $ = '(nfnot nfal1);
theorem nfex (a: wff x y) (h: $ F/ x a $): $ F/ x E. y a $ = '(nfnot (nfal (nfnot h)));

theorem ialdh (a b: wff x) (h1: $ F/ x a $) (h2: $ a -> b $): $ a -> A. x b $ =
'(syl (nfi h1) (alimi h2));
theorem eexh (a b: wff x) (h1: $ F/ x b $) (h2: $ a -> b $): $ E. x a -> b $ =
'(con1 (ialdh (nfnot h1) (con3 h2)));
theorem eex (a: wff x) (b: wff) (h: $ a -> b $): $ E. x a -> b $ = '(eexh nfv h);
theorem eexdh (a b c: wff x) (h1: $ F/ x a $) (h2: $ F/ x c $)
  (h3: $ a -> b -> c $): $ a -> E. x b -> c $ =
'(con1d @ exp @ ialdh (nfan h1 (nfnot h2)) (imp @ con3d h3));
theorem eexd (a: wff) (b: wff x) (c: wff)
  (h: $ a -> b -> c $): $ a -> E. x b -> c $ = '(eexdh nfv nfv h);
theorem eexda (a: wff) (b: wff x) (c: wff)
  (h: $ a /\ b -> c $): $ a -> E. x b -> c $ = '(eexd (exp h));
theorem eexb (a: wff x) (b: wff): $ (E. x a -> b) <-> A. x (a -> b) $ =
'(ibii (ialdh (nfim nfex1 nfv) (imim1i iex)) (eexdh nfal1 nfv eal));
theorem ealeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ =
'(eexh (nfim nfal1 h) (syl6 (alimd (bi1d e)) eal) ax_6);
theorem iexeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(con2 (ealeh (nfnot h) (notbid e)));
theorem eale (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ = '(ealeh nfv e);
theorem iexde (G: wff) (a: nat) (b: wff x)
  (e: $ G /\ x = a -> b $): $ G -> E. x b $ = '(mpi ax_6 (eximd (exp e)));
theorem iexe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(iexde (mpbird anl (anwr e)));
theorem ealde (G: wff) (a: nat) (b: wff x)
  (e: $ G /\ x = a -> b -> c $): $ G -> A. x b -> c $ =
'(con4d (exp (sylib (iexde (an32s (imp (con3d e)))) exnal)));

theorem eqtr3: $ b = a -> b = c -> a = c $ = 'ax_7;
theorem eqid: $ a = a $ = '(!! eex x (imidm ax_7) ax_6);
theorem eqcom: $ a = b -> b = a $ = '(mpi eqid ax_7);
theorem eqtr: $ a = b -> b = c -> a = c $ = '(syl eqcom ax_7);
theorem eqtr4: $ a = b -> c = b -> a = c $ = '(syl5 eqcom eqtr);
theorem eqcomb: $ a = b <-> b = a $ = '(ibii eqcom eqcom);
theorem eqeq1: $ a = b -> (a = c <-> b = c) $ = '(ibid eqtr3 eqtr);
theorem eqeq2: $ b = c -> (a = b <-> a = c) $ = '(ibid (com12 eqtr) (com12 eqtr4));
theorem eqeq1d (h: $ G -> a = b $): $ G -> (a = c <-> b = c) $ = '(syl h eqeq1);
theorem eqeq2d (h: $ G -> b = c $): $ G -> (a = b <-> a = c) $ = '(syl h eqeq2);
theorem eqeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a = c <-> b = d) $ = '(bitrd (eqeq1d h1) (eqeq2d h2));
theorem eqeq: $ a = b -> c = d -> (a = c <-> b = d) $ = '(exp (eqeqd anl anr));
theorem eqtr3d (h1: $ G -> b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc h1 h2 eqtr3);
theorem eqidd: $ G -> a = a $ = '(a1i eqid);
theorem eqcomd (h: $ G -> a = b $): $ G -> b = a $ = '(syl h eqcom);
theorem eqtrd (h1: $ G -> a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc h1 h2 eqtr);
theorem eqtr4d (h1: $ G -> a = b $) (h2: $ G -> c = b $): $ G -> a = c $ = '(sylc h1 h2 eqtr4);
theorem syl5eq (h1: $ a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtrd (a1i h1) h2);
theorem syl5eqr (h1: $ b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtr3d (a1i h1) h2);
theorem syl6eq (h1: $ G -> a = b $) (h2: $ b = c $): $ G -> a = c $ = '(eqtrd h1 (a1i h2));
theorem syl6eqr (h1: $ G -> a = b $) (h2: $ c = b $): $ G -> a = c $ = '(eqtr4d h1 (a1i h2));
theorem eqtr4g (h1: $ G -> a = b $) (h2: $ c = a $) (h3: $ d = b $):
  $ G -> c = d $ = '(syl5eq h2 (syl6eqr h1 h3));

theorem cbvalh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ =
'(ibii (ialdh (nfal h1) (eale e))
  (ialdh (nfal h2) (eale @ bicomd @ syl eqcom e)));
theorem cbval (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ = '(cbvalh nfv nfv e);

theorem cbvexh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ =
'(notbi (cbvalh (nfnot h1) (nfnot h2) (notbid e)));
theorem cbvex (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ = '(cbvexh nfv nfv e);

def ne (a b: nat): wff = $ ~ a = b $; infixl ne: $!=$ prec 50;

theorem neeq1: $ a = b -> (a != c <-> b != c) $ = '(notbid eqeq1);
theorem neeq2: $ b = c -> (a != b <-> a != c) $ = '(notbid eqeq2);
theorem neeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a != c <-> b != d) $ = '(notbid (eqeqd h1 h2));
theorem necom: $ a != b -> b != a $ = '(con3 eqcom);

def sb (a: nat) {x .y: nat} (ph: wff x): wff =
  $ A. y (y = a -> A. x (x = y -> ph)) $;
notation sb (a x ph) = ($[$:30) a ($/$:0) x ($]$:0) ph;

theorem sbeq (a: nat) (b: wff x): $ x = a -> (b <-> [a / x] b) $ =
'(ibid (exp @ !! iald y @ a1d @ syl (anwr ax_5) ax_12)
  (mpi ax_6 @ eexd @ exp @ syl5 eal @ syld (com12 (imim1i anr)) @
    syl (imp eqtr4) @ com12 eal));
theorem nfsb1 (a: nat) (b: wff x): $ F/ x [a / x] b $ =
'(!! nfal _ y (nfim nfv nfal1));
theorem nfsb (a: nat) (b: wff x) (h: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ z (nfim nfv (nfal (nfim nfv h))));
theorem sbeq1d (G: wff) (a b: nat) (c: wff x)
  (h: $ G -> a = b $): $ G -> ([a / x] c <-> [b / x] c) $ =
'(!! albid y (imbi1d (eqeq2d h)));
theorem sbeq2d (G: wff) (a: nat x) (b c: wff x)
  (h: $ G -> (b <-> c) $): $ G -> ([a / x] b <-> [a / x] c) $ =
'(!! albid y (imbi2d (albid (imbi2d h))));

theorem sbeht (a: nat) (b c: wff x) (h: $ F/ x c $):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ =
'(eexh (nfim nfal1 (nfbi nfsb1 nfv))
  (exp (bitr3d (anwl sbeq) (impcom eal))) ax_6);
theorem sbeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeht h (ax_gen e));
theorem sbet (a: nat) (b: wff x) (c: wff):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ = '(sbeht nfv);
theorem sbe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeh nfv e);
theorem sbed (a: nat) (b: wff x) (c: wff)
  (e: $ G /\ x = a -> (b <-> c) $): $ G -> ([a / x] b <-> c) $ =
'(rsyl sbet @ iald @ exp e);
theorem dfsb2 (a: nat) (b: wff x): $ [a / x] b <-> A. x (x = a -> b) $ =
'(ibii
  (mpi (!! ax_6 y) @ eexd @ syl eal @ a2i @ alimd @ imim1d @ com12 eqtr4)
  (iald @ com12 @ alimd @ imim1d @ com12 eqtr));
theorem dfsb3 (a: nat) (b: wff x): $ [a / x] b <-> E. x (x = a /\ b) $ =
'(sbeh nfex1 (syl (syl5bb (bitr4 (albii notan2) dfsb2) (bicomd sbeq)) con2b));
theorem sbco (a: nat x) (b: wff x):
  $ [a / y] [y / x] b <-> [a / x] b $ = '(bitr dfsb2 (albii (imbi2i dfsb2)));
theorem sbid (a: wff x): $ [x / x] a <-> a $ =
'(ibii (mpi (!! ax_6 y) @ eexd @ syl eal @ a2i @ syl eqcom @ com12 eal)
  (iald @ com12 @ bi1d @ syl6bb (syl eqcom sbeq) dfsb2));
theorem cbvsbh (a: nat) (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ =
'(!! albii z (imbi2i (cbvalh (nfim nfv h1) (nfim nfv h2) (imbid (eqeq1) e))));
theorem cbvsb (a: nat) (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ = '(cbvsbh nfv nfv e);

theorem aleqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ A. x (x = a -> p) <-> q $ = '(bitr3 dfsb2 (sbe e));
theorem exeqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ E. x (x = a /\ p) <-> q $ = '(bitr3 dfsb3 (sbe e));
theorem cbvals (p: wff x): $ A. x p <-> A. y ([y / x] p) $ = '(cbvalh nfv nfsb1 sbeq);
theorem cbvexs (p: wff x): $ E. x p <-> E. y ([y / x] p) $ = '(cbvexh nfv nfsb1 sbeq);
theorem cbvald (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (A. x p <-> A. y q) $ =
'(bitrd (a1i cbvals) (albid (syl (iald (exp h)) sbet)));
theorem cbvexd (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (E. x p <-> E. y q) $ =
'(bitrd (a1i cbvexs) (exbid (syl (iald (exp h)) sbet)));

strict sort set;
term ab {x: nat} (p: wff x): set;
notation ab {x: nat} (p: wff x): set = (${$:max) x ($|$:0) p ($}$:0);
term el: nat > set > wff; infixl el: $e.$ prec 50;
axiom elab (a: nat) {x: nat} (p: wff x):
  $ a e. {x | p} <-> [a / x] p $;
axiom ax_8 (a b: nat) (A: set): $ a = b -> a e. A -> b e. A $;

def eqs (A B: set) {.x: nat}: wff = $ A. x (x e. A <-> x e. B) $;
infixl eqs: $==$ prec 50;

theorem eqsid: $ A == A $ = '(!! ax_gen x biid);
theorem eqscom: $ A == B -> B == A $ = '(!! alimi x bicom);
theorem eqstr: $ A == B -> B == C -> A == C $ = '(syl (!! alimi x bitr) ax_4);
theorem eqstr3: $ B == A -> B == C -> A == C $ = '(syl eqscom eqstr);
theorem eqstr4: $ A == B -> C == B -> A == C $ = '(syl5 eqscom eqstr);
theorem eqseq1: $ A == B -> (A == C <-> B == C) $ = '(ibid eqstr3 eqstr);
theorem eqseq2: $ B == C -> (A == B <-> A == C) $ = '(ibid (com12 eqstr) (com12 eqstr4));
theorem eqseq1d (h: $ G -> A == B $): $ G -> (A == C <-> B == C) $ = '(syl h eqseq1);
theorem eqseq2d (h: $ G -> B == C $): $ G -> (A == B <-> A == C) $ = '(syl h eqseq2);
theorem eqseqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> (A == C <-> B == D) $ = '(bitrd (eqseq1d h1) (eqseq2d h2));
theorem eqseq: $ A == B -> C == D -> (A == C <-> B == D) $ = '(exp (eqseqd anl anr));
theorem eqstr3d (h1: $ G -> B == A $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc h1 h2 eqstr3);
theorem eqsidd: $ G -> A == A $ = '(a1i eqsid);
theorem eqscomd (h: $ G -> A == B $): $ G -> B == A $ = '(syl h eqscom);
theorem eqstrd (h1: $ G -> A == B $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc h1 h2 eqstr);
theorem eqstr4d (h1: $ G -> A == B $) (h2: $ G -> C == B $): $ G -> A == C $ = '(sylc h1 h2 eqstr4);

theorem eleq1: $ a = b -> (a e. A <-> b e. A) $ = '(ibid ax_8 (syl eqcom ax_8));
theorem eleq2: $ A == B -> (a e. A <-> a e. B) $ = 'eal;
theorem eleq1d (h: $ G -> a = b $): $ G -> (a e. A <-> b e. A) $ = '(syl h eleq1);
theorem eleq2d (h: $ G -> A == B $): $ G -> (a e. A <-> a e. B) $ = '(syl h eleq2);
theorem eleqd (h1: $ G -> a = b $) (h2: $ G -> A == B $):
  $ G -> (a e. A <-> b e. B) $ = '(bitrd (eleq1d h1) (eleq2d h2));

theorem abeq (p q: wff x): $ A. x (p <-> q) -> {x | p} == {x | q} $ =
'(!! iald y (bitr4g (ealeh (nfbi nfsb1 nfsb1) (bibid sbeq sbeq)) elab elab));
theorem abeqd (G: wff) (p q: wff x)
  (h: $ G -> (p <-> q) $): $ G -> {x | p} == {x | q} $ = '(syl (iald h) abeq);
theorem eqri {x} (h: $ x e. A <-> x e. B $): $ A == B $ = '(ax_gen h);
theorem eqrd (G) {x} (h: $ G -> (x e. A <-> x e. B) $): $ G -> A == B $ = '(iald h);
theorem cbvabh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ =
'(!! eqri z @ bitr4gi (cbvsbh h1 h2 e) elab elab);
theorem cbvab (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ = '(cbvabh nfv nfv e);
theorem cbvabs (p: wff x): $ {x | p} == {y | [y / x] p} $ = '(cbvabh nfv nfsb1 sbeq);
theorem cbvabd (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> {x | p} == {y | q} $ =
'(eqstrd (a1i cbvabs) @ abeqd @ syl (iald (exp h)) sbet);
theorem elab2 (a: nat x) (p: wff x): $ a e. {x | p} <-> [a / x] p $ =
'(bitr (bitr (eleq2 (cbvabh nfv nfsb1 sbeq)) elab) (!! sbco x y));
theorem elabe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ a e. {x | p} <-> q $ = '(bitr elab2 (sbe e));
theorem abid (p: wff x): $ x e. {x | p} <-> p $ = '(bitr elab2 sbid);
theorem abid2: $ {x | x e. A} == A $ = '(!! eqri y @ elabe eleq1);

def Inter (A B: set) (.x: nat): set = $ {x | x e. A /\ x e. B} $;
infixl Inter: $i^i$ prec 70;

theorem ineqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> A i^i C == B i^i D $ = '(!! abeqd x (anbid (eleq2d h1) (eleq2d h2)));

def Union (A B: set) (.x: nat): set = $ {x | x e. A \/ x e. B} $;
infixl Union: $u.$ prec 65;

theorem uneqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> A u. C == B u. D $ = '(!! abeqd x (orbid (eleq2d h1) (eleq2d h2)));

def Univ (.x: nat): set = $ {x | T.} $; prefix Univ: $V$ prec max;

local def nfs {x: nat} (A: set x): wff = $ A. y (F/ x y e. A) $;
prefix nfs: $FS/$ prec 10;
local def nfn {x: nat} (a: nat x): wff = $ A. y (F/ x y = a) $;
prefix nfn: $FN/$ prec 10;

theorem nfsv: $ FS/ x A $ = '(!! ax_gen y nfv);
theorem nfnv: $ FN/ x a $ = '(!! ax_gen y nfv);
theorem nfsri {x y} (A: set x) (h: $ F/ x y e. A $): $ FS/ x A $ = '(ax_gen h);
theorem nfnri {x y} (a: nat x) (h: $ F/ x y = a $): $ FN/ x a $ = '(ax_gen h);
theorem nfel2 (a: nat) (A: set x) (h: $ FS/ x A $): $ F/ x a e. A $ = '(eal h);
theorem nfeq (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ F/ x a = b $ =
'(nfx (bicom @ !! exeqe y eqeq1) (nfex @ nfan (eal h1) (eal h2)));
theorem nfeq2 (b: nat x) (h: $ FN/ x b $): $ F/ x a = b $ = '(nfeq nfnv h);
theorem nfel (a: nat x) (A: set x) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ F/ x a e. A $ =
'(nfx (bicom @ !! exeqe y eleq1) (nfex @ nfan (eal h1) (eal h2)));
theorem nfab1 (p: wff x): $ FS/ x {x | p} $ = '(!! nfsri _ y @ nfx elab nfsb1);
theorem nfab (p: wff y) (h: $ F/ x p $): $ FS/ x {y | p} $ = '(!! nfsri _ z @ nfx elab @ nfsb h);
theorem nfeqs (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ F/ x A == B $ =
'(!! nfal _ y @ nfbi (nfel2 h1) (nfel2 h2));
theorem nfnx (a b: nat x) (h1: $ a = b $) (h2: $ FN/ x b $): $ FN/ x a $ =
'(!! nfnri _ y @ nfx (eqeq2 h1) @ nfeq2 h2);

theorem nfsbh (a: nat x) (b: wff x) (h1: $ FN/ x a $) (h2: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ z (nfim (nfeq2 h1) (nfal (nfim nfv h2))));

theorem abeqb (p q: wff x): $ A. x (p <-> q) <-> {x | p} == {x | q} $ =
'(ibii abeq (ialdh (nfeqs nfab1 nfab1) (sylib eleq2 (bibi abid abid))));

def sbs (a: nat) {x .y: nat} (A: set x): set = $ {y | [a / x] y e. A} $;
notation sbs (a: nat) {x: nat} (A: set x): set =
  ($S[$:70) a ($/$:0) x ($]$:0) A;

theorem elsbs (a b: nat) (A: set x): $ b e. S[a / x] A <-> [a / x] b e. A $ =
'(bitr (!! elab y) (sbe (sbeq2d eleq1)));
theorem sbseq (a: nat) (A: set x): $ x = a -> A == S[a / x] A $ =
'(!! eqrd y (syl6bb sbeq (bicom elsbs)));
theorem nfsbs1 (a: nat) (A: set x): $ FS/ x S[a / x] A $ =
'(!! nfsri _ y (nfx elsbs nfsb1));
theorem nfsbsh (a: nat x) (A: set x y) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ FS/ x S[a / y] A $ =
'(!! nfsri _ z @ nfx elsbs @ nfsbh h1 @ nfel2 h2);
theorem nfsbs (a: nat) (A: set x y) (h: $ FS/ x A $): $ FS/ x S[a / y] A $ = '(nfsbsh nfnv h);
theorem sbseq1d (G: wff) (a b: nat) (A: set x) (h: $ G -> a = b $):
  $ G -> S[a / x] A == S[b / x] A $ = '(!! abeqd y (sbeq1d h));
theorem sbseq2d (G: wff) (a: nat x) (A B: set x)
  (h: $ G -> A == B $): $ G -> S[a / x] A == S[a / x] B $ =
'(!! abeqd y (sbeq2d (eleq2d h)));
theorem sbseht (a: nat) (A B: set x) (h: $ FS/ x B $):
  $ A. x (x = a -> A == B) -> S[a / x] A == B $ =
'(!! eqrd y @ syl5bb elsbs @ rsyl (sbeht @ nfel2 h) @ alimi @ imim2 eleq2);
theorem sbseh (a: nat) (A B: set x) (h: $ FS/ x B $)
  (e: $ x = a -> A == B $): $ S[a / x] A == B $ = '(sbseht h (ax_gen e));
theorem sbset (a: nat) (A: set x) (B: set):
  $ A. x (x = a -> A == B) -> S[a / x] A == B $ = '(sbseht nfsv);
theorem sbse (a: nat) (A: set x) (B: set)
  (e: $ x = a -> A == B $): $ S[a / x] A == B$ = '(sbseh nfsv e);
theorem sbsed (a: nat) (A: set x) (B: set)
  (e: $ G /\ x = a -> A == B $): $ G -> S[a / x] A == B $ =
'(rsyl sbset @ iald @ exp e);
theorem sbsid (a: set x): $ S[x / x] A == A $ =
'(!! eqri y @ bitr elsbs sbid);

term d0: nat; prefix d0: $0$ prec max;
term suc: nat > nat;

def d1:  nat = $suc 0$; prefix d1:  $1$  prec max;
def d2:  nat = $suc 1$; prefix d2:  $2$  prec max;
def d3:  nat = $suc 2$; prefix d3:  $3$  prec max;
def d4:  nat = $suc 3$; prefix d4:  $4$  prec max;
def d5:  nat = $suc 4$; prefix d5:  $5$  prec max;
def d6:  nat = $suc 5$; prefix d6:  $6$  prec max;
def d7:  nat = $suc 6$; prefix d7:  $7$  prec max;
def d8:  nat = $suc 7$; prefix d8:  $8$  prec max;
def d9:  nat = $suc 8$; prefix d9:  $9$  prec max;
def d10: nat = $suc 9$; prefix d10: $10$ prec max;

axiom peano1 (a: nat): $ suc a != 0 $;
axiom peano2 (a b: nat): $ suc a = suc b <-> a = b $;
axiom peano5 {x: nat} (ph: wff x):
  $ [0 / x] ph -> A. x (ph -> [suc x / x] ph) -> A. x ph $;

theorem d1ne0: $ 1 != 0 $ = 'peano1;
theorem d2ne0: $ 2 != 0 $ = 'peano1;
theorem suceq: $ a = b -> suc a = suc b $ = '(bi2 peano2);
theorem suceqd (h: $ G -> a = b $): $ G -> suc a = suc b $ = '(syl h suceq);

theorem ind {x y} (a) (px: wff x) (p0 pa: wff) (py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ p0 $) (h2: $ py -> ps $): $ pa $ =
'(eale ha @ peano5
  (mpbir h1 (sbe h0))
  (mpbir (ax_gen @ syl h2 @ bi2i @ sbe hs)
    (cbvalh nfv (nfim nfv nfsb1) @ imbid hy @ sbeq1d suceq)));

theorem indd {x y} (a) (px: wff x) (p0 pa: wff) (py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ G -> p0 $) (h2: $ G /\ py -> ps $): $ G -> pa $ =
'(ind (imbi2d h0) (imbi2d hy) (imbi2d hs) (imbi2d ha) h1 (a2i (exp h2)));

theorem exsuc (a: nat): $ a != 0 <-> E. x suc x = a $ =
'(ibii
  (! ind y z _ $ y != 0 -> E. x suc x = y $ _ _ _ _
    (imbid (notbid eqeq1) (exbid eqeq2)) (imbid (notbid eqeq1) (exbid eqeq2))
    (imbid (notbid eqeq1) (exbid eqeq2)) (imbid (notbid eqeq1) (exbid eqeq2))
    (absurdr eqid) (a1i (a1i (iexe (eqeq1d suceq) eqid))))
  (eex (mpbii peano1 neeq1)));

term the: set > nat;
axiom theid {x: nat} (A: set) (a: nat): $ A == {x | x = a} -> the A = a $;
axiom the0 {x y: nat} (A: set): $ ~E. y A == {x | x = y} -> the A = 0 $;

theorem theeqd (h: $ G -> A == B $): $ G -> the A = the B $ =
'(! casesd _ $ E. y A == {x | x = y} $ _
  (eexda (eqtr4d (anwr theid) (syl (imp (syl h eqstr3)) theid)))
  (exp (eqtr4d (anwr the0) (syl (impbi (notbid (exbid (eqseq1d h)))) the0))));
theorem eqthed {x} (h: $ G -> (x e. A <-> x = a) $): $ G -> the A = a $ =
'(syl (eqrd (syl6bb h (bicom (elabe eqeq1)))) (!! theid z));
theorem eqtheabd (p: wff x) (h: $ G -> (p <-> x = a) $): $ G -> the {x | p} = a $ =
'(!! eqthed y @ syl5bb elab @
  syl (iald h) @ ealeh (nfbi nfsb1 nfv) @ bibid sbeq eqeq1);

theorem eqthe0d {x} (h: $ G -> x e. A -> x = 0 $): $ G -> the A = 0 $ =
(focus
  '(casesd (eexda _) (a1i (!! the0 y x)))
  '(syl (eqstrd anr (syl _ (abeqd eqeq2))) theid)
  '(mpd (mpbiri (mpbir eqid (elabe eqeq1)) (anwr eleq2)) (anwl h)));
theorem eqthe0abd (p: wff x) (h: $ G -> p -> x = 0 $): $ G -> the {x | p} = 0 $ =
'(!! eqthe0d y @ syl5bi elab @
  syl (iald h) @ ealeh (nfim nfsb1 nfv) @ imbid sbeq eqeq1);

theorem eqtheb: $ a = the A <-> (A == {x | x = a} \/ ~E. y A == {x | x = y} /\ a = 0) $ =
'(ibii
  (casesda
    (imp @ eexd @ exp @ orld @ mpbird anr @
      syl (eqtrd anl @ anwr theid) (eqseq2d @ abeqd eqeq2))
    (orrd @ iand anr @ eqtrd anl @ anwr the0))
  (eor (eqcomd theid) (eqtrd anr @ anwl @ eqcomd the0)));

theorem nfthe (A: set x) (h: $ FS/ x A $): $ FN/ x the A $ =
'(!! nfnri _ y (nfx (!! eqtheb u v)
  (nfor (nfeqs h nfsv) (nfan (nfnot (nfex (nfeqs h nfsv))) nfv))));

def sbn (a: nat) {x .y: nat} (b: nat x): nat = $ the {y | [a / x] y = b} $;
notation sbn (a: nat) {x: nat} (b: nat x): nat =
  ($N[$:70) a ($/$:0) x ($]$:0) b;

theorem sbneq (a: nat) (b: nat x): $ x = a -> b = N[a / x] b $ =
'(eqcomd @ !! eqtheabd y @ bicomd sbeq);
theorem nfsbn1 (a: nat) (b: nat x): $ FN/ x N[a / x] b $ =
'(nfthe @ !! nfab _ y nfsb1);
theorem nfsbnh (a b: nat x y) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x N[a / y] b $ =
'(nfthe @ !! nfab _ y @ nfsbh h1 @ nfeq2 h2);
theorem nfsbn (a: nat) (b: nat x y) (h: $ FN/ x b $): $ FN/ x N[a / y] b $ = '(nfsbnh nfnv h);
theorem sbneq2d (G: wff) (a b c: nat x)
  (h: $ G -> b = c $): $ G -> N[a / x] b = N[a / x] c $ =
'(theeqd @ !! cbvabd y z @ sbeq2d @ eqeqd anr @ anwl h);
theorem sbneht (a: nat) (b c: nat x) (h: $ FN/ x c $):
  $ A. x (x = a -> b = c) -> N[a / x] b = c $ =
'(!! eqtheabd y @ rsyl (sbeht @ nfeq2 h) @ alimi @ imim2 eqeq2);
theorem sbneh (a: nat) (b c: nat x) (h: $ FN/ x c $)
  (e: $ x = a -> b = c $): $ N[a / x] b = c $ = '(sbneht h @ ax_gen e);
theorem sbnet (a: nat) (b: nat x) (c: nat):
  $ A. x (x = a -> b = c) -> N[a / x] b = c $ = '(sbneht nfnv);
theorem sbne (a: nat) (b: nat x) (c: nat)
  (e: $ x = a -> b = c $): $ N[a / x] b = c $ = '(sbneh nfnv e);
theorem sbned (a: nat) (b: nat x) (c: nat)
  (e: $ G /\ x = a -> b = c $): $ G -> N[a / x] b = c $ = '(rsyl sbnet @ iald @ exp e);
theorem sbneq1 (a b: nat) (c: nat x): $ a = b -> N[a / x] c = N[b / x] c $ =
'(rsyl (sbneht nfsbn1) @ iald @ syl6 (bi1d eqeq2) sbneq);
theorem sbnid (a: nat x): $ N[x / x] a = a $ = '(trud @ !! eqtheabd y @ a1i sbid);

theorem nfnlem {y} (a c: nat x) (e: $ y = a -> b = c $) (h: $ FN/ x a $): $ FN/ x c $ =
'(nfnx (eqcom @ sbne e) @ nfsbnh h nfnv);
theorem nfnlem2 {y z} (a b d: nat x) (e: $ y = a /\ z = b -> c = d $)
  (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x d $ =
'(nfnx (eqcom @ sbne @ sbned e) @ nfsbnh h1 @ nfsbnh h2 nfnv);

theorem nfsuc (a: nat x) (h: $ FN/ x a $): $ FN/ x suc a $ = '(!! nfnlem _ y suceq h);

term add: nat > nat > nat; infixl add: $+$ prec 65;
term mul: nat > nat > nat; infixl mul: $*$ prec 70;

axiom addeq (a b c d: nat): $ a = b -> c = d -> a + c = b + d $;
axiom muleq (a b c d: nat): $ a = b -> c = d -> a * c = b * d $;
axiom add0 (a: nat): $ a + 0 = a $;
axiom addS (a b: nat): $ a + suc b = suc (a + b) $;
axiom mul0 (a: nat): $ a * 0 = 0 $;
axiom mulS (a b: nat): $ a * suc b = a * b + a $;

theorem addeq1: $ a = b -> a + c = b + c $ = '(mpi eqid addeq);
theorem muleq1: $ a = b -> a * c = b * c $ = '(mpi eqid muleq);
theorem addeq2: $ a = b -> c + a = c + b $ = '(addeq eqid);
theorem muleq2: $ a = b -> c * a = c * b $ = '(muleq eqid);
theorem addeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a + c = b + d $ = '(sylc h1 h2 addeq);
theorem muleqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a * c = b * d $ = '(sylc h1 h2 muleq);
theorem nfadd (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $):
  $ FN/ x a + b $ = '(!! nfnlem2 _ y z (addeqd anl anr) h1 h2);
theorem nfmul (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $):
  $ FN/ x a * b $ = '(!! nfnlem2 _ y z (muleqd anl anr) h1 h2);

theorem add02: $ a + 0 = a $ = 'add0;
theorem add01: $ 0 + a = a $ =
'(! ind x y _ $ 0 + x = x $ _ _ _ _
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  add0 (syl5eq addS suceq));

theorem addS2: $ a + suc b = suc (a + b) $ = 'addS;
theorem addS1: $ suc a + b = suc (a + b) $ =
'(! ind x y _ $ suc a + x = suc (a + x) $ _ _ _ _
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqtr4 add0 (suceq add0))
  (syl5eq addS (suceqd (syl6eqr id addS))));

theorem add12: $ a + 1 = suc a $ = '(eqtr addS (suceq add0));
theorem add11: $ 1 + a = suc a $ = '(eqtr addS1 (suceq add01));

theorem addcom: $ a + b = b + a $ =
'(! ind x y _ $ a + x = x + a $ _ _ _ _
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqtr4 add0 add01) (eqtr4g suceq addS addS1));

theorem addass: $ (a + b) + c = a + (b + c) $ =
'(! ind x y _ $ (a + b) + x = a + (b + x) $ _ _ _ _
  (eqeqd addeq2 (syl addeq2 addeq2)) (eqeqd addeq2 (syl addeq2 addeq2))
  (eqeqd addeq2 (syl addeq2 addeq2)) (eqeqd addeq2 (syl addeq2 addeq2))
  (eqtr4 add0 (addeq2 add0))
  (eqtr4g suceq addS (eqtr (addeq2 addS) addS)));

theorem add32: $ (a + b) + c = (a + c) + b $ =
'(eqtr addass (eqtr4 (addeq2 addcom) addass));

theorem addcan1: $ a + c = b + c <-> a = b $ =
'(! ind x y _ $ a + x = b + x <-> a = b $ _ _ _ _
  (bibi1d (eqeqd addeq2 addeq2)) (bibi1d (eqeqd addeq2 addeq2))
  (bibi1d (eqeqd addeq2 addeq2)) (bibi1d (eqeqd addeq2 addeq2))
  (eqeq add0 add0) (syl5bb (bitr (eqeq addS addS) peano2) id));
theorem addcan2: $ a + b = a + c <-> b = c $ =
'(bitr (eqeq addcom addcom) addcan1);

theorem mul02: $ a * 0 = 0 $ = 'mul0;
theorem mul01: $ 0 * a = 0 $ =
'(! ind x y _ $ 0 * x = 0 $ _ _ _ _
  (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2)
  mul0 (syl5eq (eqtr mulS add0) id));

theorem mulS2: $ a * suc b = a * b + a $ = 'mulS;
theorem mulS1: $ suc a * b = a * b + b $ =
'(! ind x y _ $ suc a * x = a * x + x $ _ _ _ _
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqtr4 mul0 (eqtr add0 mul0))
  (eqtr4g addeq1 mulS @ eqtr (addeq1 mulS) @
    eqtr addS @ eqtr4 (suceq add32) addS));

theorem mulcom: $ a * b = b * a $ =
'(! ind x y _ $ a * x = x * a $ _ _ _ _
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqtr4 mul0 mul01) (eqtr4g addeq1 mulS mulS1));

theorem mul12: $ a * 1 = a $ = '(eqtr mulS (eqtr (addeq1 mul0) add01));
theorem mul11: $ 1 * a = a $ = '(eqtr mulcom mul12);
theorem mul22: $ a * 2 = a + a $ = '(eqtr mulS2 @ addeq1 mul12);
theorem mul21: $ 2 * a = a + a $ = '(eqtr mulcom mul22);

theorem muladd: $ a * (b + c) = a * b + a * c $ =
'(! ind x y _ $ a * (b + x) = a * b + a * x $ _ _ _ _
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqeqd (syl addeq2 muleq2) (syl muleq2 addeq2))
  (eqtr4 (muleq2 add0) (eqtr (addeq2 mul0) add0))
  (eqtr4g addeq1 (eqtr (muleq2 addS) mulS) (eqtr4 (addeq2 mulS) addass)));

theorem addmul: $ (a + b) * c = a * c + b * c $ =
'(eqtr mulcom (eqtr muladd (addeq mulcom mulcom)));

theorem mulass: $ (a * b) * c = a * (b * c) $ =
'(! ind x y _ $ (a * b) * x = a * (b * x) $ _ _ _ _
  (eqeqd muleq2 (syl muleq2 muleq2)) (eqeqd muleq2 (syl muleq2 muleq2))
  (eqeqd muleq2 (syl muleq2 muleq2)) (eqeqd muleq2 (syl muleq2 muleq2))
  (eqtr4 mul0 (eqtr (muleq2 mul0) mul0))
  (eqtr4g addeq1 mulS (eqtr (muleq2 mulS) muladd)));

def sub (a b: nat): nat = $ the {x | b + x = a} $;
infixl sub: $-$ prec 65;

theorem subeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a - c = b - d $ =
'(theeqd (!! cbvabd x y (eqeqd (addeqd (anwl h2) anr) (anwl h1))));
theorem subeq: $ a = b -> c = d -> a - c = b - d $ = '(exp (subeqd anl anr));
theorem subeq1: $ a = b -> a - c = b - c $ = '(mpi eqid subeq);
theorem subeq2: $ a = b -> c - a = c - b $ = '(subeq eqid);

theorem eqsub2: $ a + b = c -> c - a = b $ =
'(!! eqthed x (syl5bb (!! elabe y (eqeq1d addeq2)) (syl6bb (bicomd eqeq2) addcan2)));
theorem eqsub1: $ a + b = c -> c - b = a $ = '(sylbi (eqeq1 addcom) eqsub2);
theorem pncan: $ a + b - b = a $ = '(eqsub1 eqid);
theorem pncan2: $ a + b - a = b $ = '(eqsub2 eqid);
theorem sub02: $ a - 0 = a $ = '(eqsub1 add0);

def le (a b .x: nat): wff = $ E. x a + x = b $;
infixl le: $<=$ prec 50;

theorem dfle: $ a <= b <-> E. x a + x = b $ = '(!! cbvex y x (eqeq1d addeq2));

theorem leeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> (a <= c <-> b <= d) $ =
'(!! cbvexd x y (eqeqd (addeqd (anwl h1) anr) (anwl h2)));
theorem leeq: $ a = b -> c = d -> (a <= c <-> b <= d) $ = '(exp (leeqd anl anr));
theorem leeq1: $ a = b -> (a <= c <-> b <= c) $ = '(mpi eqid leeq);
theorem leeq2: $ b = c -> (a <= b <-> a <= c) $ = '(leeq eqid);

theorem leid: $ a <= a $ = '(!! iexe x (eqeq1d addeq2) add0);
theorem eqle: $ a = b -> a <= b $ = '(mpbii leid leeq2);
theorem eqler: $ a = b -> b <= a $ = '(syl eqcom eqle);

theorem pncan3: $ a <= b -> a + (b - a) = b $ =
'(!! eex x (mpbii (addeq2 pncan2) (eqeqd (syl subeq1 addeq2) id)));
theorem npcan: $ b <= a -> a - b + b = a $ = '(syl5eq addcom pncan3);

theorem leaddid2: $ a <= a + b $ = '(!! iexe x (eqeq1d addeq2) eqid);
theorem leaddid1: $ a <= b + a $ = '(mpbi leaddid2 (leeq eqid addcom));

theorem lesucid: $ a <= suc a $ = '(mpbi leaddid2 (leeq2 add12));

theorem le01: $ 0 <= a $ = '(mpbi leaddid1 (leeq2 add0));

theorem leadd1: $ a <= b <-> a + c <= b + c $ =
'(bitr dfle (!! exbii x (bitr3 addcan1 (eqeq1 add32))));
theorem leadd2: $ b <= c <-> a + b <= a + c $ = '(bitr leadd1 (leeq addcom addcom));
theorem lesuc: $ a <= b <-> suc a <= suc b $ = '(bitr leadd1 (leeq add12 add12));

theorem letrd (h1: $ G -> a <= b $) (h2: $ G -> b <= c $): $ G -> a <= c $ =
'(mpd h1 @ !! eexda x @ mpd (anwl h2) @ !! eexda y @ syl
  (syl5eqr addass @ eqtrd (syl anlr addeq1) anr)
  (!! iexe z @ eqeq1d addeq2));

theorem letr: $ a <= b -> b <= c -> a <= c $ = '(exp (letrd anl anr));

theorem leasymd (h1: $ G -> a <= b $) (h2: $ G -> b <= a $): $ G -> a = b $ =
(focus
  '(mpd h1 (!! eexda x (! casesda _ $ x = 0 $ _ _ _)))
  (focus
    '(syl5eqr add0 (eqtr3d (anwr addeq2) anlr)))
  (focus
    '(imp (syl5bi exsuc (!! eexda y _)))
    '(mpd (anwl (anwl h2)) (!! eexda z _))
    '(sylc (a1i peano1) _ absurd)
    '(syl5eqr addS1 @ eqtrd (syl anlr addeq1) (sylib _ addcan2))
    '(eqtr4g (eqtrd (syl (anwl anlr) addeq1) anr) (eqcom addass) add0)));

theorem leasym: $ a <= b -> b <= a -> a = b $ = '(exp (leasymd anl anr));

theorem le02: $ a <= 0 <-> a = 0 $ = '(ibii (mpi le01 leasym) eqle);

theorem leaddd (h1: $ G -> a <= b $) (h2: $ G -> c <= d $): $ G -> a + c <= b + d $ =
'(letrd (sylib h1 leadd1) (sylib h2 leadd2));

theorem leadd: $ a <= b -> c <= d -> a + c <= b + d $ = '(exp (leaddd anl anr));

theorem lemul1a: $ a <= b -> a * c <= b * c $ =
'(! indd _ x y _ $ a * x <= b * x $ _ _ _ _
  (leeqd muleq2 muleq2) (leeqd muleq2 muleq2) (leeqd muleq2 muleq2) (leeqd muleq2 muleq2)
  (a1i (eqle (eqtr4 mul0 mul0))) (sylibr (leaddd anr anl) (leeq mulS mulS)));
theorem lemul2a: $ b <= c -> a * b <= a * c $ = '(sylib lemul1a (leeq mulcom mulcom));
theorem lemuld (h1: $ G -> a <= b $) (h2: $ G -> c <= d $): $ G -> a * c <= b * d $ =
'(letrd (syl h1 lemul1a) (syl h2 lemul2a));

def lt (a b: nat): wff = $ suc a <= b $;
infixl lt: $<$ prec 50;

theorem lteqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> (a < c <-> b < d) $ =
'(leeqd (suceqd h1) h2);
theorem lteq: $ a = b -> c = d -> (a < c <-> b < d) $ = '(exp (lteqd anl anr));
theorem lteq1: $ a = b -> (a < c <-> b < c) $ = '(mpi eqid lteq);
theorem lteq2: $ b = c -> (a < b <-> a < c) $ = '(lteq eqid);

theorem ltletr: $ a < b -> b <= c -> a < c $ = 'letr;
theorem ltletrd (h1: $ G -> a < b $) (h2: $ G -> b <= c $): $ G -> a < c $ = '(letrd h1 h2);

theorem ltle: $ a < b -> a <= b $ = '(letrd (a1i lesucid) id);
theorem ltled (h: $ G -> a < b $): $ G -> a <= b $ = '(syl h ltle);

theorem lelttr: $ a <= b -> b < c -> a < c $ = '(sylbi lesuc letr);
theorem lelttrd (h1: $ G -> a <= b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc h1 h2 lelttr);

theorem lttr: $ a < b -> b < c -> a < c $ = '(syl ltle lelttr);
theorem lttrd (h1: $ G -> a < b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc h1 h2 lttr);

theorem ltsucid: $ a < suc a $ = 'leid;

theorem lt01: $ 0 < a <-> a != 0 $ = '(bitr4 (!! exbii x (eqeq1 add11)) exsuc);
theorem lt02: $ ~ a < 0 $ = '(con3 (bi1 le02) peano1);
theorem lt01S: $ 0 < suc a $ = '(mpbir peano1 lt01);

theorem ltadd1: $ a < b <-> a + c < b + c $ = '(bitr leadd1 (leeq1 addS1));
theorem ltadd2: $ b < c <-> a + b < a + c $ = '(bitr ltadd1 (lteq addcom addcom));
theorem ltsuc: $ a < b <-> suc a < suc b $ = '(bitr ltadd1 (lteq add12 add12));
theorem leltsuc: $ a <= b <-> a < suc b $ = 'lesuc;

theorem ltirr: $ ~ a < a $ = '(mtbi lt02 (bitr ltadd1 (lteq add01 add01)));
theorem ltne: $ a < b -> a != b $ = '(mpi ltirr (con3d (com12 (bi1d lteq1))));
theorem ltner: $ a < b -> b != a $ = '(syl ltne necom);

theorem d0lt1: $ 0 < 1 $ = 'lt01S;
theorem d0lt2: $ 0 < 2 $ = 'lt01S;
theorem d1lt2: $ 1 < 2 $ = '(mpbi d0lt1 ltsuc);
theorem lt12: $ a < 1 <-> a = 0 $ = '(bitr3 leltsuc le02);

theorem nlesubeq0: $ ~b <= a -> a - b = 0 $ =
(focus
  '(syl (con3 (eximi (sylbir abeqb _))) (!! the0 x y))
  '(mpbiri eqid (eale (bibid (eqeq1d addeq2) eqeq1))));

theorem subleid: $ a - b <= a $ =
'(cases (mpbii leaddid2 (syl npcan leeq2)) (mpbiri le01 (syl nlesubeq0 leeq1)));

theorem leloe: $ a <= b <-> a < b \/ a = b $ =
'(ibii (!! eex x @ casesd
    (exp (orrd (syl5eqr add0 (eqtr3d (anwr addeq2) anl))))
    (syl5bi exsuc @ !! eexda y @ orld @ mpbii leaddid2 @
      syl (syl5eq (eqtr4 addS1 addS2) @ eqtrd (anwr addeq2) anl) leeq2))
  (eor ltle eqle));

theorem ltlene: $ a < b <-> a <= b /\ a != b $ =
'(ibii (iand ltle ltne) (imp (con1d (bi1 leloe))));
theorem ltlenle: $ a < b <-> a <= b /\ ~b <= a $ =
'(ibii (iand ltle (mtd (a1i ltirr) ltletr))
  (sylibr (iand anl (anwr (con3 eqler))) ltlene));

theorem ltorle: $ a < b \/ b <= a $ =
'(! ind x y _ $ a < x \/ x <= a $ _ _ _ _
  (orbid lteq2 leeq1) (orbid lteq2 leeq1) (orbid lteq2 leeq1) (orbid lteq2 leeq1)
  (orr le01)
  (eor (orld (mpi ltsucid lttr))
    (syl5 (con3 (bi1 lesuc)) @ exp @ bi2 ltlenle)));
theorem leorlt: $ a <= b \/ b < a $ = '(orcom ltorle);

theorem ltnle: $ a < b <-> ~b <= a $ = '(ibii (sylbi ltlenle anr) leorlt);
theorem lenlt: $ a <= b <-> ~b < a $ = '(con2b ltnle);
theorem ltnlt: $ a < b -> ~b < a $ = '(sylbi ltnle (con3 ltle));
theorem leorle: $ a <= b \/ b <= a $ = '(syl leorlt ltle);

theorem ltmul1: $ c != 0 -> (a < b <-> a * c < b * c) $ =
'(ibid
  (com12 @ ! indd _ x y _ $ x != 0 -> a * x < b * x $ _ _ _ _
    (imbid neeq1 (lteqd muleq2 muleq2)) (imbid neeq1 (lteqd muleq2 muleq2))
    (imbid neeq1 (lteqd muleq2 muleq2)) (imbid neeq1 (lteqd muleq2 muleq2))
    (syl eqidd absurdr)
    (a1d @ anwl @ sylibr
      (ltletrd (bi1 ltadd2) @ sylib (syl ltle lemul1a) leadd1)
      (lteq mulS mulS)))
  (a1i (mpbir (con3 lemul1a) (imbii ltnle ltnle))));
theorem ltmul2: $ a != 0 -> (b < c <-> a * b < a * c) $ =
'(syl6bb ltmul1 (lteq mulcom mulcom));
theorem lemul1: $ c != 0 -> (a <= b <-> a * c <= b * c) $ =
'(sylibr (notbid ltmul1) (bibi lenlt lenlt));
theorem lemul2: $ a != 0 -> (b <= c <-> a * b <= a * c) $ =
'(syl6bb lemul1 (leeq mulcom mulcom));

theorem mulcan1: $ c != 0 -> (a * c = b * c <-> a = b) $ =
'(ibid (exp (leasymd
    (mpbird (anwr eqle) (anwl lemul1))
    (mpbird (anwr eqler) (anwl lemul1))))
  (a1i muleq1));
theorem mulcan2: $ a != 0 -> (a * b = a * c <-> b = c) $ =
'(syl5bb (eqeq mulcom mulcom) mulcan1);

theorem sub01: $ 0 - a = 0 $ =
'(cases (sylbi le02 (syl6eq subeq2 sub02)) nlesubeq0);

theorem pnpcan2: $ (a + c) - (b + c) = a - b $ =
'(cases
  (syl (syl5eqr addass (syl npcan addeq1)) eqsub1)
  (eqtr4d (sylbi (notbi leadd1) nlesubeq0) nlesubeq0));

theorem pnpcan: $ (a + b) - (a + c) = b - c $ = '(eqtr (subeq addcom addcom) pnpcan2);
theorem subSS: $ suc a - suc b = a - b $ = '(eqtr3 (subeq add12 add12) pnpcan2);

abstract def if (p: wff) (a b: nat): nat = $ the {n | ifp p (n = a) (n = b)} $;

theorem ifeqd (h1: $ G -> (p <-> q) $) (h2: $ G -> a = c $) (h3: $ G -> b = d $):
  $ G -> if p a b = if q c d $ =
'(theeqd @ !! cbvabd x y @
  ifpbid (anwl h1) (eqeqd anr @ anwl h2) (eqeqd anr @ anwl h3));
theorem ifeq1d (h: $ G -> (p <-> q) $): $ G -> if p a b = if q a b $ = '(ifeqd h eqidd eqidd);
theorem ifeq2d (h: $ G -> a = b $): $ G -> if p a c = if p b c $ = '(ifeqd biidd h eqidd);
theorem ifeq3d (h: $ G -> b = c $): $ G -> if p a b = if p a c $ = '(ifeqd biidd eqidd h);

pub theorem iftrue (p: wff) (a b: nat): $ p -> if p a b = a $ = '(!! eqtheabd n ifptrue);
pub theorem iffalse (p: wff) (a b: nat): $ ~p -> if p a b = b $ = '(!! eqtheabd n ifpfalse);

theorem ifid: $ if p a a = a $ = '(cases iftrue iffalse);

def true (n: nat): wff = $ n != 0 $;
def bool (n: nat): wff = $ n < 2 $;
def nat (p: wff): nat = $ if p 1 0 $;

theorem trueeq: $ a = b -> (true a <-> true b) $ = 'neeq1;
theorem booleq: $ a = b -> (bool a <-> bool b) $ = 'lteq1;
theorem nateq: $ (p <-> q) -> nat p = nat q $ = '(ifeqd id eqidd eqidd);

theorem true1: $ true 1 $ = 'd1ne0;
theorem true0: $ ~ true 0 $ = '(notnot1 eqid);

theorem bool0: $ bool 0 $ = 'd0lt2;
theorem bool1: $ bool 1 $ = 'd1lt2;
theorem bool01: $ bool n <-> n = 0 \/ n = 1 $ =
'(bitr3 leltsuc (bitr leloe (orbi1i lt12)));

theorem dftrue2: $ bool n -> (true n <-> n = 1) $ =
'(ibid (bi1 bool01) (a1i @ mpbiri d1ne0 neeq1));

theorem truenat: $ true (nat p) <-> p $ =
'(ibii (con1 iffalse) (mpbiri d1ne0 (syl iftrue neeq1)));
theorem nattrue: $ bool n -> nat (true n) = n $ =
'(sylbi bool01 @ eor
  (eqtr4d (syl trueeq nateq) @ syl6eqr id @ iffalse true0)
  (eqtr4d (syl trueeq nateq) @ syl6eqr id @ iftrue true1));

def min (a b: nat): nat = $ if (a < b) a b $;
def max (a b: nat): nat = $ if (a < b) b a $;

theorem mineqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> min a c = min b d $ = '(ifeqd (lteqd h1 h2) h1 h2);
theorem maxeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> max a c = max b d $ = '(ifeqd (lteqd h1 h2) h2 h1);

theorem mineq1: $ a <= b -> min a b = a $ =
'(sylbi leloe @ eor iftrue @ syl6eq (ifeq3d eqcom) ifid);
theorem maxeq2: $ a <= b -> max a b = b $ =
'(sylbi leloe @ eor iftrue @ syl6eq (ifeq3d id) ifid);

theorem mincom: $ min a b = min b a $ =
'(cases (eqtr4d iftrue @ syl ltnlt iffalse) (eqtr4d iffalse @ sylbir lenlt mineq1));
theorem maxcom: $ max a b = max b a $ =
'(cases (eqtr4d iftrue @ syl ltnlt iffalse) (eqtr4d iffalse @ sylbir lenlt maxeq2));

theorem mineq2: $ b <= a -> min a b = b $ = '(syl5eq mincom mineq1);
theorem maxeq1: $ b <= a -> max a b = a $ = '(syl5eq maxcom maxeq2);

theorem minle1: $ min a b <= a $ =
'(cases (syl iftrue eqle) (mpbird (bi2 lenlt) (syl iffalse leeq1)));
theorem minle2: $ min a b <= b $ = '(mpbi minle1 (leeq1 mincom));
theorem lemin: $ a <= min b c <-> a <= b /\ a <= c $ =
'(ibii (iand (mpi minle1 letr) (mpi minle2 letr)) @ casesda
  (mpbird anll @ anwr @ syl iftrue leeq2)
  (mpbird anlr @ anwr @ syl iffalse leeq2));

theorem lemax1: $ a <= max a b $ =
'(cases (mpbird ltle (syl iftrue leeq2)) (syl iffalse eqler));
theorem lemax2: $ b <= max a b $ = '(mpbi lemax1 (leeq2 maxcom));
theorem maxle: $ max a b <= c <-> a <= c /\ b <= c $ =
'(ibii (iand (letr lemax1) (letr lemax2)) @ casesda
  (mpbird anlr @ anwr @ syl iftrue leeq1)
  (mpbird anll @ anwr @ syl iffalse leeq1));

abstract def div (a b: nat): nat = $ the {q | E. r (r < b /\ b * q + r = a)} $;
infixl div: $//$ prec 70;
abstract def mod (a b: nat): nat = $ a - b * (a // b) $;
infixl mod: $%$ prec 70;

theorem diveqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a // c = b // d $ =
'(theeqd @ !! cbvabd q1 q2 @ !! cbvexd r1 r2 @
  anbid (leeqd (suceqd anr) (anwll h2)) @
  eqeqd (addeqd (muleqd (anwll h2) anlr) anr) @ anwll h1);
theorem modeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a % c = b % d $ =
'(subeqd h1 @ muleqd h2 @ diveqd h1 h2);
theorem diveq1: $ a = b -> a // c = b // c $ = '(diveqd id eqidd);
theorem diveq2: $ b = c -> a // b = a // c $ = '(diveqd eqidd id);
theorem modeq1: $ a = b -> a % c = b % c $ = '(modeqd id eqidd);
theorem modeq2: $ b = c -> a % b = a % c $ = '(modeqd eqidd id);

pub theorem div0 (a: nat): $ a // 0 = 0 $ =
'(trud @ !! eqthe0abd q @ a1i @ !! eex r @ anwl @ absurd lt02);
theorem mod0: $ a % 0 = a $ = '(eqtr (subeq2 mul01) sub02);

theorem divlem1
  (h1: $ G -> r1 < b $) (h2: $ G -> r2 < b $)
  (h3: $ G -> b * q1 + r1 <= b * q2 + r2 $):
  $ G -> q1 <= q2 $ =
(focus
  (have 'b0 $ G -> b != 0 $ '(syl (lelttrd (a1i le01) h1) ltner))
  '(sylibr (mpbird (lelttrd (a1i leaddid2) _) (syl b0 ltmul2)) leltsuc)
  '(lelttrd h3 (sylib h2 @ bitr4 ltadd2 (lteq2 mulS))));

theorem divlem2 (h1: $ G -> R < b $) (h2: $ G -> b * Q + R = a $):
  $ G -> (E. r (r < b /\ b * q + r = a) <-> q = Q) $ =
(focus
  (have 'b0 $ G -> b != 0 $ '(syl (lelttrd (a1i le01) h1) ltner))
  '(ibid (eexda @ leasymd
      (divlem1 anrl (anwl h1) @ rsyl eqle @ eqtr4d anrr (anwl h2))
      (divlem1 (anwl h1) anrl @ rsyl eqle @ eqtr4d (anwl h2) anrr))
    (exp @ syl
      (iand (anwl h1) @ eqtrd (anwr @ syl muleq2 addeq1) (anwl h2))
      (iexe @ anbid lteq1 @ eqeq1d addeq2))));

theorem divlem3 (a b: nat): $ b != 0 -> E. q E. r (r < b /\ b * q + r = a) $ =
(focus
  '(! indd _ x y _ $ E. q E. r (r < b /\ b * q + r = x) $ _ _ _ _
    (exbid @ exbid @ anbi2d eqeq2) (exbid @ exbid @ anbi2d eqeq2)
    (exbid @ exbid @ anbi2d eqeq2) (exbid @ exbid @ anbi2d eqeq2)
    _ _)
  (focus
    '(iexde @ iexde @ iand
      (mpbird (sylibr anll lt01) (anwr lteq1))
      (syl6eq (addeqd (syl6eq (anwl (anwr muleq2)) mul02) anr) add0)))
  (focus
    '(imp @ syl5bi (!! cbvex _ u @ !! cbvexd _ v
      (anbid (anwr lteq1) @ eqeq1d @ addeqd (anwl muleq2) anr))
      (eexd @ eexda @ mpd (sylib anrl leloe) (eord _ _)))
    (focus
      '(exp @ iexde @ iexde @ iand
        (mpbird (anwll anr) (anwr lteq1))
        (eqtrd (anwr addeq2) @ syl5eq addS @ suceqd @
          eqtrd (syl (syl anlr muleq2) addeq1) (anw3l anrr))))
    (focus
      '(exp @ iexde @ iexde @ iand
        (mpbird (sylibr (anw3l anl) lt01) (anwr lteq1))
        (eqtrd (addeqd (syl anlr muleq2) anr) @
          syl5eq add0 @ syl5eq mulS @ eqtr3d (syl (anwll anr) addeq2) @
            syl5eq addS @ suceqd @ anw3l anrr)))));

theorem eqdivmod (h1: $ G -> R < b $) (h2: $ G -> b * Q + R = a $):
  $ G -> a // b = Q /\ a % b = R $ =
(focus
  (have 'eq $ G -> a // b = Q $
    '(!! eqtheabd q @ !! divlem2 r h1 h2))
  '(iand eq (syl (eqtrd (syl (syl eq muleq2) addeq1) h2) eqsub2)));

pub theorem divmod (a b: nat): $ b * (a // b) + a % b = a $ =
(focus
  '(pncan3 @ cases _ _)
  (focus
    '(mpbiri le01 @ syl (syl6eq (syl (syl6eq diveq2 div0) muleq2) mul0) leeq1))
  (focus
    '(mpd (!! divlem3 q r) @ eexd @ eexda @ mpbii leaddid2 _)
    '(syl (eqtrd (syl (syl _ muleq2) addeq1) anrr) leeq2)
    '(!! eqtheabd q @ !! divlem2 r anrl anrr)));

pub theorem modlt (a b: nat): $ b != 0 -> a % b < b $ =
'(mpd (!! divlem3 q r) @ eexd @ eexda @
  mpbird anrl @ syl (anrd @ eqdivmod anrl anrr) lteq1);

theorem modle1: $ a % b <= a $ = '(mpbi leaddid1 (leeq2 divmod));

theorem div01: $ 0 // a = 0 $ =
'(cases (syl6eq diveq2 div0) @ anld @
  eqdivmod (bi2 lt01) (a1i @ eqtr add0 mul0));
theorem mod01: $ 0 % a = 0 $ =
'(cases (syl6eq modeq2 mod0) @ anrd @
  eqdivmod (bi2 lt01) (a1i @ eqtr add0 mul0));

theorem muldiv2: $ b != 0 -> b * a // b = a $ =
'(anld @ eqdivmod (bi2 lt01) (a1i add0));
theorem muldiv1: $ b != 0 -> a * b // b = a $ =
'(eqtrd (diveqd (a1i mulcom) eqidd) muldiv2);
theorem mulmod1: $ b * a % b = 0 $ =
'(cases
  (eqtrd modeq2 @ syl5eq mod0 @ syl6eq muleq1 mul01)
  (anrd @ eqdivmod (bi2 lt01) (a1i add0)));
theorem mulmod2: $ a * b % b = 0 $ =
'(eqtr (modeqd id eqidd mulcom) mulmod1);

theorem lediv1: $ a <= b -> a // c <= b // c $ =
'(casesda (mpbiri le01 @ rsyl leeq1 @ syl6eq (anwr diveq2) div0)
  (divlem1 (anwr modlt) (anwr modlt) @ sylibr anl @ leeq divmod divmod));

def dvd (a b .c: nat): wff = $ E. c c * a = b $;
infixl dvd: $||$ prec 50;

theorem dvdeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a || c <-> b || d) $ =
'(!! cbvexd x y @ eqeqd (muleqd anr @ anwl h1) (anwl h2));
theorem dvdeq1: $ a = b -> (a || c <-> b || c) $ = '(dvdeqd id eqidd);
theorem dvdeq2: $ b = c -> (a || b <-> a || c) $ = '(dvdeqd eqidd id);

theorem idvd: $ c * a = b -> a || b $ = '(!! iexe x @ eqeq1d muleq1);
theorem idvd2: $ a * c = b -> a || b $ = '(sylbi (eqeq1 mulcom) idvd);

theorem divmul: $ b || a -> a // b * b = a $ =
(focus
  '(!! eex x @ eqtr3d (syl diveq1 muleq1) @ syl5eq _ id)
  '(cases (eqtr4d (syl6eq muleq2 mul0) (syl6eq muleq2 mul0)) (syl muldiv1 muleq1)));
theorem muldiv3: $ b || a -> b * (a // b) = a $ = '(syl5eq mulcom divmul);

theorem dvdadd1: $ n || a -> (n || b <-> n || a + b) $ =
(focus
  '(!! eex x @ ibid _ _)
  (focus
    '(!! eexda y @ rsyl idvd @ syl5eq addmul @ imp addeq))
  (focus
    '(!! eexda z @ rsyl idvd @ sylib _ addcan2)
    '(eqtr3d (anwl addeq1) @ syl5eqr addmul @ eqtrd _ anr)
    '(casesda (anwr @ eqtr4d (syl6eq muleq2 mul0) (syl6eq muleq2 mul0)) _)
    '(syl _ @ syl pncan3 muleq1)
    '(mpbiri leaddid2 @ bitrd (anwr lemul1) @ leeqd anll anlr)));

theorem dvdadd2: $ n || a -> (n || b <-> n || b + a) $ =
'(syl6bb dvdadd1 @ dvdeqd eqidd id addcom);

theorem dvdmul1: $ a || b * a $ = '(idvd eqid);
theorem dvdmul2: $ a || a * b $ = '(mpbi dvdmul1 (dvdeq2 mulcom));

theorem dvdtr: $ a || b -> b || c -> a || c $ =
'(!! eex x @ !! eexda y @ rsyl idvd @ eqtrd (anwl @ syl5eq mulass muleq2) anr);

theorem dvdmul12: $ a || b -> a || c * b $ = '(mpi dvdmul1 dvdtr);
theorem dvdmul11: $ a || b -> a || b * c $ = '(mpi dvdmul2 dvdtr);

theorem modeq0: $ a % n = 0 <-> n || a $ =
'(ibii
  (!! iexde x @ eqtrd (anwr muleq1) @ syl5eq mulcom @
    syl5eqr add0 @ eqtr3d (anwl addeq2) @ a1i divmod)
  (eex @ syl6eq (modeqd eqcom eqidd) mulmod2));

theorem dvd02: $ a || 0 $ = '(idvd mul01);
theorem dvd01: $ 0 || a <-> a = 0 $ =
'(ibii (!! eex x @ eqcomd @ bi1 @ eqeq1 mul02) (mpbiri dvd02 dvdeq2));

theorem dvdid: $ a || a $ = '(idvd mul11);

theorem dvdled (h1: $ G -> b != 0 $) (h2: $ G -> a || b $): $ G -> a <= b $ =
'(mpd h2 @ !! eexda x @ mpbid
  (syl (sylibr (mtd (anwl h1) @ exp @
    eqtr3d anlr @ syl6eq (anwr muleq1) mul01) lt01) lemul1a)
  (leeqd (a1i mul11) anr));

theorem d2dvd1: $ ~2 || 1 $ =
'(mt (mpbi d1lt2 ltnle) @ dvdled (a1i d1ne0) id);

theorem d2dvdS: $ 2 || suc n <-> ~2 || n $ =
'(ibii
  (mtd (a1i d2dvd1) @ exp @ mpbird anl @ syl6bb (anwr dvdadd1) @ dvdeq2 add12)
  (! ind x y _ $ 2 || x \/ 2 || suc x $ _ _ _ _
  (orbid dvdeq2 @ syl suceq dvdeq2)
  (orbid dvdeq2 @ syl suceq dvdeq2)
  (orbid dvdeq2 @ syl suceq dvdeq2)
  (orbid dvdeq2 @ syl suceq dvdeq2)
  (orl dvd02)
  (eor (orrd @ mpbii dvdid @ syl6bb dvdadd1 @ dvdeq2 @ eqtr addS @ suceq add12) orl)));

theorem modlteq: $ a < n -> a % n = a $ =
'(anrd @ eqdivmod id @ a1i @ eqtr (addeq1 mul0) add01);

theorem modmod: $ a % n % n = a % n $ =
'(cases (modeqd (syl6eq modeq2 mod0) eqidd) (syl modlt modlteq));

theorem dvdsubmod: $ n || a - a % n $ = '(idvd2 @ eqcom @ eqsub1 @ divmod);

theorem boolmod2: $ bool (n % 2) $ = '(modlt d2ne0);

local def eqm (n a b) = $ a % n = b % n $;
notation eqm (n a b) = ($mod($:50) n ($):$:50) a ($=$:50) b;

theorem eqmid: $ mod(n): a = a $ = 'eqid;
theorem eqmtr: $ mod(n): a = b -> mod(n): b = c -> mod(n): a = c $ = 'eqtr;
theorem eqmcom: $ mod(n): a = b -> mod(n): b = a $ = 'eqcom;

theorem eqmeqd (h1: $ G -> m = n $) (h2: $ G -> a = b $) (h3: $ G -> c = d $):
  $ G -> (mod(m): a = c <-> mod(n): b = d) $ = '(eqeqd (modeqd h2 h1) (modeqd h3 h1));
theorem eqmeq23d (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (mod(n): a = c <-> mod(n): b = d) $ = '(eqmeqd eqidd h1 h2);
theorem eqmeq1: $ m = n -> (mod(m): a = b <-> mod(n): a = b) $ = '(eqmeqd id eqidd eqidd);
theorem eqmeq2: $ a = b -> (mod(n): a = c <-> mod(n): b = c) $ = '(eqmeq23d id eqidd);
theorem eqmeq3: $ b = c -> (mod(n): a = b <-> mod(n): a = c) $ = '(eqmeq23d eqidd id);

theorem eqmmod: $ mod(n): a % n = a $ = 'modmod;

theorem eqm03: $ mod(n): a = 0 <-> n || a $ = '(bitr (eqeq2 mod01) modeq0);

theorem eqmdvdsub: $ a <= b -> (mod(n): a = b <-> n || b - a) $ =
(focus
  (have 'h $ a <= b -> b - a % n = b - a + (a - a % n) $
    '(rsyl eqsub1 @ syl5eq addass @ syl5eq (addeq2 @ npcan modle1) npcan))
  '(ibida
    (sylibr
      (mpbiri dvdsubmod @ dvdeqd eqidd @ eqtr3d (anwl h) (anwr subeq2))
      (dvdadd2 dvdsubmod))
    (casesda _ _))
  (focus
    '(rsyl modeq1 @ eqtr3d
      (syl6eq (rsyl addeq1 @ sylib (mpbid anlr @ anwr dvdeq1) dvd01) add01)
        (anwll npcan)))
  (focus
    '(eqcomd @ anrd @ eqdivmod (anwr modlt) @ eqtrd
      (rsyl addeq1 @ syl5eq muladd @ eqtr4d _ @ anwll h)
      (rsyl npcan @ letrd (a1i modle1) anll))
    '(addeqd (syl anlr muldiv3) @ a1i @ eqcom @ eqsub1 divmod)));

theorem eqmaddlem (h1: $ G -> a <= b $) (h2: $ G -> mod(n): a = b $):
  $ G -> mod(n): a + c = b + c $ =
'(mpbird (sylibr (mpbid h2 @ syl h1 eqmdvdsub) @ dvdeq2 pnpcan2)
  (syl h1 @ sylbi leadd1 eqmdvdsub));

theorem eqmadd1d (h: $ G -> mod(n): a = b $): $ G -> mod(n): a + c = b + c $ =
'(eor (exp @ eqmaddlem anl @ anwr h)
  (exp @ rsyl eqmcom @ eqmaddlem anl @ anwr @ syl h eqmcom) leorle);
theorem eqmadd2d (h: $ G -> mod(n): b = c $): $ G -> mod(n): a + b = a + c $ =
'(mpbid (eqmadd1d h) @ eqmeq23d (a1i addcom) (a1i addcom));

theorem eqmaddd (h1: $ G -> mod(n): a = b $) (h2: $ G -> mod(n): c = d $):
  $ G -> mod(n): a + c = b + d $ =
'(sylc (eqmadd1d h1) (eqmadd2d h2) eqmtr);

def b0 (n: nat): nat = $ n + n $;
def b1 (n: nat): nat = $ suc (b0 n) $;
def odd (n: nat): wff = $ n % 2 = 1 $;

theorem b0eq: $ a = b -> b0 a = b0 b $ = '(addeqd id id);
theorem b1eq: $ a = b -> b1 a = b1 b $ = '(suceqd b0eq);
theorem oddeq: $ a = b -> (odd a <-> odd b) $ = '(eqeq1d modeq1);

theorem b0mul21: $ 2 * n = b0 n $ = 'mul21;
theorem b0mul22: $ n * 2 = b0 n $ = 'mul22;

theorem b1mul21: $ 2 * n + 1 = b1 n $ = '(eqtr (addeq1 b0mul21) add12);

theorem b0dvd2: $ 2 || b0 n $ = '(idvd b0mul22);
theorem b1dvd2: $ ~2 || b1 n $ = '(mpbi b0dvd2 @ con2b d2dvdS);

theorem odddvd: $ odd n <-> ~ 2 || n $ =
'(bitr3 (dftrue2 boolmod2) @ notbi modeq0);

theorem b0odd: $ ~odd (b0 n) $ = '(mpbi b0dvd2 @ con2b odddvd);
theorem b1odd: $ odd (b1 n) $ = '(mpbir b1dvd2 odddvd);

theorem b0div2: $ b0 n // 2 = n $ = '(eqtr3 (diveq1 b0mul21) (muldiv2 d2ne0));
theorem b1div2: $ b1 n // 2 = n $ =
'(trud @ anld @ eqdivmod (a1i d1lt2) (a1i b1mul21));
theorem b0can: $ b0 a = b0 b <-> a = b $ =
'(ibii (sylib diveq1 @ eqeq b0div2 b0div2) b0eq);
theorem b1can: $ b1 a = b1 b <-> a = b $ =
'(ibii (sylib diveq1 @ eqeq b1div2 b1div2) b1eq);

theorem b0orb1: $ n = b0 (n // 2) \/ n = b1 (n // 2) $ =
'(syl (con3 (eqcomd @ syl5eqr b0mul21 muldiv3)) @
  sylbir odddvd @ syl5eqr divmod @ syl6eq addeq2 b1mul21);

theorem odd0: $ ~ odd 0 $ = '(mtbir (mt d1ne0 eqcom) (eqeq1 mod01));
theorem oddS: $ odd (suc n) <-> ~odd n $ =
'(bitr odddvd @ notbi @ bitr4 d2dvdS odddvd);

def pr (a b: nat): nat = $ (a + b) * suc (a + b) // 2 + b $;
infixr pr: $<>$ prec 54;

theorem preqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a <> c = b <> d $ =
'(addeqd (rsyl diveq1 @ muleqd (addeqd h1 h2) (suceqd @ addeqd h1 h2)) h2);
theorem preq1: $ a = b -> a <> c = b <> c $ = '(preqd id eqidd);
theorem preq2: $ b = c -> a <> b = a <> c $ = '(preqd eqidd id);
theorem nfpr (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x a <> b $ =
'(!! nfnlem2 _ y z (preqd anl anr) h1 h2);

theorem prlem1: $ 2 || n * suc n $ = '(cases dvdmul11 @ sylbir d2dvdS dvdmul12);

theorem prlem2: $ a <> c <= b <> d -> a + c <= b + d $ =
(focus
  '(sylibr (mtd (sylib _ ltnle) @ exp @ sylibr _ @ lemul2 d2ne0) lenlt)
  (focus
    '(lelttrd (letr leaddid2) @ a1i @ mpbi (mpbi leaddid1 leltsuc) ltadd2))
  (focus
    '(mpbird
      (lemuld (sylibr (sylib (sylibr anr @ leeq1 add12) lesuc) (leeq1 addS)) anr)
      (leeqd
        (syl6eqr (syl5eq muladd @ rsyl addeq1 @ a1i @ muldiv3 prlem1) addmul)
        (a1i @ eqtr (muldiv3 prlem1) mulcom)))));

theorem prth: $ a <> c = b <> d <-> a = b /\ c = d $ =
(focus
  '(ibii _ (preqd anl anr))
  (have 'h $ (a <> c = b <> d) -> a + c = b + d $
    '(leasymd (syl eqle prlem2) (syl eqler prlem2)))
  (have 'h2 $ (a <> c = b <> d) -> c = d $
    '(sylib (mpbid id @ syl h @ eqeq1d @
      rsyl addeq1 @ rsyl diveq1 @ muleqd id suceq) addcan2))
  '(iand (sylib (eqtr4d h @ sylibr h2 addcan2) addcan1) h2));

abstract def fst (a: nat): nat = $ the {x | E. y a = x <> y} $;
abstract def snd (a: nat): nat = $ the {y | E. x a = x <> y} $;

pub theorem pr0: $ 0 <> 0 = 0 $ =
'(eqtr (addeq1 @ eqtr (diveq1 @ eqtr (muleq1 add0) mul01) div01) add0);

theorem expr: $ E. x E. y a = x <> y $ =
(focus
  '(! ind u v _ $ E. x E. y u = x <> y $ _ _ _ _
    (exbid @ exbid eqeq1) (exbid @ exbid eqeq1)
    (exbid @ exbid eqeq1) (exbid @ exbid eqeq1)
    (trud @ iexde @ iexde @ syl5eqr pr0 @ eqcomd @ preqd anlr anr)
    (sylib _ (cbvex @ cbvexd @ eqeq2d @ preqd anl anr)))
  '(eex @ eex @ casesd _ _)
  (focus
    '(exp @ !! iexde m @ !! iexde n _)
    (have 'h3 $ _ /\ m = suc y /\ n = 0 -> m + n = suc y $
      '(syl6eq (addeqd anlr anr) add0))
    (have 'h4 $ _ /\ x = 0 /\ m = suc y /\ n = 0 -> x + y = y $
      '(syl6eq (syl (anwll anr) addeq1) add01))
    '(eqtrd (suceqd an3l) @ syl5eqr addS @ eqtr4d (sylib _ @ mulcan2 d2ne0)
      (syl6eq (addeqd (rsyl diveq1 (muleqd h3 @ suceqd h3)) anr) add0))
    '(syl5eq muladd @ syl6eqr _ @ eqtr (muldiv3 prlem1) mulcom)
    '(eqtrd
      (rsyl addeq1 @ syl5eq (muldiv3 prlem1) @ muleqd h4 @ suceqd h4)
      (syl5eqr addmul @ a1i @ muleq1 @ eqtr addS @ suceq add12)))
  (focus
    (have 'h $ _ /\ suc z = x /\ m = z /\ n = suc y -> x + y = m + n $
      '(eqtr4d
        (syl6eq (eqcomd @ anwll @ anwr addeq1) (eqtr4 addS1 addS2))
        (addeqd anlr anr)))
    '(syl5bi exsuc @ !! eexda z @ !! iexde m @ !! iexde n @
      eqtrd (anw3l suceq) @ syl5eqr addS @ addeqd
      (rsyl diveq1 @ muleqd h @ suceqd h) (eqcomd anr))));

theorem fsteq: $ a = b -> fst a = fst b $ =
'(theeqd @ !! cbvabd x1 x2 @ !! cbvexd y1 y2 @ eqeqd anll @ preqd anlr anr);
theorem sndeq: $ a = b -> snd a = snd b $ =
'(theeqd @ !! cbvabd y1 y2 @ !! cbvexd x1 x2 @ eqeqd anll @ preqd anr anlr);

pub theorem fstpr (a b: nat): $ fst (a <> b) = a $ =
'(trud @ !! eqtheabd x @ a1i @ ibii
  (!! eex y @ sylbi prth @ eqcomd anl)
  (syl (eqcomd preq1) @ iexe @ eqeq2d preq2));
pub theorem sndpr (a b: nat): $ snd (a <> b) = b $ =
'(trud @ !! eqtheabd y @ a1i @ ibii
  (!! eex x @ sylbi prth @ eqcomd anr)
  (syl (eqcomd preq2) @ iexe @ eqeq2d preq1));
pub theorem fstsnd (a: nat): $ fst a <> snd a = a $ =
'(!! eex x (!! eex y @ eqtr4d (preqd (syl6eq fsteq fstpr) (syl6eq sndeq sndpr)) id) expr);

theorem fst0: $ fst 0 = 0 $ = '(eqtr3 (fsteq pr0) fstpr);
theorem snd0: $ snd 0 = 0 $ = '(eqtr3 (sndeq pr0) sndpr);

def pi11 (n: nat): nat = $ fst (fst n) $;
def pi12 (n: nat): nat = $ snd (fst n) $;
def pi21 (n: nat): nat = $ fst (snd n) $;
def pi22 (n: nat): nat = $ snd (snd n) $;
def pi221 (n: nat): nat = $ fst (pi22 n) $;
def pi222 (n: nat): nat = $ snd (pi22 n) $;

theorem pi11eq: $ a = b -> pi11 a = pi11 b $ = '(syl fsteq fsteq);
theorem pi12eq: $ a = b -> pi12 a = pi12 b $ = '(syl fsteq sndeq);
theorem pi21eq: $ a = b -> pi21 a = pi21 b $ = '(syl sndeq fsteq);
theorem pi22eq: $ a = b -> pi22 a = pi22 b $ = '(syl sndeq sndeq);
theorem pi221eq: $ a = b -> pi221 a = pi221 b $ = '(syl pi22eq fsteq);
theorem pi222eq: $ a = b -> pi222 a = pi222 b $ = '(syl pi22eq sndeq);

theorem pi11pr: $ pi11 ((a <> b) <> c) = a $ = '(eqtr (fsteq fstpr) fstpr);
theorem pi12pr: $ pi12 ((a <> b) <> c) = b $ = '(eqtr (sndeq fstpr) sndpr);
theorem pi21pr: $ pi21 (a <> b <> c) = b $ = '(eqtr (fsteq sndpr) fstpr);
theorem pi22pr: $ pi22 (a <> b <> c) = c $ = '(eqtr (sndeq sndpr) sndpr);
theorem pi221pr: $ pi221 (a <> b <> c <> d) = c $ = '(eqtr (fsteq pi22pr) fstpr);
theorem pi222pr: $ pi222 (a <> b <> c <> d) = d $ = '(eqtr (sndeq pi22pr) sndpr);

def isfun (A: set): wff =
$ A. a A. b A. b2 (a <> b e. A -> a <> b2 e. A -> b = b2) $;

theorem isfund (h1: $ G -> isfun F $)
  (h2: $ G -> a <> b e. F $) (h3: $ G -> a <> b2 e. F $):
  $ G -> b = b2 $ =
'(mpd h3 @ mpd h2 @ mpd h1 @ !! ealde x @ !! ealde y @ !! ealde z @ bi1d @
  imbid (eleq1d @ preqd anllr anlr) @
  imbid (eleq1d @ preqd anllr anr) @ eqeqd anlr anr);

theorem isfunbd (h1: $ G -> isfun F $) (h2: $ G -> a <> b e. F $):
  $ G -> (a <> b2 e. F <-> b = b2) $ =
'(ibida (isfund (anwl h1) (anwl h2) anr) @ mpbid (anwl h2) @ eleq1d @ anwr preq2);

theorem isfuneq: $ A == B -> (isfun A <-> isfun B) $ =
'(!! cbvald a1 a2 @ !! cbvald b1 b2 @ !! cbvald c1 c2 @
  imbid (eleqd (preqd anllr anlr) an3l) @
  imbid (eleqd (preqd anllr anr) an3l) @ eqeqd anlr anr);

def opab {x y: nat} (ph: wff x y): set =
$ {z | E. x E. y (z = x <> y /\ ph)} $;

def Xp (A B: set): set = $ opab x y (x e. A /\ y e. B) $;

def Dom (A: set): set = $ {x | E. y x <> y e. A} $;
def Ran (A: set): set = $ {y | E. x x <> y e. A} $;

def Im (F A: set): set = $ {y | E. x (x e. A /\ x <> y e. F)} $;
infixl Im: $''$ prec 80;

def cnv (A: set): set = $ opab x y (y <> x e. A) $;

def comp (F G: set): set =
$ opab x z (E. y (x <> y e. G /\ y <> z e. F)) $;
infixr comp: $o.$ prec 90;

def lam {x: nat} (a: nat x): set = $ {p | E. x p = x <> a} $;
notation lam {x: nat} (a: nat x): set = ($\$:30) x ($,$:0) a;

theorem lameq (a b: nat x): $ A. x a = b -> (\ x, a) == (\ x, b) $ =
'(!! cbvabd p1 p2 @ rsyl exbi @ ialdh (nfan nfal1 nfv) @
  eqeqd anr @ anwl @ syl eal preq2);
theorem lameqd (G: wff) (a b: nat x)
  (h: $ G -> a = b $): $ G -> (\ x, a) == (\ x, b) $ = '(syl (iald h) lameq);

theorem nflam1 (a: nat x): $ FS/ x \ x, a $ = '(!! nfab _ p nfex1);
theorem nflam (a: nat x y) (h: $ FN/ x a $): $ FS/ x \ y, a $ =
'(!! nfab _ p @ nfex @ nfeq nfnv @ nfpr nfnv h);
theorem cbvlamh (a b: nat x y) (h1: $ FN/ y a $) (h2: $ FN/ x b $)
  (e: $ x = y -> a = b $): $ (\ x, a) == (\ y, b) $ =
'(!! cbvab p1 p2 @ cbvexd @ eqeqd anl @ anwr @ preqd id e);
theorem cbvlam (a: nat x) (b: nat y)
  (e: $ x = y -> a = b $): $ (\ x, a) == (\ y, b) $ = '(cbvlamh nfnv nfnv e);
theorem cbvlams (a: nat x): $ (\ x, a) == (\ y, N[y / x] a) $ = '(cbvlamh nfnv nfsbn1 sbneq);
theorem cbvlamd (G: wff) (a: nat x) (b: nat y)
  (h: $ G /\ x = y -> a = b $): $ G -> (\ x, a) == (\ y, b) $ =
'(eqstrd (a1i cbvlams) @ lameqd @ syl (iald (exp h)) sbnet);

theorem lamisf (a: nat x): $ isfun (\ x, a) $ =
'(!! ax_gen u @ !! ax_gen v @ !! ax_gen w @
  sylbi (!! elabe p @ exbid eqeq1) @ eexh (nfim (nfel2 nflam1) nfv) @ sylbi prth @
  syl5bi (bitr (!! elabe p @ exbid eqeq1) @
    cbvexh nfv (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbneq) @
  !! eexd y @ syl5bi prth @ exp @ eqtr4d anlr @ eqtr4d anrr @ rsyl sbneq @
  eqtr3d anll anrl);

def app (F: set) (x: nat): nat = $ the {y | x <> y e. F} $;
infixl app: $@$ prec 200;

theorem appeqd (h1: $ G -> A == B $) (h2: $ G -> a = b $): $ G -> A @ a = B @ b $ =
'(theeqd @ !! cbvabd y1 y2 @ eleqd (preqd (anwl h2) anr) (anwl h1));
theorem appeq2d (h: $ G -> a = b $): $ G -> F @ a = F @ b $ = '(appeqd eqsidd h);
theorem appeq1: $ A == B -> A @ a = B @ a $ = '(appeqd id eqidd);
theorem appeq2: $ a = b -> F @ a = F @ b $ = '(appeq2d id);

theorem isfappd (h1: $ G -> isfun F $) (h2: $ G -> a <> b e. F $):
  $ G -> F @ a = b $ =
'(!! eqtheabd x @ syl6bb (isfunbd h1 h2) eqcomb);

theorem lamapps (a b: nat x): $ (\ x, a) @ b = N[b / x] a $ =
'(trud @ isfappd (a1i lamisf) @ a1i @ mpbir
  (ax_mp eqid @ iexe @ eqeq2d @ preqd id sbneq1)
  (!! elabe p @ syl5bb
    (cbvexh nfv (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbneq)
    (!! exbid z eqeq1)));
theorem lamapp (a: nat x): $ (\ x, a) @ x = a $ = '(eqtr lamapps sbnid);
theorem lamappe (a: nat x) (e: $ x = b -> a = c $):
  $ (\ x, a) @ b = c $ = '(eqtr lamapps @ sbne e);

def case (A B: set): set =
  $ \ n, if (odd n) (B @ (n // 2)) (A @ (n // 2)) $;
pub theorem casel (A B: set) (n: nat): $ case A B @ (b0 n) = A @ n $ =
'(!! lamappe i @ eqtrd
  (rsyl iffalse @ mtbird (a1i b0odd) oddeq)
  (appeq2d @ syl6eq diveq1 b0div2));
pub theorem caser (A B: set) (n: nat): $ case A B @ (b1 n) = B @ n $ =
'(!! lamappe i @ eqtrd
  (rsyl iftrue @ mpbird (a1i b1odd) oddeq)
  (appeq2d @ syl6eq diveq1 b1div2));

abstract def Sum (A B: set): set =
$ {n | ifp (odd n) (n // 2 e. B) (n // 2 e. A)} $;
pub theorem Suml (A B: set) (n: nat): $ b0 n e. Sum A B <-> n e. A $ =
'(!! elabe i @ bitrd
  (rsyl ifpfalse @ mtbird (a1i b0odd) oddeq)
  (eleq1d @ syl6eq diveq1 b0div2));
pub theorem Sumr (A B: set) (n: nat): $ b1 n e. Sum A B <-> n e. B $ =
'(!! elabe i @ bitrd
  (rsyl ifptrue @ mpbird (a1i b1odd) oddeq)
  (eleq1d @ syl6eq diveq1 b1div2));

local def least (A: set): nat = $ the {x | x e. A /\ A. y (y e. A -> x <= y)} $;

theorem leasteq: $ A == B -> least A = least B $ =
'(theeqd @ !! cbvabd x1 x2 @ anbid (eleqd anr anl) @
  !! cbvald y1 y2 @ imbid (eleqd anr anll) (leeqd anlr anr));

theorem leastlem: $ a e. A -> least A e. A /\ A. z (z e. A -> least A <= z) $ =
(focus
  (have 'h1 _
    '(! ind x y _ $ A. z (z e. A -> x < z) \/
        E. u (u e. A /\ A. z (z e. A -> u <= z)) $ _ _ _ _
      (orbi1d @ albid @ imbi2d lteq1) (orbi1d @ albid @ imbi2d lteq1)
      (orbi1d @ albid @ imbi2d lteq1) (orbi1d @ albid @ imbi2d lteq1)
      (cases
        (orrd @ sylan id (a1i @ ax_gen @ a1i le01) @
          iexe @ anbid eleq1 @ albid @ imbi2d leeq1)
        (orld @ iald @ exp @ sylibr
          (mtd anl @ com12 @ syl5 anr (bi1d eleq1)) lt01))
      (eor
        (casesda
          (orrd @ sylan anr anl @
            iexe @ anbid eleq1 @ albid @ imbi2d leeq1)
          (orld @ ialdh (nfan nfal1 nfv) @ exp @ sylibr
            (iand (imp @ anwl eal)
              (mtd anlr @ exp @ mpbird anlr @ anwr eleq1))
            ltlene))
        orr)))
  (have 'h2 $ a e. A -> E. u (u e. A /\ A. z (z e. A -> u <= z)) $
    '(rsyl h1 @ mtd (a1i ltirr) @ com12 @ eale @ imbid eleq1 lteq2))
  (have 'h3 $ u e. A /\ A. z (z e. A -> u <= z) -> least A = u $
    '(!! eqtheabd v @ ibid
      (exp @ leasymd
        (mpd anll @ anwr @ anwr @ eale @ imbid eleq1 leeq2)
        (mpd anrl @ anwl @ anwr @ eale @ imbid eleq1 leeq2))
      (com12 @ bi2d @ anbid eleq1 @ albid @ imbi2d leeq1)))
  '(syl h2 @ eex @ mpbird id @ anbid (eleq1d h3) (albid @ imbi2d @ syl h3 leeq1)));

theorem leastel: $ a e. A -> least A e. A $ = '(anld @ !! leastlem x);

theorem leastle: $ a e. A -> least A <= a $ =
'(mpd (!! leastlem x) @ com12 @ anwr @ eale @ imbid eleq1 leeq2);

local def coprime (a b: nat): wff = $ A. d (d || a -> d || b -> d = 1) $;

local def invm (a n: nat): nat = $ least {b | mod(n): a * b = 1} $;

-- Godel's beta function
local def beta (a n: nat): nat = $ fst a % suc (snd a * suc n) $;

theorem betaeqd (h1: $ G -> a1 = a2 $) (h2: $ G -> n1 = n2 $):
  $ G -> beta a1 n1 = beta a2 n2 $ =
'(modeqd (syl h1 fsteq) (suceqd @ muleqd (syl h1 sndeq) (suceqd h2)));

theorem betaval: $ beta (a <> b) n = a % suc (b * suc n) $ =
'(modeqd id (a1i @ suceq @ muleq1 @ sndpr) fstpr);

theorem betathmlem1 (v: nat x): $ E. c (n || c /\ A. x (x < n -> v || c)) $;
theorem betathm (v: nat x): $ E. a A. x (x < n -> beta a i = v) $;

abstract def rec (z: nat) {x: nat} (s: nat x) (n: nat): nat =
$ the {v | E. a (beta a 0 = z /\ beta a n = v /\
    A. i (i < n -> beta a (suc i) = N[beta a i / x] s))} $;

theorem reclem1 (z: nat) {x: nat} (s: nat x) (n: nat):
  $ E. a (beta a 0 = z /\
    A. i (i < n -> beta a (suc i) = N[beta a i / x] s)) $;

pub theorem rec0 (z: nat) {x: nat} (s: nat x): $ rec z x s 0 = z $;
pub theorem recS (z: nat) {x: nat} (s: nat x) (n: nat):
  $ rec z x s (suc n) = N[rec z x s n / x] s $;

abstract def pow (a b: nat): nat; infixr pow: $^$ prec 80;
pub theorem pow0 (a: nat): $ a ^ 0 = 1 $;
pub theorem powS (a b: nat): $ a ^ suc b = a * a ^ b $;

def shl (a n: nat): nat = $ a * 2 ^ n $;
def shr (a n: nat): nat = $ a // 2 ^ n $;

def nel (a b: nat): wff = $ odd (shr a b) $;
def ns (a .x: nat): set = $ {x | nel x a} $; coercion ns: nat > set;
pub theorem axext {x: nat} (a b: nat): $ a == b -> a = b $;
pub theorem extlt (a b: nat): $ a e. b -> a < b $;
pub theorem nel0 (a: nat): $ ~ a e. 0 $;

def finite (A: set) (.n: nat): wff = $ E. n n == A $;

def lower (A: set) (.n: nat): nat = $ the {n | n == A} $;

abstract def sn (a: nat): nat;
pub theorem elsn (a b: nat): $ a e. sn b <-> a = b $;

abstract def ins (a b: nat): nat; infixr ins: $;$ prec 84;
pub theorem elins (a b c: nat): $ a e. ins b c <-> a = b \/ a e. c $;

def upto (n: nat): nat = $ 2 ^ n - 1 $;
pub theorem elupto (k n: nat): $ k e. upto n <-> k < n $;

def Bool: nat = $ 0 ; sn 1 $;
def Option (A: set) (.n: nat): set = $ {n | n = 0 \/ n - 1 e. A} $;

def subset (A B: set) (.x: nat): wff = $ A. x (x e. A -> x e. B) $;
infixl subset: $C_$ prec 50;

def Power (A: set) (.x: nat): set = $ {x | x C_ A} $;
def power (a: nat): nat = $ lower (Power a) $;

abstract def card (s: nat): nat;
pub theorem card0: $ card 0 = 0 $;
pub theorem cardS (a s: nat): $ ~a e. s -> card (a ; s) = suc (card s) $;

def cons (a b: nat): nat = $ suc (a <> b) $; infixr cons: $:$ prec 90;

abstract def sep (n: nat) (A: set): nat;
pub theorem elsep (n: nat) (A: set) (a: nat):
  $ a e. sep n A <-> a e. n /\ a e. A $;

def res (A: set) (n: nat): nat = $ sep (lower (Xp n V)) A $;
infixl res: $|`$ prec 55;
pub theorem elres (n a b: nat) (A: set):
  $ isfun A -> (a <> b e. A |` n <-> a e. n /\ a <> b e. A) $;

def Arrow (A B: set) (.f: nat): set =
$ {f | isfun f /\ Dom f == A /\ Ran f C_ B} $;

def write (f x y .a .b: nat): nat =
  $ lower (opab a b (a <> b e. f /\ a != x \/ a = x /\ b = y)) $;
pub theorem writeEq (f x y: nat): $ write f x y @ x = y $;
pub theorem writeNe (f x y a: nat): $ a != x -> write f x y @ a = f @ a $;

abstract def srec {x: nat} (s: nat x): set;
pub theorem srecval {x y: nat} (s: nat x) (n: nat):
  $ srec x s @ n = N[srec x s |` upto n / x] s $;

abstract def srecp (A: set): set;
pub theorem srecpval (A: set) (n: nat):
  $ n e. srecp A <-> n <> sep n (srecp A) e. A $;

abstract def all (A: set) (n: nat): wff;
pub theorem all0 (A: set): $ all A 0 $;
pub theorem allS (A: set) (a b: nat): $ all A (a : b) <-> a e. A /\ all A b $;

def List (A: set) (.n: nat): set = $ {n | all A n} $;

abstract def in (a l: nat): wff; infixl in: $IN$ prec 50;
pub theorem id0 (a: nat): $ ~ a IN 0 $;
pub theorem inS (a b l: nat): $ a IN (b : l) <-> a = b \/ a IN l $;

abstract def lmems (l: nat): nat;
pub theorem ellmems (a l: nat): $ a e. lmems l <-> a IN l $;

abstract def lrec (z: nat) (S: set) (n: nat): nat;
pub theorem lrec0 (z: nat) (S: set): $ lrec z S 0 = z $;
pub theorem lrecS (z: nat) (S: set) (a b: nat):
  $ lrec z S (a : b) = S @ (a <> lrec z S b) $;

abstract def len (l: nat): nat;
pub theorem len0: $ len 0 = 0 $;
pub theorem lenS (a b: nat): $ len (a : b) = suc (len b) $;

def Array (A: set) (n .l: nat): set = $ {l | l e. List A /\ len l = n} $;

abstract def snoc (l a: nat): nat; infixl snoc: $|>$ prec 85;
pub theorem snoc0 (a: nat): $ 0 |> a = a : 0 $;
pub theorem snocS (a b c: nat): $ (a : b) |> c = a : (b |> c) $;
pub theorem snoclt (a b: nat): $ a < a |> b $;

abstract def append (l1 l2: nat): nat; infixl append: $++$ prec 85;
pub theorem append0 (a: nat): $ 0 ++ a = a $;
pub theorem appendS (a b c: nat): $ (a : b) ++ c = a : (b ++ c) $;

abstract def nth (n l: nat): nat;
pub theorem nth0 (n: nat): $ nth n 0 = 0 $;
pub theorem nthZ (a l: nat): $ nth 0 (a : l) = suc a $;
pub theorem nthS (n a l: nat): $ nth (suc n) (a : l) = nth n l $;

abstract def repeat (a n: nat): nat;
pub theorem repeat0 (a: nat): $ repeat a 0 = 0 $;
pub theorem repeatS (a n: nat): $ repeat a (suc n) = a : repeat a n $;

def sublistAt (n l l2 .l1 .l3: nat): wff =
$ E. l1 E. l3 (l = l1 ++ l2 ++ l3 /\ len l1 = n) $;
