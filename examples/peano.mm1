delimiter $ ( [ { ~ $
          $ } ] ) , $;
strict provable sort wff;
term im (ph ps: wff): wff; infixr im: $->$ prec 25;
term not (ph: wff): wff; prefix not: $~$ prec 40;

axiom ax_1 (ph ps: wff): $ ph -> ps -> ph $;
axiom ax_2 (ph ps ch: wff): $ (ph -> ps -> ch) -> (ph -> ps) -> ph -> ch $;
axiom ax_3 (ph ps: wff): $ (~ph -> ~ps) -> ps -> ph $;
axiom ax_mp (ph ps: wff): $ ph -> ps $ > $ ph $ > $ ps $;

do {
  (set-timeout 500)
  (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
  (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
  (def last (match-fn [(a) a] [(_ . l) (last l)]))
  (def (append . ls) @ foldr ls () @ fn (l l2) @ foldr l l2 cons)
  (def (rev l) (foldl l () (fn (l a) (cons a l))))
  (def (verb e) (list ':verb e))
  (def (exact e) (refine (verb e)))
  (def refine-extra-args-orig refine-extra-args)
  (def (refine-extra-args refine p . ps) @
    foldl ps p @ fn (acc p2) @
      refine @ list 'ax_mp (verb acc) (verb p2))
  (def (result) (hd (get-goals)))
  (def (later) @ match (get-goals)
    [(g . gs) (apply set-goals @ append gs @ list g)])
};

theorem a1i (h: $ b $): $ a -> b $ = '(ax_1 h);
theorem a2i (h: $ a -> b -> c $): $ (a -> b) -> (a -> c) $ = '(ax_2 h);
theorem mpd (h1: $ a -> b $) (h2: $ a -> b -> c $): $ a -> c $ = '(ax_2 h2 h1);
theorem mpi (h1: $ b $) (h2: $ a -> b -> c $): $ a -> c $ = '(mpd (a1i h1) h2);
theorem id: $ a -> a $ = '(mpd (! ax_1 _ a) ax_1);
theorem idd: $ a -> b -> b $ = '(a1i id);
theorem syl (h1: $ b -> c $) (h2: $ a -> b $): $ a -> c $ = '(mpd h2 (a1i h1));
theorem rsyl (h1: $ a -> b $) (h2: $ b -> c $): $ a -> c $ = '(syl h2 h1);
theorem a1d (h: $ a -> b $): $ a -> c -> b $ = '(syl ax_1 h);
theorem a2d (h: $ a -> b -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl ax_2 h);
theorem a3d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl ax_3 h);
theorem sylc (h: $ b -> c -> d $) (h1: $ a -> b $) (h2: $ a -> c $): $ a -> d $ = '(mpd h2 @ syl h h1);
theorem syld (h1: $ a -> c -> d $) (h2: $ a -> b -> c $): $ a -> b -> d $ = '(mpd h2 @ a2d @ a1d h1);
theorem syl5 (h1: $ b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syld h2 (a1i h1));
theorem syl6 (h1: $ c -> d $) (h2: $ a -> b -> c $): $ a -> b -> d $ = '(syld (a1i h1) h2);
theorem imim2: $ (b -> c) -> (a -> b) -> (a -> c) $ = '(a2d ax_1);
theorem imim2i (h: $ b -> c $): $ (a -> b) -> (a -> c) $ = '(imim2 h);
theorem imim2d (h: $ a -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl imim2 h);
theorem absurd: $ ~a -> a -> b $ = '(a3d ax_1);
theorem com12 (h: $ a -> b -> c $): $ b -> a -> c $ = '(syl (a2i h) ax_1);
theorem com23 (h: $ a -> b -> c -> d $): $ a -> c -> b -> d $ = '(syl (com12 @ imim2d @ com12 id) h);
theorem absurdr: $ a -> ~a -> b $ = '(com12 absurd);
theorem imim1: $ (a -> b) -> (b -> c) -> (a -> c) $ = '(com12 imim2);
theorem imim1i (h: $ a -> b $): $ (b -> c) -> (a -> c) $ = '(imim1 h);
theorem imim1d (h: $ a -> b -> c $): $ a -> (c -> d) -> (b -> d) $ = '(syl imim1 h);
theorem imimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $):
  $ a -> (c -> d) -> (b -> e) $ = '(syld (imim1d h1) (imim2d h2));
theorem imidm: $ (a -> a -> b) -> a -> b $ = '(a2i (com12 id));
theorem contra: $ (~a -> a) -> a $ = '(imidm (a3d (a2i absurd)));
theorem dne: $ ~~a -> a $ = '(syl contra absurd);
theorem inot: $ (a -> ~a) -> ~a $ = '(syl contra (imim1 dne));
theorem con2: $ (a -> ~b) -> (b -> ~a) $ = '(a3d (syl5 dne id));
theorem notnot1: $ a -> ~~a $ = '(con2 id);
theorem con3: $ (a -> b) -> (~b -> ~a) $ = '(syl con2 (imim2i notnot1));
theorem con1: $ (~a -> b) -> (~b -> a) $ = '(a3d (imim2i notnot1));
theorem cases (h1: $ a -> b $) (h2: $ ~a -> b $): $ b $ = '(contra @ syl h1 @ con1 h2);
theorem casesd (h1: $ a -> b -> c $) (h2: $ a -> ~b -> c $): $ a -> c $ =
'(cases (com12 h1) (com12 h2));
theorem con1d (h: $ a -> ~b -> c $): $ a -> ~c -> b $ = '(syl con1 h);
theorem con2d (h: $ a -> b -> ~c $): $ a -> c -> ~b $ = '(syl con2 h);
theorem con3d (h: $ a -> b -> c $): $ a -> ~c -> ~b $ = '(syl con3 h);
theorem con4d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl ax_3 h);
theorem mt (h1: $ b -> a $) (h2: $ ~a $): $ ~b $ = '(con3 h1 h2);
theorem mtd (h1: $ a -> ~b $) (h2: $ a -> c -> b $): $ a -> ~c $ = '(mpd h1 (con3d h2));
theorem mt2d (h1: $ a -> c $) (h2: $ a -> b -> ~c $): $ a -> ~b $ = '(sylc con2 h2 h1);

def an (a b: wff): wff = $ ~(a -> ~b) $;
infixl an: $/\$ prec 35;

theorem anl: $ a /\ b -> a $ = '(con1 absurd);
theorem anr: $ a /\ b -> b $ = '(con1 ax_1);
theorem ian: $ a -> b -> a /\ b $ = '(syl con2 (com12 id));
theorem iand (h1: $ a -> b $) (h2: $ a -> c $): $ a -> b /\ c $ = '(sylc ian h1 h2);
theorem anld (h: $ a -> b /\ c $): $ a -> b $ = '(syl anl h);
theorem anrd (h: $ a -> b /\ c $): $ a -> c $ = '(syl anr h);
theorem iani (h1: $ a $) (h2: $ b $): $ a /\ b $ = '(ian h1 h2);
theorem anwl (h: $ a -> c $): $ a /\ b -> c $ = '(syl h anl);
theorem anwr (h: $ b -> c $): $ a /\ b -> c $ = '(syl h anr);
theorem anll: $ a /\ b /\ c -> a $ = '(anwl anl);
theorem anlr: $ a /\ b /\ c -> b $ = '(anwl anr);
theorem anrl: $ a /\ (b /\ c) -> b $ = '(anwr anl);
theorem anrr: $ a /\ (b /\ c) -> c $ = '(anwr anr);
theorem anwll (h: $ a -> d $): $ a /\ b /\ c -> d $ = '(anwl (anwl h));
theorem anw3l (h: $ a -> e $): $ a /\ b /\ c /\ d -> e $ = '(anwll (anwl h));
theorem an3l: $ a /\ b /\ c /\ d -> a $ = '(anwll anl);
theorem anllr: $ a /\ b /\ c /\ d -> b $ = '(anwll anr);
theorem imp (h: $ a -> b -> c $): $ a /\ b -> c $ = '(sylc h anl anr);
theorem exp (h: $ a /\ b -> c $): $ a -> b -> c $ = '(syl6 h ian);
theorem impcom (h: $ a -> b -> c $): $ b /\ a -> c $ = '(imp (com12 h));
theorem expcom (h: $ a /\ b -> c $): $ b -> a -> c $ = '(com12 (exp h));
theorem sylan (h: $ b /\ c -> d $) (h1: $ a -> b $) (h2: $ a -> c $):
  $ a -> d $ = '(syl h @ iand h1 h2);
theorem animd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b /\ d -> c /\ e $ =
'(exp (iand (imp (syl5 anl h1)) (imp (syl5 anr h2))));
theorem anim1d (h: $ a -> b -> c $): $ a -> b /\ d -> c /\ d $ = '(animd h idd);
theorem anim2d (h: $ a -> c -> d $): $ a -> b /\ c -> b /\ d $ = '(animd idd h);
theorem anim1: $ (a -> b) -> a /\ c -> b /\ c $ = '(anim1d id);
theorem anim2: $ (b -> c) -> a /\ b -> a /\ c $ = '(anim2d id);
theorem anim2a: $ (a -> b -> c) -> (a /\ b -> a /\ c) $ =
'(exp @ iand anrl @ mpd anrr @ mpd anrl anl);
theorem ancom: $ a /\ b -> b /\ a $ = '(iand anr anl);
theorem an32s (h: $ a /\ b /\ c -> d $): $ a /\ c /\ b -> d $ =
'(sylan h (iand anll anr) anlr);
theorem casesda (h1: $ a /\ b -> c $) (h2: $ a /\ ~b -> c $): $ a -> c $ =
'(casesd (exp h1) (exp h2));
theorem inotda (h: $ a /\ b -> ~b $): $ a -> ~b $ = '(syl inot @ exp h);
theorem mpand (h1: $ a -> b $) (h2: $ a /\ b -> c $): $ a -> c $ = '(mpd h1 (exp h2));
theorem mtand (h1: $ a -> ~b $) (h2: $ a /\ c -> b $): $ a -> ~c $ = '(mtd h1 (exp h2));
theorem mtani (h1: $ ~b $) (h2: $ a /\ c -> b $): $ a -> ~c $ = '(mtand (a1i h1) h2);

def iff (a b: wff): wff = $ (a -> b) /\ (b -> a) $;
infixl iff: $<->$ prec 20;

theorem bi1: $ (a <-> b) -> a -> b $ = 'anl;
theorem bi1i (h: $ a <-> b $): $ a -> b $ = '(bi1 h);
theorem bi1d (h: $ a -> (b <-> c) $): $ a -> b -> c $ = '(syl bi1 h);
theorem bi2: $ (a <-> b) -> b -> a $ = 'anr;
theorem bi2i (h: $ a <-> b $): $ b -> a $ = '(bi2 h);
theorem bi2d (h: $ a -> (b <-> c) $): $ a -> c -> b $ = '(syl bi2 h);
theorem ibii (h1: $ a -> b $) (h2: $ b -> a $): $ a <-> b $ = '(iani h1 h2);
theorem ibid (h1: $ a -> b -> c $) (h2: $ a -> c -> b $): $ a -> (b <-> c) $ = '(iand h1 h2);
theorem ibida (h1: $ a /\ b -> c $) (h2: $ a /\ c -> b $): $ a -> (b <-> c) $ = '(ibid (exp h1) (exp h2));
theorem biid: $ a <-> a $ = '(ibii id id);
theorem biidd: $ a -> (b <-> b) $ = '(a1i biid);
theorem mpbi (h1: $ a <-> b $) (h2: $ a $): $ b $ = '(bi1i h1 h2);
theorem mpbir (h1: $ b <-> a $) (h2: $ a $): $ b $ = '(bi2i h1 h2);
theorem mpbid (h1: $ a -> (b <-> c) $) (h2: $ a -> b $): $ a -> c $ = '(mpd h2 (bi1d h1));
theorem mpbird (h1: $ a -> (c <-> b) $) (h2: $ a -> b $): $ a -> c $ = '(mpd h2 (bi2d h1));
theorem mpbii (h1: $ b $) (h2: $ a -> (b <-> c) $): $ a -> c $ = '(mpbid h2 (a1i h1));
theorem mpbiri (h1: $ b $) (h2: $ a -> (c <-> b) $): $ a -> c $ = '(mpbird h2 (a1i h1));
theorem mtbi (h1: $ a <-> b $) (h2: $ ~a $): $ ~b $ = '(mt (bi2 h1) h2);
theorem mtbir (h1: $ b <-> a $) (h2: $ ~a $): $ ~b $ = '(mt (bi1 h1) h2);
theorem mtbid (h1: $ a -> (b <-> c) $) (h2: $ a -> ~b $): $ a -> ~c $ = '(mtd h2 (bi2d h1));
theorem mtbird (h1: $ a -> (c <-> b) $) (h2: $ a -> ~b $): $ a -> ~c $ = '(mtd h2 (bi1d h1));
theorem con1b: $ (~a <-> b) -> (~b <-> a) $ = '(ibid (con1d bi1) (con2d bi2));
theorem con2b: $ (a <-> ~b) -> (b <-> ~a) $ = '(ibid (con2d bi1) (con1d bi2));
theorem con3b: $ (a <-> b) -> (~a <-> ~b) $ = '(ibid (con3d bi2) (con3d bi1));
theorem con4b: $ (~a <-> ~b) -> (a <-> b) $ = '(ibid (con4d bi2) (con4d bi1));
theorem notnot: $ a <-> ~~a $ = '(ibii notnot1 dne);
theorem bithd (h1: $ a -> b $) (h2: $ a -> c $): $ a -> (b <-> c) $ = '(ibid (a1d h2) (a1d h1));
theorem binthd (h1: $ a -> ~b $) (h2: $ a -> ~c $): $ a -> (b <-> c) $ = '(syl con4b @ bithd h1 h2);
theorem bith: $ a -> b -> (a <-> b) $ = '(exp @ bithd anl anr);
theorem binth: $ ~a -> ~b -> (a <-> b) $ = '(exp @ binthd anl anr);
theorem bicom: $ (a <-> b) -> (b <-> a) $ = '(ibid bi2 bi1);
theorem bicomd (h: $ a -> (b <-> c) $): $ a -> (c <-> b) $ = '(syl bicom h);
theorem bitrd (h1: $ a -> (b <-> c) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ =
'(ibid (syld (bi1d h2) (bi1d h1)) (syld (bi2d h1) (bi2d h2)));
theorem bitr3d (h1: $ a -> (c <-> b) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (bicomd h1) h2);
theorem bitr4d (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> c) $): $ a -> (b <-> d) $ = '(bitrd h1 (bicomd h2));
theorem bitr: $ (a <-> b) -> (b <-> c) -> (a <-> c) $ = '(exp (bitrd anl anr));
theorem bitr3: $ (b <-> a) -> (b <-> c) -> (a <-> c) $ = '(exp (bitr3d anl anr));
theorem bitr4: $ (a <-> b) -> (c <-> b) -> (a <-> c) $ = '(exp (bitr4d anl anr));
theorem sylib (h1: $ b <-> c $) (h2: $ a -> b $): $ a -> c $ = '(syl (bi1i h1) h2);
theorem sylibr (h1: $ c <-> b $) (h2: $ a -> b $): $ a -> c $ = '(syl (bi2i h1) h2);
theorem sylbi (h1: $ a <-> b $) (h2: $ b -> c $): $ a -> c $ = '(syl h2 (bi1i h1));
theorem sylbir (h1: $ b <-> a $) (h2: $ b -> c $): $ a -> c $ = '(syl h2 (bi2i h1));
theorem syl5bb (h1: $ b <-> c $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (a1i h1) h2);
theorem syl5bbr (h1: $ c <-> b $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(syl5bb (bicom h1) h2);
theorem syl6bb (h1: $ c <-> d $) (h2: $ a -> (b <-> c) $): $ a -> (b <-> d) $ = '(bitrd h2 (a1i h1));
theorem syl6bbr (h1: $ d <-> c $) (h2: $ a -> (b <-> c) $): $ a -> (b <-> d) $ = '(syl6bb (bicom h1) h2);
theorem syl5bi (h1: $ b <-> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syl5 (bi1 h1) h2);
theorem syl5bir (h1: $ c <-> b $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syl5bi (bicom h1) h2);
theorem syl6ibr (h1: $ d <-> c $) (h2: $ a -> b -> c $): $ a -> b -> d $ = '(syl6 (bi2 h1) h2);
theorem syl5ibrcom (h1: $ c -> (b <-> d) $) (h2: $ a -> d $): $ a -> c -> b $ = '(com12 @ syl5 h2 (bi2d h1));
theorem bitr3g (h1: $ b <-> d $) (h2: $ c <-> e $) (h: $ a -> (b <-> c) $):
  $ a -> (d <-> e) $ = '(syl5bb (bicom h1) @ syl6bb h2 h);
theorem bitr4g (h1: $ d <-> b $) (h2: $ e <-> c $) (h: $ a -> (b <-> c) $):
  $ a -> (d <-> e) $ = '(syl5bb h1 @ syl6bb (bicom h2) h);
theorem bitr3gi (h1: $ a <-> c $) (h2: $ b <-> d $) (h: $ a <-> b $): $ c <-> d $ = '(bitr3 h1 @ bitr h h2);
theorem bitr4gi (h1: $ c <-> a $) (h2: $ d <-> b $) (h: $ a <-> b $): $ c <-> d $ = '(bitr h1 @ bitr4 h h2);
theorem impbi (h: $ a -> (b <-> c) $): $ a /\ b -> c $ = '(imp @ bi1d h);
theorem impbir (h: $ a -> (c <-> b) $): $ a /\ b -> c $ = '(imp @ bi2d h);
theorem ancomb: $ a /\ b <-> b /\ a $ = '(ibii ancom ancom);
theorem anass: $ a /\ b /\ c <-> a /\ (b /\ c) $ =
'(ibii (iand anll (anim1 anr)) (iand (anim2 anl) anrr));
theorem bian2a: $ (a -> b) -> (a <-> a /\ b) $ = '(ibid (a2i ian) (a1i anl));
theorem bian1a: $ (b -> a) -> (b <-> a /\ b) $ = '(syl6bb ancomb bian2a);
theorem bian1: $ a -> (b <-> a /\ b) $ = '(syl bian1a ax_1);
theorem bian2: $ b -> (a <-> a /\ b) $ = '(syl bian2a ax_1);
theorem notbi: $ (a <-> b) -> (~a <-> ~b) $ = 'con3b;
theorem notbii (h: $ a <-> b $): $ ~a <-> ~b $ = '(notbi h);
theorem notbid (h: $ a -> (b <-> c) $): $ a -> (~b <-> ~c) $ = '(syl notbi h);
theorem imbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b -> d <-> c -> e) $ =
'(ibid (imimd (bi2d h1) (bi1d h2)) (imimd (bi1d h1) (bi2d h2)));
theorem imbi1d (h: $ a -> (b <-> c) $): $ a -> (b -> d <-> c -> d) $ = '(imbid h biidd);
theorem imbi2d (h: $ a -> (c <-> d) $): $ a -> (b -> c <-> b -> d) $ = '(imbid biidd h);
theorem imbi1i (h: $ a <-> b $): $ a -> c <-> b -> c $ = '(imbi1d id h);
theorem imbi2i (h: $ b <-> c $): $ a -> b <-> a -> c $ = '(imbi2d id h);
theorem imbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a -> c <-> b -> d $ = '(bitr (imbi1i h1) (imbi2i h2));
theorem anbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b /\ d <-> c /\ e) $ =
'(ibid (animd (bi1d h1) (bi1d h2)) (animd (bi2d h1) (bi2d h2)));
theorem anbi1d (h: $ a -> (b <-> c) $): $ a -> (b /\ d <-> c /\ d) $ = '(anbid h biidd);
theorem anbi2d (h: $ a -> (c <-> d) $): $ a -> (b /\ c <-> b /\ d) $ = '(anbid biidd h);
theorem anbi: $ (a <-> b) -> (c <-> d) -> (a /\ c <-> b /\ d) $ = '(exp @ anbid anl anr);
theorem anbi1i (h: $ a <-> b $): $ a /\ c <-> b /\ c $ = '(anbi1d id h);
theorem anbi2i (h: $ b <-> c $): $ a /\ b <-> a /\ c $ = '(anbi2d id h);
theorem anbi2a: $ (a -> (b <-> c)) -> (a /\ b <-> a /\ c) $ =
'(ibid (syl anim2a @ imim2i bi1) (syl anim2a @ imim2i bi2));
theorem anbi1a: $ (c -> (a <-> b)) -> (a /\ c <-> b /\ c) $ = '(syl5bb ancomb @ syl6bb ancomb anbi2a);
theorem rbida (h1: $ a /\ c -> b $) (h2: $ a /\ d -> b $)
  (h: $ a /\ b -> (c <-> d) $): $ a -> (c <-> d) $ =
'(bitrd (syl bian2a @ exp h1) @ bitr4d (syl anbi1a @ exp h) (syl bian2a @ exp h2));
theorem rbid (h1: $ b -> a $) (h2: $ c -> a $) (h: $ a -> (b <-> c) $): $ b <-> c $ =
'(bitr (bian2a h1) @ bitr4 (anbi1a h) (bian2a h2));
theorem bibid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> ((b <-> d) <-> (c <-> e)) $ =
'(anbid (imbid h1 h2) (imbid h2 h1));
theorem bibi1d (h: $ a -> (b <-> c) $): $ a -> ((b <-> d) <-> (c <-> d)) $ = '(bibid h biidd);
theorem bibi2d (h: $ a -> (c <-> d) $): $ a -> ((b <-> c) <-> (b <-> d)) $ = '(bibid biidd h);
theorem bibi: $ (a <-> b) -> (c <-> d) -> ((a <-> c) <-> (b <-> d)) $ = '(exp (bibid anl anr));
theorem impexp: $ (a /\ b -> c) <-> (a -> b -> c) $ =
'(ibii (exp @ exp @ mpd (anim1 anr) anll) (exp @ mpd anrr @ mpd anrl anl));

def or (a b: wff): wff = $ ~a -> b $;
infixl or: $\/$ prec 30;

theorem orl: $ a -> a \/ b $ = 'absurdr;
theorem orr: $ b -> a \/ b $ = 'ax_1;
theorem eori (h1: $ a -> c $) (h2: $ b -> c $): $ a \/ b -> c $ =
'(casesd (a1i h1) (imim2i h2));
theorem eord (h1: $ a -> b -> d $) (h2: $ a -> c -> d $):
  $ a -> b \/ c -> d $ = '(com12 (eori (com12 h1) (com12 h2)));
theorem eorda (h1: $ a /\ b -> d $) (h2: $ a /\ c -> d $):
  $ a -> b \/ c -> d $ = '(eord (exp h1) (exp h2));
theorem orld (h: $ a -> b $): $ a -> b \/ c $ = '(syl orl h);
theorem orrd (h: $ a -> c $): $ a -> b \/ c $ = '(syl orr h);
theorem eor: $ (a -> c) -> (b -> c) -> a \/ b -> c $ = '(exp (eord anl anr));
theorem orimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b \/ d -> c \/ e $ =
'(eord (syl6 orl h1) (syl6 orr h2));
theorem orim1d (h: $ a -> b -> c $): $ a -> b \/ d -> c \/ d $ = '(orimd h idd);
theorem orim2d (h: $ a -> c -> d $): $ a -> b \/ c -> b \/ d $ = '(orimd idd h);
theorem orbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b \/ d <-> c \/ e) $ =
'(ibid (orimd (bi1d h1) (bi1d h2)) (orimd (bi2d h1) (bi2d h2)));
theorem orbi1d (h: $ a -> (b <-> c) $): $ a -> (b \/ d <-> c \/ d) $ = '(orbid h biidd);
theorem orbi2d (h: $ a -> (c <-> d) $): $ a -> (b \/ c <-> b \/ d) $ = '(orbid biidd h);
theorem orbi1i (h: $ a <-> b $): $ a \/ c <-> b \/ c $ = '(orbi1d id h);
theorem orbi2i (h: $ b <-> c $): $ a \/ b <-> a \/ c $ = '(orbi2d id h);
theorem orbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a \/ c <-> b \/ d $ = '(bitr (orbi1i h1) (orbi2i h2));
theorem orcom: $ a \/ b -> b \/ a $ = 'con1;
theorem orcomb: $ a \/ b <-> b \/ a $ = '(ibii orcom orcom);
theorem notan2: $ ~(a /\ b) <-> a -> ~b $ = '(bicom notnot);
theorem notan: $ ~(a /\ b) <-> (~a \/ ~b) $ = '(bitr notan2 (imbi1i notnot));
theorem notor: $ ~(a \/ b) <-> (~a /\ ~b) $ = '(con1b (bitr4 notan (orbii notnot notnot)));
theorem andi: $ a /\ (b \/ c) <-> a /\ b \/ a /\ c $ =
'(ibii (imp @ orimd ian ian) @ eor (anim2 orl) (anim2 orr));
theorem andir: $ (a \/ b) /\ c <-> a /\ c \/ b /\ c $ =
'(bitr ancomb @ bitr andi @ orbii ancomb ancomb);
theorem biim1: $ a -> (b <-> a -> b) $ = '(ibid (a1i ax_1) (com12 id));
theorem biim2: $ ~b -> (~a <-> a -> b) $ = '(ibid (a1i absurd) (com12 con3));
theorem bior1: $ ~a -> (b <-> a \/ b) $ = 'biim1;
theorem bior2: $ ~b -> (a <-> a \/ b) $ = '(syl6bb orcomb bior1);
theorem em: $ p \/ ~p $ = 'id;

abstract def ifp (p a b: wff): wff = $ p /\ a \/ ~p /\ b $;

theorem ifpbid (h1: $ G -> (p <-> q) $) (h2: $ G -> (a <-> c) $) (h3: $ G -> (b <-> d) $):
  $ G -> (ifp p a b <-> ifp q c d) $ = '(orbid (anbid h1 h2) (anbid (notbid h1) h3));
theorem ifpbi1d (h: $ G -> (p <-> q) $): $ G -> (ifp p a b <-> ifp q a b) $ = '(ifpbid h biidd biidd);
theorem ifpbi2d (h: $ G -> (a <-> b) $): $ G -> (ifp p a c <-> ifp p b c) $ = '(ifpbid biidd h biidd);
theorem ifpbi3d (h: $ G -> (b <-> c) $): $ G -> (ifp p a b <-> ifp p a c) $ = '(ifpbid biidd biidd h);

pub theorem ifppos (p a b: wff): $ p -> (ifp p a b <-> a) $ =
'(ibid (eord (a1i anr) (syl5 anl absurdr)) (exp orl));
pub theorem ifpneg (p a b: wff): $ ~p -> (ifp p a b <-> b) $ =
'(ibid (eord (syl5 anl absurd) (a1i anr)) (exp orr));

term wtru: wff; prefix wtru: $T.$ prec max;
axiom tru: $ T. $;
def fal: wff = $ ~T. $; prefix fal: $F.$ prec max;

theorem trud (h: $ T. -> a $): $ a $ = '(h tru);
theorem notfal: $ ~F. $ = '(notnot1 tru);
theorem efal: $ F. -> a $ = '(absurd notfal);

sort nat;
term al {x: nat} (ph: wff x): wff; prefix al: $A.$ prec 40;

def ex {x: nat} (ph: wff x): wff = $ ~(A. x ~ph) $;
prefix ex: $E.$ prec 40;

term eq (a b: nat): wff; infixl eq: $=$ prec 50;

axiom ax_gen (ph: wff) {x: nat}: $ ph $ > $ A. x ph $;
axiom ax_4 {x: nat} (ph ps: wff x): $ A. x (ph -> ps) -> A. x ph -> A. x ps $;
axiom ax_5 {x: nat} (ph: wff): $ ph -> A. x ph $;
axiom ax_6 (a: nat) {x: nat}: $ E. x x = a $;
axiom ax_7 (a b c: nat): $ a = b -> a = c -> b = c $;
axiom ax_10 {x: nat} (ph: wff x): $ ~(A. x ph) -> A. x ~ (A. x ph) $;
axiom ax_11 {x y: nat} (ph: wff x y): $ A. x A. y ph -> A. y A. x ph $;
axiom ax_12 {x y: nat} (ph: wff y): $ A. y ph -> A. x (x = y -> ph) $;

theorem alimi (a b: wff x) (h: $ a -> b $): $ A. x a -> A. x b $ = '(ax_4 (ax_gen h));
theorem iald (a: wff) (b: wff x) (h: $ a -> b $): $ a -> A. x b $ = '(syl (alimi h) ax_5);
theorem albi (a b: wff x): $ A. x (a <-> b) -> (A. x a <-> A. x b) $ =
'(ibid (syl ax_4 @ alimi bi1) (syl ax_4 @ alimi bi2));
theorem albii (a b: wff x) (h: $ a <-> b $): $ A. x a <-> A. x b $ = '(albi @ ax_gen h);
theorem alimd (G: wff) (a b: wff x) (h: $ G -> a -> b $):
  $ G -> A. x a -> A. x b $ = '(syl ax_4 @ syl ax_5 h);
theorem albid (G: wff) (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (A. x a <-> A. x b) $ = '(syl albi @ iald h);
theorem alan (a b: wff x): $ A. x (a /\ b) <-> A. x a /\ A. x b $ =
'(ibii (iand (alimi anl) (alimi anr)) (imp @ syl ax_4 @ alimi ian));
theorem exim (a b: wff x): $ A. x (a -> b) -> E. x a -> E. x b $ =
'(syl con3 @ syl ax_4 @ alimi con3);
theorem eximi (a b: wff x) (h: $ a -> b $): $ E. x a -> E. x b $ = '(exim @ ax_gen h);
theorem exbi (a b: wff x): $ A. x (a <-> b) -> (E. x a <-> E. x b) $ =
'(notbid @ syl albi @ alimi notbi);
theorem exbid (G: wff) (a b: wff x) (h: $ G -> (a <-> b) $):
  $ G -> (E. x a <-> E. x b) $ = '(syl exbi @ iald h);
theorem exbii (a b: wff x) (h: $ a <-> b $):
  $ E. x a <-> E. x b $ = '(exbi @ ax_gen h);
theorem iex (a: wff x): $ a -> E. x a $ =
'(syl (mpi ax_6 exim) @ syl ax_12 @ !! ax_5 y);
theorem alnex (a: wff x): $ A. x ~a <-> ~(E. x a) $ = 'notnot;
theorem ngen (a: wff x) (h: $ ~a $): $ ~E. x a $ = '(notnot1 (ax_gen h));
theorem alex (a: wff x): $ A. x a <-> ~(E. x ~a) $ =
'(bitr (albii notnot) alnex);
theorem exnal (a: wff x): $ E. x ~a <-> ~(A. x a) $ = '(con2b alex);
theorem eal (a: wff x): $ A. x a -> a $ = '(ax_3 @ sylib exnal iex);
theorem exor (a b: wff x): $ E. x (a \/ b) <-> E. x a \/ E. x b $ =
'(bitr (notbii (bitr (albii notor) alan)) notan);
theorem eximd (G) (a b: wff x) (h: $ G -> a -> b $): $ G -> E. x a -> E. x b $ = '(syl exim @ iald h);

local def nf {x: nat} (a: wff x): wff = $ A. x (a -> A. x a) $;
prefix nf: $F/$ prec 10;

theorem nfv: $ F/ x a $ = '(ax_gen ax_5);
theorem nfi (a: wff x) (h: $ F/ x a $): $ a -> A. x a $ = '(eal h);
theorem nfri (a: wff x) (h: $ a -> A. x a $): $ F/ x a $ = '(ax_gen h);
theorem nfbii (a b: wff x) (h: $ a <-> b $): $ (F/ x a) <-> (F/ x b) $ = '(albii @ imbii h @ albii h);
theorem nfx (a b: wff x) (h1: $ a <-> b $) (h2: $ F/ x b $): $ F/ x a $ = '(bi2i (nfbii h1) h2);
theorem nfal1 (a: wff x): $ F/ x A. x a $ = '(ax_gen ax_5);
theorem nfal (a: wff x y) (h: $ F/ x a $): $ F/ x A. y a $ =
'(nfri @ syl ax_11 @ alimi @ nfi h);
theorem nfnot (a: wff x) (h: $ F/ x a $): $ F/ x ~a $ =
'(nfri @ con1 @ syl eal @ syl (con1 @ !! ax_10 x) @ eximi @ nfi h);
theorem nfim (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a -> b $ =
'(nfri @ cases
   (syl6 (syl (alimi ax_1) (nfi h2)) (com12 id))
   (a1d @ syl (alimi absurd) @ nfi @ nfnot h1));
theorem nfan (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a /\ b $ = '(nfnot @ nfim h1 @ nfnot h2);
theorem nfor (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a \/ b $ = '(nfim (nfnot h1) h2);
theorem nfbi (a b: wff x) (h1: $ F/ x a $) (h2: $ F/ x b $): $ F/ x a <-> b $ = '(nfan (nfim h1 h2) (nfim h2 h1));
theorem nfex1 (a: wff x): $ F/ x E. x a $ = '(nfnot nfal1);
theorem nfex (a: wff x y) (h: $ F/ x a $): $ F/ x E. y a $ = '(nfnot @ nfal @ nfnot h);

theorem ialdh (a b: wff x) (h1: $ F/ x a $) (h2: $ a -> b $): $ a -> A. x b $ =
'(syl (alimi h2) (nfi h1));
theorem eexh (a b: wff x) (h1: $ F/ x b $) (h2: $ a -> b $): $ E. x a -> b $ =
'(con1 @ ialdh (nfnot h1) @ con3 h2);
theorem eex (a: wff x) (b: wff) (h: $ a -> b $): $ E. x a -> b $ = '(eexh nfv h);
theorem eexdh (a b c: wff x) (h1: $ F/ x a $) (h2: $ F/ x c $)
  (h3: $ a -> b -> c $): $ a -> E. x b -> c $ =
'(con1d @ exp @ ialdh (nfan h1 (nfnot h2)) (imp @ con3d h3));
theorem alimdh (a b c: wff x) (h1: $ F/ x a $) (h2: $ a -> b -> c $):
  $ a -> A. x b -> A. x c $ = '(syl ax_4 @ ialdh h1 h2);
theorem albidh (G a b: wff x) (h1: $ F/ x G $) (h: $ G -> (a <-> b) $):
  $ G -> (A. x a <-> A. x b) $ = '(syl albi @ ialdh h1 h);
theorem al2imi (a b c: wff x) (h: $ a -> b -> c $): $ A. x a -> A. x b -> A. x c $ =
'(alimdh nfal1 @ syl h eal);
theorem eexd (a: wff) (b: wff x) (c: wff)
  (h: $ a -> b -> c $): $ a -> E. x b -> c $ = '(eexdh nfv nfv h);
theorem eexda (a: wff) (b: wff x) (c: wff)
  (h: $ a /\ b -> c $): $ a -> E. x b -> c $ = '(eexd (exp h));
theorem eexb (a: wff x) (b: wff): $ (E. x a -> b) <-> A. x (a -> b) $ =
'(ibii (ialdh (nfim nfex1 nfv) (imim1i iex)) (eexdh nfal1 nfv eal));
theorem ealeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ =
'(eexh (nfim nfal1 h) (syl6 eal @ alimd @ bi1d e) ax_6);
theorem iexeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(con2 (ealeh (nfnot h) (notbid e)));
theorem eale (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $ = '(ealeh nfv e);
theorem iexde (G: wff) (a: nat) (b: wff x)
  (e: $ G /\ x = a -> b $): $ G -> E. x b $ = '(mpi ax_6 (eximd (exp e)));
theorem iexe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ c -> E. x b $ = '(iexde @ mpbird (anwr e) anl);
theorem ealde (G: wff) (a: nat) (b: wff x)
  (e: $ G /\ x = a -> b -> c $): $ G -> A. x b -> c $ =
'(con4d @ exp @ sylib exnal @ iexde @ an32s @ imp @ con3d e);
theorem exan1 (a) (b: wff x): $ E. x (a /\ b) <-> a /\ E. x b $ =
'(ibii (iand (eex anl) (eximi anr)) (imp @ eximd ian));

theorem eqtr3: $ b = a -> b = c -> a = c $ = 'ax_7;
theorem eqid: $ a = a $ = '(!! eex x (imidm ax_7) ax_6);
theorem eqcom: $ a = b -> b = a $ = '(mpi eqid ax_7);
theorem eqtr: $ a = b -> b = c -> a = c $ = '(syl ax_7 eqcom);
theorem eqtr4: $ a = b -> c = b -> a = c $ = '(syl5 eqcom eqtr);
theorem eqcomb: $ a = b <-> b = a $ = '(ibii eqcom eqcom);
theorem eqeq1: $ a = b -> (a = c <-> b = c) $ = '(ibid eqtr3 eqtr);
theorem eqeq2: $ b = c -> (a = b <-> a = c) $ = '(ibid (com12 eqtr) (com12 eqtr4));
theorem eqeq1d (h: $ G -> a = b $): $ G -> (a = c <-> b = c) $ = '(syl eqeq1 h);
theorem eqeq2d (h: $ G -> b = c $): $ G -> (a = b <-> a = c) $ = '(syl eqeq2 h);
theorem eqeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a = c <-> b = d) $ = '(bitrd (eqeq1d h1) (eqeq2d h2));
theorem eqeq: $ a = b -> c = d -> (a = c <-> b = d) $ = '(exp (eqeqd anl anr));
theorem eqtr3d (h1: $ G -> b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc eqtr3 h1 h2);
theorem eqidd: $ G -> a = a $ = '(a1i eqid);
theorem eqcomd (h: $ G -> a = b $): $ G -> b = a $ = '(syl eqcom h);
theorem eqtrd (h1: $ G -> a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(sylc eqtr h1 h2);
theorem eqtr4d (h1: $ G -> a = b $) (h2: $ G -> c = b $): $ G -> a = c $ = '(sylc eqtr4 h1 h2);
theorem syl5eq (h1: $ a = b $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtrd (a1i h1) h2);
theorem syl5eqr (h1: $ b = a $) (h2: $ G -> b = c $): $ G -> a = c $ = '(eqtr3d (a1i h1) h2);
theorem syl6eq (h1: $ b = c $) (h2: $ G -> a = b $): $ G -> a = c $ = '(eqtrd h2 (a1i h1));
theorem syl6eqr (h1: $ c = b $) (h2: $ G -> a = b $): $ G -> a = c $ = '(eqtr4d h2 (a1i h1));
theorem eqtr4g (h1: $ c = a $) (h2: $ d = b $) (h: $ G -> a = b $):
  $ G -> c = d $ = '(syl5eq h1 @ syl6eqr h2 h);

theorem cbvalh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ =
'(ibii (ialdh (nfal h1) (eale e))
  (ialdh (nfal h2) (eale @ bicomd @ syl e eqcom)));
theorem cbval (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ A. x p <-> A. y q $ = '(cbvalh nfv nfv e);

theorem cbvexh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ =
'(notbi (cbvalh (nfnot h1) (nfnot h2) (notbid e)));
theorem cbvex (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ E. x p <-> E. y q $ = '(cbvexh nfv nfv e);

def ne (a b: nat): wff = $ ~ a = b $; infixl ne: $!=$ prec 50;

theorem neeq1: $ a = b -> (a != c <-> b != c) $ = '(notbid eqeq1);
theorem neeq2: $ b = c -> (a != b <-> a != c) $ = '(notbid eqeq2);
theorem neeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a != c <-> b != d) $ = '(notbid (eqeqd h1 h2));
theorem necom: $ a != b -> b != a $ = '(con3 eqcom);

def sb (a: nat) {x .y: nat} (ph: wff x): wff =
  $ A. y (y = a -> A. x (x = y -> ph)) $;
notation sb (a x ph) = ($[$:30) a ($/$:0) x ($]$:0) ph;

theorem sbeq (a: nat) (b: wff x): $ x = a -> (b <-> [a / x] b) $ =
'(ibid (exp @ !! iald y @ a1d @ syl ax_12 @ anwr ax_5)
  (mpi ax_6 @ eexd @ exp @ syl5 eal @
    syld (syl (com12 eal) @ imp eqtr4) @ com12 @ imim1i anr));
theorem nfsb1 (a: nat) (b: wff x): $ F/ x [a / x] b $ =
'(!! nfal _ y (nfim nfv nfal1));
theorem nfsb (a: nat) (b: wff x) (h: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ z (nfim nfv (nfal (nfim nfv h))));
theorem sbeq1d (G: wff) (a b: nat) (c: wff x)
  (h: $ G -> a = b $): $ G -> ([a / x] c <-> [b / x] c) $ =
'(!! albid y (imbi1d (eqeq2d h)));
theorem sbeq1 (a b: nat) (c: wff x): $ a = b -> ([a / x] c <-> [b / x] c) $ = '(sbeq1d id);
theorem sbeq2d (G: wff) (a: nat x) (b c: wff x)
  (h: $ G -> (b <-> c) $): $ G -> ([a / x] b <-> [a / x] c) $ =
'(!! albid y (imbi2d (albid (imbi2d h))));

theorem sbeht (a: nat) (b c: wff x) (h: $ F/ x c $):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ =
'(eexh (nfim nfal1 (nfbi nfsb1 nfv))
  (exp (bitr3d (anwl sbeq) (impcom eal))) ax_6);
theorem sbeh (a: nat) (b c: wff x) (h: $ F/ x c $)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeht h (ax_gen e));
theorem sbet (a: nat) (b: wff x) (c: wff):
  $ A. x (x = a -> (b <-> c)) -> ([a / x] b <-> c) $ = '(sbeht nfv);
theorem sbe (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ [a / x] b <-> c $ = '(sbeh nfv e);
theorem sbed (a: nat) (b: wff x) (c: wff)
  (e: $ G /\ x = a -> (b <-> c) $): $ G -> ([a / x] b <-> c) $ =
'(syl sbet @ iald @ exp e);
theorem dfsb2 (a: nat) (b: wff x): $ [a / x] b <-> A. x (x = a -> b) $ =
'(ibii
  (mpi (!! ax_6 y) @ eexd @ syl (a2i @ alimd @ imim1d @ com12 eqtr4) eal)
  (iald @ com12 @ alimd @ imim1d @ com12 eqtr));
theorem dfsb3 (a: nat) (b: wff x): $ [a / x] b <-> E. x (x = a /\ b) $ =
'(sbeh nfex1 @ syl con2b @ syl5bb (bitr4 (albii notan2) dfsb2) @ bicomd sbeq);
theorem sbco (a: nat x) (b: wff x):
  $ [a / y] [y / x] b <-> [a / x] b $ = '(bitr dfsb2 (albii (imbi2i dfsb2)));
theorem sbid (a: wff x): $ [x / x] a <-> a $ =
'(ibii (mpi (!! ax_6 y) @ eexd @ rsyl eal @ a2i @ rsyl eqcom @ com12 eal)
  (iald @ com12 @ bi1d @ syl6bb dfsb2 @ syl sbeq eqcom));
theorem sbth (a: nat x) (p: wff x) (h: $ p $): $ [a / x] p $ =
'(!! ax_gen y @ a1i @ ax_gen @ a1i h);
theorem cbvsbh (a: nat) (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ =
'(!! albii z (imbi2i (cbvalh (nfim nfv h1) (nfim nfv h2) (imbid (eqeq1) e))));
theorem cbvsb (a: nat) (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ [a / x] p <-> [a / y] q $ = '(cbvsbh nfv nfv e);

theorem aleqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ A. x (x = a -> p) <-> q $ = '(bitr3 dfsb2 @ sbe e);
theorem exeqe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ E. x (x = a /\ p) <-> q $ = '(bitr3 dfsb3 @ sbe e);
theorem cbvals (p: wff x): $ A. x p <-> A. y ([y / x] p) $ = '(cbvalh nfv nfsb1 sbeq);
theorem cbvexs (p: wff x): $ E. x p <-> E. y ([y / x] p) $ = '(cbvexh nfv nfsb1 sbeq);
theorem cbvald (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (A. x p <-> A. y q) $ =
'(bitrd (a1i cbvals) (albid @ syl sbet @ iald @ exp h));
theorem cbvexd (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> (E. x p <-> E. y q) $ =
'(bitrd (a1i cbvexs) (exbid @ syl sbet @ iald @ exp h));

strict sort set;
term ab {x: nat} (p: wff x): set;
notation ab {x: nat} (p: wff x): set = (${$:max) x ($|$:0) p ($}$:0);
term el: nat > set > wff; infixl el: $e.$ prec 50;
axiom elab (a: nat) {x: nat} (p: wff x):
  $ a e. {x | p} <-> [a / x] p $;
axiom ax_8 (a b: nat) (A: set): $ a = b -> a e. A -> b e. A $;

def eqs (A B: set) {.x: nat}: wff = $ A. x (x e. A <-> x e. B) $;
infixl eqs: $==$ prec 50;

theorem eqsid: $ A == A $ = '(!! ax_gen x biid);
theorem eqscom: $ A == B -> B == A $ = '(!! alimi x bicom);
theorem eqstr: $ A == B -> B == C -> A == C $ = '(syl ax_4 @ !! alimi x bitr);
theorem eqstr3: $ B == A -> B == C -> A == C $ = '(syl eqstr eqscom);
theorem eqstr4: $ A == B -> C == B -> A == C $ = '(syl5 eqscom eqstr);
theorem eqseq1: $ A == B -> (A == C <-> B == C) $ = '(ibid eqstr3 eqstr);
theorem eqseq2: $ B == C -> (A == B <-> A == C) $ = '(ibid (com12 eqstr) (com12 eqstr4));
theorem eqseq1d (h: $ G -> A == B $): $ G -> (A == C <-> B == C) $ = '(syl eqseq1 h);
theorem eqseq2d (h: $ G -> B == C $): $ G -> (A == B <-> A == C) $ = '(syl eqseq2 h);
theorem eqseqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> (A == C <-> B == D) $ = '(bitrd (eqseq1d h1) (eqseq2d h2));
theorem eqseq: $ A == B -> C == D -> (A == C <-> B == D) $ = '(exp (eqseqd anl anr));
theorem eqstr3d (h1: $ G -> B == A $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc eqstr3 h1 h2);
theorem eqsidd: $ G -> A == A $ = '(a1i eqsid);
theorem eqscomd (h: $ G -> A == B $): $ G -> B == A $ = '(syl eqscom h);
theorem eqstrd (h1: $ G -> A == B $) (h2: $ G -> B == C $): $ G -> A == C $ = '(sylc eqstr h1 h2);
theorem eqstr4d (h1: $ G -> A == B $) (h2: $ G -> C == B $): $ G -> A == C $ = '(sylc eqstr4 h1 h2);

theorem eleq1: $ a = b -> (a e. A <-> b e. A) $ = '(ibid ax_8 @ syl ax_8 eqcom);
theorem eleq2: $ A == B -> (a e. A <-> a e. B) $ = 'eal;
theorem eleq1d (h: $ G -> a = b $): $ G -> (a e. A <-> b e. A) $ = '(syl eleq1 h);
theorem eleq2d (h: $ G -> A == B $): $ G -> (a e. A <-> a e. B) $ = '(syl eleq2 h);
theorem eleqd (h1: $ G -> a = b $) (h2: $ G -> A == B $):
  $ G -> (a e. A <-> b e. B) $ = '(bitrd (eleq1d h1) (eleq2d h2));

theorem abeq (p q: wff x): $ A. x (p <-> q) -> {x | p} == {x | q} $ =
'(!! iald y @ bitr4g elab elab @ ealeh (nfbi nfsb1 nfsb1) (bibid sbeq sbeq));
theorem abeqd (G: wff) (p q: wff x)
  (h: $ G -> (p <-> q) $): $ G -> {x | p} == {x | q} $ = '(syl abeq @ iald h);
theorem eqri {x} (h: $ x e. A <-> x e. B $): $ A == B $ = '(ax_gen h);
theorem eqrd (G) {x} (h: $ G -> (x e. A <-> x e. B) $): $ G -> A == B $ = '(iald h);
theorem cbvabh (p q: wff x y) (h1: $ F/ y p $) (h2: $ F/ x q $)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ =
'(!! eqri z @ bitr4gi elab elab @ cbvsbh h1 h2 e);
theorem cbvab (p: wff x) (q: wff y)
  (e: $ x = y -> (p <-> q) $): $ {x | p} == {y | q} $ = '(cbvabh nfv nfv e);
theorem cbvabs (p: wff x): $ {x | p} == {y | [y / x] p} $ = '(cbvabh nfv nfsb1 sbeq);
theorem cbvabd (G: wff) (p: wff x) (q: wff y)
  (h: $ G /\ x = y -> (p <-> q) $): $ G -> {x | p} == {y | q} $ =
'(eqstrd (a1i cbvabs) @ abeqd @ syl sbet @ iald @ exp h);
theorem elab2 (a: nat x) (p: wff x): $ a e. {x | p} <-> [a / x] p $ =
'(bitr (bitr (eleq2 (cbvabh nfv nfsb1 sbeq)) elab) (!! sbco x y));
theorem elabe (a: nat) (p: wff x) (q: wff)
  (e: $ x = a -> (p <-> q) $): $ a e. {x | p} <-> q $ = '(bitr elab2 (sbe e));
theorem abid (p: wff x): $ x e. {x | p} <-> p $ = '(bitr elab2 sbid);
theorem abid2: $ {x | x e. A} == A $ = '(!! eqri y @ elabe eleq1);

def Inter (A B: set) (.x: nat): set = $ {x | x e. A /\ x e. B} $;
infixl Inter: $i^i$ prec 70;

theorem ineqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> A i^i C == B i^i D $ = '(!! abeqd x (anbid (eleq2d h1) (eleq2d h2)));
theorem elin: $ a e. A i^i B <-> a e. A /\ a e. B $ = '(!! elabe x @ anbid eleq1 eleq1);

def Union (A B: set) (.x: nat): set = $ {x | x e. A \/ x e. B} $;
infixl Union: $u.$ prec 65;

theorem uneqd (h1: $ G -> A == B $) (h2: $ G -> C == D $):
  $ G -> A u. C == B u. D $ = '(!! abeqd x (orbid (eleq2d h1) (eleq2d h2)));
theorem elun: $ a e. A u. B <-> a e. A \/ a e. B $ = '(!! elabe x @ orbid eleq1 eleq1);

def Univ (.x: nat): set = $ {x | T.} $; prefix Univ: $V$ prec max;

theorem eluniv: $ a e. V $ = '(mpbir (!! elabe x biidd) tru);

def subset (A B: set) (.x: nat): wff = $ A. x (x e. A -> x e. B) $;
infixl subset: $C_$ prec 50;

theorem dfss: $ A C_ B <-> A. x (x e. A -> x e. B) $ =
'(!! cbval y _ @ imbid eleq1 eleq1);
theorem ssel: $ A C_ B -> a e. A -> a e. B $ = '(!! eale x @ imbid eleq1 eleq1);
theorem sseld (h1: $ G -> A C_ B $) (h2: $ G -> a e. A $): $ G -> a e. B $ = '(sylc ssel h1 h2);
theorem ssid: $ A C_ A $ = '(!! ax_gen x id);
theorem sstr: $ A C_ B -> B C_ C -> A C_ C $ =
'(exp @ !! iald x @ syld (anwr ssel) (anwl ssel));

theorem inss1: $ A i^i B C_ A $ = '(!! ax_gen x @ sylbi elin anl);
theorem inss2: $ A i^i B C_ B $ = '(!! ax_gen x @ sylbi elin anr);

local def nfs {x: nat} (A: set x): wff = $ A. y (F/ x y e. A) $;
prefix nfs: $FS/$ prec 10;
local def nfn {x: nat} (a: nat x): wff = $ A. y (F/ x y = a) $;
prefix nfn: $FN/$ prec 10;

theorem nfsv: $ FS/ x A $ = '(!! ax_gen y nfv);
theorem nfnv: $ FN/ x a $ = '(!! ax_gen y nfv);
theorem nfsri {x y} (A: set x) (h: $ F/ x y e. A $): $ FS/ x A $ = '(ax_gen h);
theorem nfnri {x y} (a: nat x) (h: $ F/ x y = a $): $ FN/ x a $ = '(ax_gen h);
theorem nfel2 (a: nat) (A: set x) (h: $ FS/ x A $): $ F/ x a e. A $ = '(eal h);
theorem nfeq (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ F/ x a = b $ =
'(nfx (bicom @ !! exeqe y eqeq1) (nfex @ nfan (eal h1) (eal h2)));
theorem nfeq2 (b: nat x) (h: $ FN/ x b $): $ F/ x a = b $ = '(nfeq nfnv h);
theorem nfel (a: nat x) (A: set x) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ F/ x a e. A $ =
'(nfx (bicom @ !! exeqe y eleq1) (nfex @ nfan (eal h1) (eal h2)));
theorem nfab1 (p: wff x): $ FS/ x {x | p} $ = '(!! nfsri _ y @ nfx elab nfsb1);
theorem nfab (p: wff x y) (h: $ F/ x p $): $ FS/ x {y | p} $ = '(!! nfsri _ z @ nfx elab @ nfsb h);
theorem nfeqs (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ F/ x A == B $ =
'(!! nfal _ y @ nfbi (nfel2 h1) (nfel2 h2));
theorem nfnx (a b: nat x) (h1: $ a = b $) (h2: $ FN/ x b $): $ FN/ x a $ =
'(!! nfnri _ y @ nfx (eqeq2 h1) @ nfeq2 h2);
theorem nfin (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ FS/ x A i^i B $ =
'(!! nfab _ y @ nfan (nfel2 h1) (nfel2 h2));
theorem nfss (A B: set x) (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ F/ x A C_ B $ =
'(!! nfal _ y @ nfim (nfel2 h1) (nfel2 h2));

theorem nfsbh (a: nat x) (b: wff x) (h1: $ FN/ x a $) (h2: $ F/ x b $): $ F/ x [a / y] b $ =
'(!! nfal _ z (nfim (nfeq2 h1) (nfal (nfim nfv h2))));

theorem abeqb (p q: wff x): $ A. x (p <-> q) <-> {x | p} == {x | q} $ =
'(ibii abeq (ialdh (nfeqs nfab1 nfab1) (sylib (bibi abid abid) eleq2)));
theorem eqab2d (h: $ G -> (x e. A <-> p) $): $ G -> A == {x | p} $ =
'(sylib (!! cbvalh _ y nfv (nfbi nfv @ nfel2 nfab1) @ bibid eleq1 @ syl5bbr abid eleq1) (iald h));
theorem eqab2i (h: $ x e. A <-> p $): $ A == {x | p} $ = '(trud @ eqab2d @ a1i h);
theorem eqab1d (h: $ G -> (p <-> x e. A) $): $ G -> {x | p} == A $ = '(eqscomd @ eqab2d @ bicomd h);
theorem eqab1i (h: $ p <-> x e. A $): $ {x | p} == A $ = '(trud @ eqab1d @ a1i h);
theorem ssab (p q: wff x): $ A. x (p -> q) <-> {x | p} C_ {x | q} $ =
'(!! cbvalh _ y nfv (nfim (nfel2 nfab1) (nfel2 nfab1)) @
  imbid (syl6bbr elab sbeq) (syl6bbr elab sbeq));
theorem ssab1 (p: wff x): $ A. x (p -> x e. A) <-> {x | p} C_ A $ =
'(!! cbvalh _ y nfv (nfim (nfel2 nfab1) nfv) @ imbid (syl6bbr elab sbeq) eleq1);
theorem ssab2 (p: wff x): $ A. x (x e. A -> p) <-> A C_ {x | p} $ =
'(!! cbvalh _ y nfv (nfim nfv (nfel2 nfab1)) @ imbid eleq1 (syl6bbr elab sbeq));

def sbs (a: nat) {x .y: nat} (A: set x): set = $ {y | [a / x] y e. A} $;
notation sbs (a: nat) {x: nat} (A: set x): set =
  ($S[$:70) a ($/$:0) x ($]$:0) A;

theorem elsbs (a b: nat) (A: set x): $ b e. S[a / x] A <-> [a / x] b e. A $ =
'(bitr (!! elab y) @ sbe @ sbeq2d eleq1);
theorem sbseq (a: nat) (A: set x): $ x = a -> A == S[a / x] A $ =
'(!! eqrd y @ syl6bbr elsbs sbeq);
theorem nfsbs1 (a: nat) (A: set x): $ FS/ x S[a / x] A $ =
'(!! nfsri _ y (nfx elsbs nfsb1));
theorem nfsbsh (a: nat x) (A: set x y) (h1: $ FN/ x a $) (h2: $ FS/ x A $): $ FS/ x S[a / y] A $ =
'(!! nfsri _ z @ nfx elsbs @ nfsbh h1 @ nfel2 h2);
theorem nfsbs (a: nat) (A: set x y) (h: $ FS/ x A $): $ FS/ x S[a / y] A $ = '(nfsbsh nfnv h);
theorem sbseq1d (G: wff) (a b: nat) (A: set x) (h: $ G -> a = b $):
  $ G -> S[a / x] A == S[b / x] A $ = '(!! abeqd y (sbeq1d h));
theorem sbseq2d (G: wff) (a: nat x) (A B: set x)
  (h: $ G -> A == B $): $ G -> S[a / x] A == S[a / x] B $ =
'(!! abeqd y (sbeq2d (eleq2d h)));
theorem sbseht (a: nat) (A B: set x) (h: $ FS/ x B $):
  $ A. x (x = a -> A == B) -> S[a / x] A == B $ =
'(!! eqrd y @ syl5bb elsbs @ syl (sbeht @ nfel2 h) @ alimi @ imim2 eleq2);
theorem sbseh (a: nat) (A B: set x) (h: $ FS/ x B $)
  (e: $ x = a -> A == B $): $ S[a / x] A == B $ = '(sbseht h (ax_gen e));
theorem sbset (a: nat) (A: set x) (B: set):
  $ A. x (x = a -> A == B) -> S[a / x] A == B $ = '(sbseht nfsv);
theorem sbse (a: nat) (A: set x) (B: set)
  (e: $ x = a -> A == B $): $ S[a / x] A == B$ = '(sbseh nfsv e);
theorem sbsed (a: nat) (A: set x) (B: set)
  (e: $ G /\ x = a -> A == B $): $ G -> S[a / x] A == B $ =
'(syl sbset @ iald @ exp e);
theorem sbsid (a: set x): $ S[x / x] A == A $ =
'(!! eqri y @ bitr elsbs sbid);

term d0: nat; prefix d0: $0$ prec max;
term suc: nat > nat;

def d1:  nat = $suc 0$; prefix d1:  $1$  prec max;
def d2:  nat = $suc 1$; prefix d2:  $2$  prec max;
def d3:  nat = $suc 2$; prefix d3:  $3$  prec max;
def d4:  nat = $suc 3$; prefix d4:  $4$  prec max;
def d5:  nat = $suc 4$; prefix d5:  $5$  prec max;
def d6:  nat = $suc 5$; prefix d6:  $6$  prec max;
def d7:  nat = $suc 6$; prefix d7:  $7$  prec max;
def d8:  nat = $suc 7$; prefix d8:  $8$  prec max;
def d9:  nat = $suc 8$; prefix d9:  $9$  prec max;
def d10: nat = $suc 9$; prefix d10: $10$ prec max;

axiom peano1 (a: nat): $ suc a != 0 $;
axiom peano2 (a b: nat): $ suc a = suc b <-> a = b $;
axiom peano5 {x: nat} (ph: wff x):
  $ [0 / x] ph -> A. x (ph -> [suc x / x] ph) -> A. x ph $;

theorem d1ne0: $ 1 != 0 $ = 'peano1;
theorem d2ne0: $ 2 != 0 $ = 'peano1;
theorem suceq: $ a = b -> suc a = suc b $ = '(bi2 peano2);
theorem suceqd (h: $ G -> a = b $): $ G -> suc a = suc b $ = '(syl suceq h);

theorem ind {x y} (a) (px: wff x) (p0 pa: wff) (py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ p0 $) (h2: $ py -> ps $): $ pa $ =
'(eale ha @ peano5
  (mpbir (sbe h0) h1)
  (mpbir (cbvalh nfv (nfim nfv nfsb1) @ imbid hy @ sbeq1d suceq)
    (ax_gen @ rsyl h2 @ bi2i @ sbe hs)));

theorem indd {x y} (a) (px: wff x) (p0 pa: wff) (py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ G -> p0 $) (h2: $ G /\ py -> ps $): $ G -> pa $ =
'(ind (imbi2d h0) (imbi2d hy) (imbi2d hs) (imbi2d ha) h1 (a2i (exp h2)));

theorem exsuc (a: nat): $ a != 0 <-> E. x suc x = a $ =
'(ibii
  (! ind y z _ $ y != 0 -> E. x suc x = y $ _ _ _ _
    (imbid (notbid eqeq1) (exbid eqeq2)) (imbid (notbid eqeq1) (exbid eqeq2))
    (imbid (notbid eqeq1) (exbid eqeq2)) (imbid (notbid eqeq1) (exbid eqeq2))
    (absurdr eqid) (a1i (a1i (iexe (eqeq1d suceq) eqid))))
  (eex (mpbii peano1 neeq1)));

term the: set > nat;
axiom theid {x: nat} (A: set) (a: nat): $ A == {x | x = a} -> the A = a $;
axiom the0 {x y: nat} (A: set): $ ~E. y A == {x | x = y} -> the A = 0 $;

theorem theeqd (h: $ G -> A == B $): $ G -> the A = the B $ =
'(! casesd _ $ E. y A == {x | x = y} $ _
  (eexda @ eqtr4d (anwr theid) @ syl theid @ imp @ syl eqstr3 h)
  (exp @ eqtr4d (anwr the0) @ syl the0 @ impbi @ notbid @ exbid @ eqseq1d h));
theorem eqthed {x} (h: $ G -> (x e. A <-> x = a) $): $ G -> the A = a $ =
'(syl (!! theid z) @ eqrd @ syl6bbr (elabe eqeq1) h);
theorem eqtheabd (p: wff x) (h: $ G -> (p <-> x = a) $): $ G -> the {x | p} = a $ =
'(!! eqthed y @ syl5bb elab @
  rsyl (iald h) @ ealeh (nfbi nfsb1 nfv) @ bibid sbeq eqeq1);

theorem eqthe0d {x} (h: $ G -> x e. A -> x = 0 $): $ G -> the A = 0 $ =
(focus
  '(casesd (eexda _) (a1i (!! the0 y x)))
  '(syl theid @ eqstrd anr @ syl (abeqd eqeq2) _)
  '(mpd (mpbiri (mpbir (elabe eqeq1) eqid) (anwr eleq2)) (anwl h)));
theorem eqthe0abd (p: wff x) (h: $ G -> p -> x = 0 $): $ G -> the {x | p} = 0 $ =
'(!! eqthe0d y @ syl5bi elab @
  rsyl (iald h) @ ealeh (nfim nfsb1 nfv) @ imbid sbeq eqeq1);

theorem eqtheb: $ a = the A <-> (A == {x | x = a} \/ ~E. y A == {x | x = y} /\ a = 0) $ =
'(ibii
  (casesda
    (imp @ eexd @ exp @ orld @ mpbird
      (syl (eqseq2d @ abeqd eqeq2) @ eqtrd anl @ anwr theid) anr)
    (orrd @ iand anr @ eqtrd anl @ anwr the0))
  (eor (eqcomd theid) (eqtrd anr @ anwl @ eqcomd the0)));

theorem nfthe (A: set x) (h: $ FS/ x A $): $ FN/ x the A $ =
'(!! nfnri _ y (nfx (!! eqtheb u v)
  (nfor (nfeqs h nfsv) (nfan (nfnot (nfex (nfeqs h nfsv))) nfv))));

def sbn (a: nat) {x .y: nat} (b: nat x): nat = $ the {y | [a / x] y = b} $;
notation sbn (a: nat) {x: nat} (b: nat x): nat =
  ($N[$:70) a ($/$:0) x ($]$:0) b;

theorem sbneq (a: nat) (b: nat x): $ x = a -> b = N[a / x] b $ =
'(eqcomd @ !! eqtheabd y @ bicomd sbeq);
theorem nfsbn1 (a: nat) (b: nat x): $ FN/ x N[a / x] b $ =
'(nfthe @ !! nfab _ y nfsb1);
theorem nfsbnh (a b: nat x y) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x N[a / y] b $ =
'(nfthe @ !! nfab _ y @ nfsbh h1 @ nfeq2 h2);
theorem nfsbn (a: nat) (b: nat x y) (h: $ FN/ x b $): $ FN/ x N[a / y] b $ = '(nfsbnh nfnv h);
theorem sbneq2d (G: wff) (a b c: nat x)
  (h: $ G -> b = c $): $ G -> N[a / x] b = N[a / x] c $ =
'(theeqd @ !! cbvabd y z @ sbeq2d @ eqeqd anr @ anwl h);
theorem sbneht (a: nat) (b c: nat x) (h: $ FN/ x c $):
  $ A. x (x = a -> b = c) -> N[a / x] b = c $ =
'(!! eqtheabd y @ syl (sbeht @ nfeq2 h) @ alimi @ imim2 eqeq2);
theorem sbneh (a: nat) (b c: nat x) (h: $ FN/ x c $)
  (e: $ x = a -> b = c $): $ N[a / x] b = c $ = '(sbneht h @ ax_gen e);
theorem sbnet (a: nat) (b: nat x) (c: nat):
  $ A. x (x = a -> b = c) -> N[a / x] b = c $ = '(sbneht nfnv);
theorem sbne (a: nat) (b: nat x) (c: nat)
  (e: $ x = a -> b = c $): $ N[a / x] b = c $ = '(sbneh nfnv e);
theorem sbned (a: nat) (b: nat x) (c: nat)
  (e: $ G /\ x = a -> b = c $): $ G -> N[a / x] b = c $ = '(syl sbnet @ iald @ exp e);
theorem sbneq1 (a b: nat) (c: nat x): $ a = b -> N[a / x] c = N[b / x] c $ =
'(syl (sbneht nfsbn1) @ iald @ syl6 sbneq (bi1d eqeq2));
theorem sbnid (a: nat x): $ N[x / x] a = a $ = '(trud @ !! eqtheabd y @ a1i sbid);

theorem nfnlem {y} (a c: nat x) (e: $ y = a -> b = c $) (h: $ FN/ x a $): $ FN/ x c $ =
'(nfnx (eqcom @ sbne e) @ nfsbnh h nfnv);
theorem nfnlem2 {y z} (a b d: nat x) (e: $ y = a /\ z = b -> c = d $)
  (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x d $ =
'(nfnx (eqcom @ sbne @ sbned e) @ nfsbnh h1 @ nfsbnh h2 nfnv);

theorem nfsuc (a: nat x) (h: $ FN/ x a $): $ FN/ x suc a $ = '(!! nfnlem _ y suceq h);

term add: nat > nat > nat; infixl add: $+$ prec 65;
term mul: nat > nat > nat; infixl mul: $*$ prec 70;

axiom addeq (a b c d: nat): $ a = b -> c = d -> a + c = b + d $;
axiom muleq (a b c d: nat): $ a = b -> c = d -> a * c = b * d $;
axiom add0 (a: nat): $ a + 0 = a $;
axiom addS (a b: nat): $ a + suc b = suc (a + b) $;
axiom mul0 (a: nat): $ a * 0 = 0 $;
axiom mulS (a b: nat): $ a * suc b = a * b + a $;

theorem addeq1: $ a = b -> a + c = b + c $ = '(mpi eqid addeq);
theorem muleq1: $ a = b -> a * c = b * c $ = '(mpi eqid muleq);
theorem addeq2: $ a = b -> c + a = c + b $ = '(addeq eqid);
theorem muleq2: $ a = b -> c * a = c * b $ = '(muleq eqid);
theorem addeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a + c = b + d $ = '(sylc addeq h1 h2);
theorem muleqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a * c = b * d $ = '(sylc muleq h1 h2);
theorem nfadd (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $):
  $ FN/ x a + b $ = '(!! nfnlem2 _ y z (addeqd anl anr) h1 h2);
theorem nfmul (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $):
  $ FN/ x a * b $ = '(!! nfnlem2 _ y z (muleqd anl anr) h1 h2);

theorem add02: $ a + 0 = a $ = 'add0;
theorem add01: $ 0 + a = a $ =
'(! ind x y _ $ 0 + x = x $ _ _ _ _
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  (eqeqd addeq2 id) (eqeqd addeq2 id)
  add0 (syl5eq addS suceq));

theorem addS2: $ a + suc b = suc (a + b) $ = 'addS;
theorem addS1: $ suc a + b = suc (a + b) $ =
'(! ind x y _ $ suc a + x = suc (a + x) $ _ _ _ _
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqeqd addeq2 (suceqd addeq2)) (eqeqd addeq2 (suceqd addeq2))
  (eqtr4 add0 (suceq add0))
  (syl5eq addS (suceqd (syl6eqr addS id))));
theorem addSass: $ suc a + b = a + suc b $ = '(eqtr4 addS1 addS2);

theorem add12: $ a + 1 = suc a $ = '(eqtr addS (suceq add0));
theorem add11: $ 1 + a = suc a $ = '(eqtr addS1 (suceq add01));

theorem addcom: $ a + b = b + a $ =
'(! ind x y _ $ a + x = x + a $ _ _ _ _
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqeqd addeq2 addeq1) (eqeqd addeq2 addeq1)
  (eqtr4 add0 add01) (eqtr4g addS addS1 suceq));

theorem addass: $ (a + b) + c = a + (b + c) $ =
'(! ind x y _ $ (a + b) + x = a + (b + x) $ _ _ _ _
  (eqeqd addeq2 (syl addeq2 addeq2)) (eqeqd addeq2 (syl addeq2 addeq2))
  (eqeqd addeq2 (syl addeq2 addeq2)) (eqeqd addeq2 (syl addeq2 addeq2))
  (eqtr4 add0 (addeq2 add0))
  (eqtr4g addS (eqtr (addeq2 addS) addS) suceq));

theorem add32: $ (a + b) + c = (a + c) + b $ =
'(eqtr addass (eqtr4 (addeq2 addcom) addass));

theorem add4: $ (a + b) + (c + d) = (a + c) + (b + d) $ =
'(eqtr3 addass @ eqtr (addeq1 add32) addass);

theorem addcan1: $ a + c = b + c <-> a = b $ =
'(! ind x y _ $ a + x = b + x <-> a = b $ _ _ _ _
  (bibi1d (eqeqd addeq2 addeq2)) (bibi1d (eqeqd addeq2 addeq2))
  (bibi1d (eqeqd addeq2 addeq2)) (bibi1d (eqeqd addeq2 addeq2))
  (eqeq add0 add0) (syl5bb (bitr (eqeq addS addS) peano2) id));
theorem addcan2: $ a + b = a + c <-> b = c $ =
'(bitr (eqeq addcom addcom) addcan1);

theorem mul02: $ a * 0 = 0 $ = 'mul0;
theorem mul01: $ 0 * a = 0 $ =
'(! ind x y _ $ 0 * x = 0 $ _ _ _ _
  (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2) (eqeq1d muleq2)
  mul0 (syl5eq (eqtr mulS add0) id));

theorem mulS2: $ a * suc b = a * b + a $ = 'mulS;
theorem mulS1: $ suc a * b = a * b + b $ =
'(! ind x y _ $ suc a * x = a * x + x $ _ _ _ _
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqeqd muleq2 (addeqd muleq2 id)) (eqeqd muleq2 (addeqd muleq2 id))
  (eqtr4 mul0 (eqtr add0 mul0))
  (eqtr4g mulS (eqtr (addeq1 mulS) @
    eqtr addS @ eqtr4 (suceq add32) addS) addeq1));

theorem mulcom: $ a * b = b * a $ =
'(! ind x y _ $ a * x = x * a $ _ _ _ _
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqeqd muleq2 muleq1) (eqeqd muleq2 muleq1)
  (eqtr4 mul0 mul01) (eqtr4g mulS mulS1 addeq1));

theorem mul12: $ a * 1 = a $ = '(eqtr mulS (eqtr (addeq1 mul0) add01));
theorem mul11: $ 1 * a = a $ = '(eqtr mulcom mul12);
theorem mul22: $ a * 2 = a + a $ = '(eqtr mulS2 @ addeq1 mul12);
theorem mul21: $ 2 * a = a + a $ = '(eqtr mulcom mul22);

theorem muladd: $ a * (b + c) = a * b + a * c $ =
'(! ind x y _ $ a * (b + x) = a * b + a * x $ _ _ _ _
  (eqeqd (syl muleq2 addeq2) (syl addeq2 muleq2))
  (eqeqd (syl muleq2 addeq2) (syl addeq2 muleq2))
  (eqeqd (syl muleq2 addeq2) (syl addeq2 muleq2))
  (eqeqd (syl muleq2 addeq2) (syl addeq2 muleq2))
  (eqtr4 (muleq2 add0) (eqtr (addeq2 mul0) add0))
  (eqtr4g (eqtr (muleq2 addS) mulS) (eqtr4 (addeq2 mulS) addass) addeq1));

theorem addmul: $ (a + b) * c = a * c + b * c $ =
'(eqtr mulcom (eqtr muladd (addeq mulcom mulcom)));

theorem mulass: $ (a * b) * c = a * (b * c) $ =
'(! ind x y _ $ (a * b) * x = a * (b * x) $ _ _ _ _
  (eqeqd muleq2 (syl muleq2 muleq2)) (eqeqd muleq2 (syl muleq2 muleq2))
  (eqeqd muleq2 (syl muleq2 muleq2)) (eqeqd muleq2 (syl muleq2 muleq2))
  (eqtr4 mul0 (eqtr (muleq2 mul0) mul0))
  (eqtr4g mulS (eqtr (muleq2 mulS) muladd) addeq1));

theorem mul32: $ (a * b) * c = (a * c) * b $ =
'(eqtr mulass (eqtr4 (muleq2 mulcom) mulass));

def sub (a b: nat): nat = $ the {x | b + x = a} $;
infixl sub: $-$ prec 65;

theorem subeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a - c = b - d $ =
'(theeqd (!! cbvabd x y (eqeqd (addeqd (anwl h2) anr) (anwl h1))));
theorem subeq: $ a = b -> c = d -> a - c = b - d $ = '(exp (subeqd anl anr));
theorem subeq1: $ a = b -> a - c = b - c $ = '(mpi eqid subeq);
theorem subeq2: $ a = b -> c - a = c - b $ = '(subeq eqid);

theorem eqsub2: $ a + b = c -> c - a = b $ =
'(!! eqthed x @ syl5bb (!! elabe y @ eqeq1d addeq2) (syl6bb addcan2 @ bicomd eqeq2));
theorem eqsub1: $ a + b = c -> c - b = a $ = '(sylbi (eqeq1 addcom) eqsub2);
theorem pncan: $ a + b - b = a $ = '(eqsub1 eqid);
theorem pncan2: $ a + b - a = b $ = '(eqsub2 eqid);
theorem sub02: $ a - 0 = a $ = '(eqsub1 add0);
theorem subid: $ a - a = 0 $ = '(eqsub1 add01);

def le (a b .x: nat): wff = $ E. x a + x = b $;
infixl le: $<=$ prec 50;

theorem dfle: $ a <= b <-> E. x a + x = b $ = '(!! cbvex y x (eqeq1d addeq2));

theorem leeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> (a <= c <-> b <= d) $ =
'(!! cbvexd x y (eqeqd (addeqd (anwl h1) anr) (anwl h2)));
theorem leeq: $ a = b -> c = d -> (a <= c <-> b <= d) $ = '(exp (leeqd anl anr));
theorem leeq1: $ a = b -> (a <= c <-> b <= c) $ = '(mpi eqid leeq);
theorem leeq2: $ b = c -> (a <= b <-> a <= c) $ = '(leeq eqid);

theorem leid: $ a <= a $ = '(!! iexe x (eqeq1d addeq2) add0);
theorem eqle: $ a = b -> a <= b $ = '(mpbii leid leeq2);
theorem eqler: $ a = b -> b <= a $ = '(syl eqle eqcom);

theorem pncan3: $ a <= b -> a + (b - a) = b $ =
'(!! eex x @ mpbii (addeq2 pncan2) (eqeqd (syl addeq2 subeq1) id));
theorem npcan: $ b <= a -> a - b + b = a $ = '(syl5eq addcom pncan3);

theorem leaddid2: $ a <= a + b $ = '(!! iexe x (eqeq1d addeq2) eqid);
theorem leaddid1: $ a <= b + a $ = '(mpbi (leeq eqid addcom) leaddid2);

theorem lesucid: $ a <= suc a $ = '(mpbi (leeq2 add12) leaddid2);

theorem le01: $ 0 <= a $ = '(mpbi (leeq2 add0) leaddid1);

theorem leadd1: $ a <= b <-> a + c <= b + c $ =
'(bitr dfle (!! exbii x (bitr3 addcan1 (eqeq1 add32))));
theorem leadd2: $ b <= c <-> a + b <= a + c $ = '(bitr leadd1 (leeq addcom addcom));
theorem lesuc: $ a <= b <-> suc a <= suc b $ = '(bitr leadd1 (leeq add12 add12));

theorem letrd (h1: $ G -> a <= b $) (h2: $ G -> b <= c $): $ G -> a <= c $ =
'(mpd h1 @ !! eexda x @ mpd (anwl h2) @ !! eexda y @ syl
  (!! iexe z @ eqeq1d addeq2) @
  syl5eqr addass @ eqtrd (syl addeq1 anlr) anr);

theorem letr: $ a <= b -> b <= c -> a <= c $ = '(exp (letrd anl anr));

theorem leasymd (h1: $ G -> a <= b $) (h2: $ G -> b <= a $): $ G -> a = b $ =
(focus
  '(mpd h1 (!! eexda x (! casesda _ $ x = 0 $ _ _ _)))
  (focus
    '(syl5eqr add0 (eqtr3d (anwr addeq2) anlr)))
  (focus
    '(imp (syl5bi exsuc (!! eexda y _)))
    '(mpd (anwl (anwl h2)) (!! eexda z _))
    '(sylc absurd (a1i peano1) _)
    '(syl5eqr addS1 @ eqtrd (syl addeq1 anlr) (sylib addcan2 _))
    '(eqtr4g (eqcom addass) add0 (eqtrd (syl addeq1 (anwl anlr)) anr))));

theorem leasym: $ a <= b -> b <= a -> a = b $ = '(exp (leasymd anl anr));
theorem eqlele: $ a = b <-> a <= b /\ b <= a $ =
'(ibii (iand eqle eqler) (imp leasym));

theorem le02: $ a <= 0 <-> a = 0 $ = '(ibii (mpi le01 leasym) eqle);
theorem le11: $ 1 <= a <-> a != 0 $ = '(bitr4 (!! exbii x (eqeq1 add11)) exsuc);

theorem sub1can: $ a != 0 -> suc (a - 1) = a $ = '(sylbir le11 @ syl5eqr add12 npcan);

theorem leaddd (h1: $ G -> a <= b $) (h2: $ G -> c <= d $): $ G -> a + c <= b + d $ =
'(letrd (sylib leadd1 h1) (sylib leadd2 h2));

theorem leadd: $ a <= b -> c <= d -> a + c <= b + d $ = '(exp @ leaddd anl anr);

theorem lemul1a: $ a <= b -> a * c <= b * c $ =
'(! indd _ x y _ $ a * x <= b * x $ _ _ _ _
  (leeqd muleq2 muleq2) (leeqd muleq2 muleq2) (leeqd muleq2 muleq2) (leeqd muleq2 muleq2)
  (a1i (eqle (eqtr4 mul0 mul0))) (sylibr (leeq mulS mulS) (leaddd anr anl)));
theorem lemul2a: $ b <= c -> a * b <= a * c $ = '(sylib (leeq mulcom mulcom) lemul1a);
theorem lemuld (h1: $ G -> a <= b $) (h2: $ G -> c <= d $): $ G -> a * c <= b * d $ =
'(letrd (syl lemul1a h1) (syl lemul2a h2));

def lt (a b: nat): wff = $ suc a <= b $;
infixl lt: $<$ prec 50;

theorem lteqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> (a < c <-> b < d) $ =
'(leeqd (suceqd h1) h2);
theorem lteq: $ a = b -> c = d -> (a < c <-> b < d) $ = '(exp (lteqd anl anr));
theorem lteq1: $ a = b -> (a < c <-> b < c) $ = '(mpi eqid lteq);
theorem lteq2: $ b = c -> (a < b <-> a < c) $ = '(lteq eqid);

theorem ltletr: $ a < b -> b <= c -> a < c $ = 'letr;
theorem ltletrd (h1: $ G -> a < b $) (h2: $ G -> b <= c $): $ G -> a < c $ = '(letrd h1 h2);

theorem ltle: $ a < b -> a <= b $ = '(letrd (a1i lesucid) id);
theorem ltled (h: $ G -> a < b $): $ G -> a <= b $ = '(syl ltle h);

theorem lelttr: $ a <= b -> b < c -> a < c $ = '(sylbi lesuc letr);
theorem lelttrd (h1: $ G -> a <= b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc lelttr h1 h2);

theorem lttr: $ a < b -> b < c -> a < c $ = '(syl lelttr ltle);
theorem lttrd (h1: $ G -> a < b $) (h2: $ G -> b < c $): $ G -> a < c $ = '(sylc lttr h1 h2);

theorem ltsucid: $ a < suc a $ = 'leid;

theorem lt01: $ 0 < a <-> a != 0 $ = 'le11;
theorem lt02: $ ~ a < 0 $ = '(con3 (bi1 le02) peano1);
theorem lt01S: $ 0 < suc a $ = '(mpbir lt01 peano1);

theorem ltadd1: $ a < b <-> a + c < b + c $ = '(bitr leadd1 (leeq1 addS1));
theorem ltadd2: $ b < c <-> a + b < a + c $ = '(bitr ltadd1 (lteq addcom addcom));
theorem ltsuc: $ a < b <-> suc a < suc b $ = '(bitr ltadd1 (lteq add12 add12));
theorem leltsuc: $ a <= b <-> a < suc b $ = 'lesuc;

theorem ltirr: $ ~ a < a $ = '(mtbi (bitr ltadd1 @ lteq add01 add01) lt02);
theorem ltne: $ a < b -> a != b $ = '(mpi ltirr @ con3d @ com12 @ bi1d lteq1);
theorem ltner: $ a < b -> b != a $ = '(syl necom ltne);

theorem d0lt1: $ 0 < 1 $ = 'lt01S;
theorem d0lt2: $ 0 < 2 $ = 'lt01S;
theorem d1lt2: $ 1 < 2 $ = '(mpbi ltsuc d0lt1);
theorem lt12: $ a < 1 <-> a = 0 $ = '(bitr3 leltsuc le02);

theorem nlesubeq0: $ ~b <= a -> a - b = 0 $ =
(focus
  '(syl (!! the0 x y) @ con3 @ eximi @ sylbir abeqb _)
  '(mpbiri eqid @ eale @ bibid (eqeq1d addeq2) eqeq1));

theorem subleid: $ a - b <= a $ =
'(cases (mpbii leaddid2 @ syl leeq2 npcan) (mpbiri le01 @ syl leeq1 nlesubeq0));
theorem subltid: $ 0 < a /\ 0 < b -> a - b < a $ =
'(casesda
  (sylibr ltadd1 @ mpbird (anwr @ syl lteq1 @ syl6eqr add0 npcan) @ sylib ltadd2 anlr)
  (mpbird (anwr @ syl lteq1 nlesubeq0) anll));

theorem leloe: $ a <= b <-> a < b \/ a = b $ =
'(ibii (!! eex x @ casesd
    (exp (orrd (syl5eqr add0 (eqtr3d (anwr addeq2) anl))))
    (syl5bi exsuc @ !! eexda y @ orld @ mpbii leaddid2 @
      syl leeq2 @ syl5eq addSass @ eqtrd (anwr addeq2) anl))
  (eor ltle eqle));

theorem ltlene: $ a < b <-> a <= b /\ a != b $ =
'(ibii (iand ltle ltne) (imp (con1d (bi1 leloe))));
theorem ltlenle: $ a < b <-> a <= b /\ ~b <= a $ =
'(ibii (iand ltle (mtd (a1i ltirr) ltletr))
  (sylibr ltlene @ iand anl @ anwr @ con3 eqler));

theorem ltorle: $ a < b \/ b <= a $ =
'(! ind x y _ $ a < x \/ x <= a $ _ _ _ _
  (orbid lteq2 leeq1) (orbid lteq2 leeq1) (orbid lteq2 leeq1) (orbid lteq2 leeq1)
  (orr le01)
  (eor (orld (mpi ltsucid lttr))
    (syl5 (con3 (bi1 lesuc)) @ exp @ bi2 ltlenle)));
theorem leorlt: $ a <= b \/ b < a $ = '(orcom ltorle);

theorem ltnle: $ a < b <-> ~b <= a $ = '(ibii (sylbi ltlenle anr) leorlt);
theorem lenlt: $ a <= b <-> ~b < a $ = '(con2b ltnle);
theorem ltnlt: $ a < b -> ~b < a $ = '(sylbi ltnle (con3 ltle));
theorem leorle: $ a <= b \/ b <= a $ = '(syl ltle leorlt);

theorem neltlt: $ a != b <-> a < b \/ b < a $ =
'(ibii (mpi ltorle @ imim2d @ rsyl necom @ com12 @ exp @ bi2i ltlene) (eor ltne ltner));

theorem ltsubeq0: $ a < b -> a - b = 0 $ = '(sylbi ltnle nlesubeq0);
theorem lesubeq0: $ a <= b <-> a - b = 0 $ =
'(ibii (sylbi leloe @ eor ltsubeq0 @ syl6eq subid subeq1) @
  syl contra @ exp @ syl eqle @
  eqtr3d (syl npcan @ anwr leorle) (syl6eq add01 @ anwl addeq1));

theorem subpos: $ a < b <-> 0 < b - a $ = '(bitr ltnle @ bitr4 (notbi lesubeq0) lt01);

theorem mulsub: $ a * (b - c) = a * b - a * c $ =
'(eor
  (eqcomd @ syl eqsub1 @ syl5eqr muladd @ syl muleq2 npcan)
  (eqtr4d (syl6eq mul02 @ sylbi lesubeq0 muleq2)
    (sylib lesubeq0 lemul2a)) leorle);
theorem submul: $ (a - b) * c = a * c - b * c $ =
'(eqtr mulcom @ eqtr mulsub @ subeq mulcom mulcom);

theorem ltmul1: $ 0 < c -> (a < b <-> a * c < b * c) $ =
'(ibid
  (com12 @ ! indd _ x y _ $ 0 < x -> a * x < b * x $ _ _ _ _
    (imbid lteq2 (lteqd muleq2 muleq2)) (imbid lteq2 (lteqd muleq2 muleq2))
    (imbid lteq2 (lteqd muleq2 muleq2)) (imbid lteq2 (lteqd muleq2 muleq2))
    (a1i @ absurd lt02)
    (a1d @ anwl @ sylibr (lteq mulS mulS) @
      ltletrd (bi1 ltadd2) @ sylib leadd1 @ syl lemul1a ltle))
  (a1i (mpbir (imbii ltnle ltnle) (con3 lemul1a))));
theorem ltmul2: $ 0 < a -> (b < c <-> a * b < a * c) $ =
'(syl6bb (lteq mulcom mulcom) ltmul1);
theorem lemul1: $ 0 < c -> (a <= b <-> a * c <= b * c) $ =
'(sylibr (bibi lenlt lenlt) (notbid ltmul1));
theorem lemul2: $ 0 < a -> (b <= c <-> a * b <= a * c) $ =
'(syl6bb (leeq mulcom mulcom) lemul1);

theorem mulcan1: $ c != 0 -> (a * c = b * c <-> a = b) $ =
'(ibid (sylbir lt01 @ exp (leasymd
    (mpbird (anwl lemul1) (anwr eqle))
    (mpbird (anwl lemul1) (anwr eqler))))
  (a1i muleq1));
theorem mulcan2: $ a != 0 -> (a * b = a * c <-> b = c) $ =
'(syl5bb (eqeq mulcom mulcom) mulcan1);

theorem mulpos: $ 0 < a * b <-> 0 < a /\ 0 < b $ =
'(ibii (iand
    (sylbi lt01 @ sylibr lt01 @ con3 @ syl6eq mul01 muleq1)
    (sylbi lt01 @ sylibr lt01 @ con3 @ syl6eq mul02 muleq2))
  (sylib (lteq1 mul0) @ mpbid (anwl ltmul2) anr));

theorem mulne0: $ a * b != 0 <-> a != 0 /\ b != 0 $ =
'(bitr3 lt01 @ bitr mulpos @ anbi lt01 lt01);

theorem sub01: $ 0 - a = 0 $ =
'(cases (sylbi le02 @ syl6eq sub02 subeq2) nlesubeq0);

theorem pnpcan2: $ (a + c) - (b + c) = a - b $ =
'(cases
  (syl eqsub1 @ syl5eqr addass @ syl addeq1 npcan)
  (eqtr4d (sylbi (notbi leadd1) nlesubeq0) nlesubeq0));

theorem pnpcan: $ (a + b) - (a + c) = b - c $ = '(eqtr (subeq addcom addcom) pnpcan2);
theorem subSS: $ suc a - suc b = a - b $ = '(eqtr3 (subeq add12 add12) pnpcan2);

theorem indlt {x y} (a) (px: wff x) (p0 pa: wff) (py ps: wff y)
  (h0: $ x = 0 -> (px <-> p0) $)
  (hy: $ x = y -> (px <-> py) $)
  (hs: $ x = suc y -> (px <-> ps) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h1: $ G -> p0 $) (h2: $ G /\ y < a /\ py -> ps $): $ G -> pa $ =
'(mpi leid @ indd
  (imbid leeq1 h0) (imbid leeq1 hy) (imbid leeq1 hs) (imbid leeq1 ha)
  (a1d h1) (imp @ syl5 (imim1i ltle) @ a2d @ exp @ exp h2));

theorem indstr {x y} (a) (px: wff x) (pa: wff) (py: wff y)
  (hy: $ x = y -> (px <-> py) $)
  (ha: $ x = a -> (px <-> pa) $)
  (h: $ G /\ A. x (x < y -> px) -> py $): $ G -> pa $ =
'(syl (mpi ltsucid @ eale @ imbid lteq1 ha) @
  ! indd _ z y _ $ A. x (x < z -> px) $ _ _ _ _
  (albid @ imbi1d lteq2) (albid @ imbi1d lteq2)
  (albid @ imbi1d lteq2) (albid @ imbi1d lteq2)
  (a1i @ ax_gen @ absurd lt02)
  (mpd (rsyl h @ iald @ com12 @ bi2d hy) @
    anwr @ al2imi @ syl6 (imim1i @ bi1i @ bitr3 leltsuc leloe) eor));

def finite (A: set): wff = $ E. n A. x (x e. A -> x < n) $;

theorem fineq: $ A == B -> (finite A <-> finite B) $ =
'(!! cbvexd n1 n2 @ !! cbvald x1 x2 @ imbid (eleqd anr anll) (lteqd anr anlr));

theorem finss: $ A C_ B -> finite B -> finite A $ =
'(!! eximd n @ !! alimd x @ imim1d ssel);

theorem finlt: $ finite {x | x < n} $ =
'(!! iexe m (albid @ imbi2d @ lteq2) @ !! ax_gen y @ bi1i @ elabe lteq1);

theorem finle: $ finite {x | x <= n} $ =
'(!! iexe m (albid @ imbi2d @ lteq2) @ !! ax_gen y @ sylbi (elabe leeq1) @ bi1i leltsuc);

theorem finsn: $ finite {x | x = n} $ =
'(finss (mpbi ssab @ ax_gen eqle) finle);

abstract def if (p: wff) (a b: nat): nat = $ the {n | ifp p (n = a) (n = b)} $;

theorem ifeqd (h1: $ G -> (p <-> q) $) (h2: $ G -> a = c $) (h3: $ G -> b = d $):
  $ G -> if p a b = if q c d $ =
'(theeqd @ !! cbvabd x y @
  ifpbid (anwl h1) (eqeqd anr @ anwl h2) (eqeqd anr @ anwl h3));
theorem ifeq1d (h: $ G -> (p <-> q) $): $ G -> if p a b = if q a b $ = '(ifeqd h eqidd eqidd);
theorem ifeq2d (h: $ G -> a = b $): $ G -> if p a c = if p b c $ = '(ifeqd biidd h eqidd);
theorem ifeq3d (h: $ G -> b = c $): $ G -> if p a b = if p a c $ = '(ifeqd biidd eqidd h);

pub theorem ifpos (p: wff) (a b: nat): $ p -> if p a b = a $ = '(!! eqtheabd n ifppos);
pub theorem ifneg (p: wff) (a b: nat): $ ~p -> if p a b = b $ = '(!! eqtheabd n ifpneg);

theorem ifid: $ if p a a = a $ = '(cases ifpos ifneg);

def true (n: nat): wff = $ n != 0 $;
def bool (n: nat): wff = $ n < 2 $;
def nat (p: wff): nat = $ if p 1 0 $;

theorem trueeq: $ a = b -> (true a <-> true b) $ = 'neeq1;
theorem booleq: $ a = b -> (bool a <-> bool b) $ = 'lteq1;
theorem nateq: $ (p <-> q) -> nat p = nat q $ = '(ifeqd id eqidd eqidd);

theorem true1: $ true 1 $ = 'd1ne0;
theorem true0: $ ~ true 0 $ = '(notnot1 eqid);

theorem bool0: $ bool 0 $ = 'd0lt2;
theorem bool1: $ bool 1 $ = 'd1lt2;
theorem bool01: $ bool n <-> n = 0 \/ n = 1 $ =
'(bitr3 leltsuc (bitr leloe (orbi1i lt12)));

theorem dftrue2: $ bool n -> (true n <-> n = 1) $ =
'(ibid (bi1 bool01) (a1i @ mpbiri d1ne0 neeq1));

theorem truenat: $ true (nat p) <-> p $ =
'(ibii (con1 ifneg) (mpbiri d1ne0 (syl neeq1 ifpos)));
theorem nattrue: $ bool n -> nat (true n) = n $ =
'(sylbi bool01 @ eor
  (eqtr4d (syl nateq trueeq) @ syl6eqr (ifneg true0) id)
  (eqtr4d (syl nateq trueeq) @ syl6eqr (ifpos true1) id));

theorem boolext: $ bool a -> bool b -> ((true a <-> true b) <-> a = b) $ =
'(exp @ ibid
  (exp @ mpbid (eqeqd (syl nattrue anll) (syl nattrue anlr)) @ anwr nateq)
  (a1i trueeq));

def min (a b: nat): nat = $ if (a < b) a b $;
def max (a b: nat): nat = $ if (a < b) b a $;

theorem mineqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> min a c = min b d $ = '(ifeqd (lteqd h1 h2) h1 h2);
theorem maxeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> max a c = max b d $ = '(ifeqd (lteqd h1 h2) h2 h1);
theorem nfmax {x} (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x max a b $ =
'(!! nfnlem2 _ u v (maxeqd anl anr) h1 h2);

theorem mineq1: $ a <= b -> min a b = a $ =
'(sylbi leloe @ eor ifpos @ syl6eq ifid (ifeq3d eqcom));
theorem maxeq2: $ a <= b -> max a b = b $ =
'(sylbi leloe @ eor ifpos @ syl6eq ifid (ifeq3d id));

theorem mincom: $ min a b = min b a $ =
'(cases (eqtr4d ifpos @ syl ifneg ltnlt) (eqtr4d ifneg @ sylbir lenlt mineq1));
theorem maxcom: $ max a b = max b a $ =
'(cases (eqtr4d ifpos @ syl ifneg ltnlt) (eqtr4d ifneg @ sylbir lenlt maxeq2));

theorem mineq2: $ b <= a -> min a b = b $ = '(syl5eq mincom mineq1);
theorem maxeq1: $ b <= a -> max a b = a $ = '(syl5eq maxcom maxeq2);

theorem minle1: $ min a b <= a $ =
'(cases (syl eqle ifpos) (mpbird (syl leeq1 ifneg) (bi2 lenlt)));
theorem minle2: $ min a b <= b $ = '(mpbi (leeq1 mincom) minle1);
theorem lemin: $ a <= min b c <-> a <= b /\ a <= c $ =
'(ibii (iand (mpi minle1 letr) (mpi minle2 letr)) @ casesda
  (mpbird (anwr @ syl leeq2 ifpos) anll)
  (mpbird (anwr @ syl leeq2 ifneg) anlr));

theorem subaddmin: $ (a - b) + min a b = a $ =
'(eor (eqtrd (syl addeq2 mineq2) npcan)
  (eqtrd (sylbi lesubeq0 addeq1) @ syl5eq add01 @ mineq1) leorle);
theorem minaddsub: $ min a b + (a - b) = a $ = '(eqtr addcom subaddmin);

theorem submin: $ a - min a b = a - b $ =
'(eor (eqtr4d (syl subeq2 mineq1) @ syl6eqr subid @ bi1 lesubeq0)
  (syl subeq2 mineq2) leorle);

theorem lemax1: $ a <= max a b $ =
'(cases (mpbird (syl leeq2 ifpos) ltle) (syl eqler ifneg));
theorem lemax2: $ b <= max a b $ = '(mpbi (leeq2 maxcom) lemax1);
theorem maxle: $ max a b <= c <-> a <= c /\ b <= c $ =
'(ibii (iand (letr lemax1) (letr lemax2)) @ casesda
  (mpbird (anwr @ syl leeq1 ifpos) anlr)
  (mpbird (anwr @ syl leeq1 ifneg) anll));

theorem ltmax: $ a < max b c <-> a < b \/ a < c $ =
'(con4b @ bitr3 lenlt @ bitr maxle @ bitr4 (anbi lenlt lenlt) notor);

theorem maxadd1: $ max a b + c = max (a + c) (b + c) $ =
'(cases (eqtr4d (syl addeq1 ifpos) (sylbi ltadd1 ifpos))
  (eqtr4d (syl addeq1 ifneg) (sylbi (notbi ltadd1) ifneg)));

theorem maxS: $ suc (max a b) = max (suc a) (suc b) $ =
'(eqtr3 add12 @ eqtr maxadd1 @ trud @ maxeqd (a1i add12) (a1i add12));

theorem maxlt: $ max a b < c <-> a < c /\ b < c $ = '(bitr (leeq1 maxS) maxle);
theorem lemax: $ a <= max b c <-> a <= b \/ a <= c $ =
'(con4b @ bitr3 ltnle @ bitr maxlt @ bitr4 (anbi ltnle ltnle) notor);

abstract def div (a b: nat): nat = $ the {q | E. r (r < b /\ b * q + r = a)} $;
infixl div: $//$ prec 70;
abstract def mod (a b: nat): nat = $ a - b * (a // b) $;
infixl mod: $%$ prec 70;

theorem diveqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a // c = b // d $ =
'(theeqd @ !! cbvabd q1 q2 @ !! cbvexd r1 r2 @
  anbid (leeqd (suceqd anr) (anwll h2)) @
  eqeqd (addeqd (muleqd (anwll h2) anlr) anr) @ anwll h1);
theorem modeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a % c = b % d $ =
'(subeqd h1 @ muleqd h2 @ diveqd h1 h2);
theorem diveq1: $ a = b -> a // c = b // c $ = '(diveqd id eqidd);
theorem diveq2: $ b = c -> a // b = a // c $ = '(diveqd eqidd id);
theorem modeq1: $ a = b -> a % c = b % c $ = '(modeqd id eqidd);
theorem modeq2: $ b = c -> a % b = a % c $ = '(modeqd eqidd id);

pub theorem div0 (a: nat): $ a // 0 = 0 $ =
'(trud @ !! eqthe0abd q @ a1i @ !! eex r @ anwl @ absurd lt02);
theorem mod0: $ a % 0 = a $ = '(eqtr (subeq2 mul01) sub02);

theorem divlem1
  (h1: $ G -> r1 < b $) (h2: $ G -> r2 < b $)
  (h3: $ G -> b * q1 + r1 <= b * q2 + r2 $):
  $ G -> q1 <= q2 $ =
(focus
  (have 'b0 $ G -> 0 < b $ '(lelttrd (a1i le01) h1))
  '(sylibr leltsuc @ mpbird (syl ltmul2 b0) @ lelttrd (a1i leaddid2) _)
  '(lelttrd h3 @ sylibr (lteq2 mulS) @ sylib ltadd2 h2));

theorem divlem2 (h1: $ G -> R < b $) (h2: $ G -> b * Q + R = a $):
  $ G -> (E. r (r < b /\ b * q + r = a) <-> q = Q) $ =
(focus
  (have 'b0 $ G -> b != 0 $ '(syl ltner @ lelttrd (a1i le01) h1))
  '(ibid (eexda @ leasymd
      (divlem1 anrl (anwl h1) @ syl eqle @ eqtr4d anrr (anwl h2))
      (divlem1 (anwl h1) anrl @ syl eqle @ eqtr4d (anwl h2) anrr))
    (exp @ syl
      (iexe @ anbid lteq1 @ eqeq1d addeq2)
      (iand (anwl h1) @ eqtrd (anwr @ syl addeq1 muleq2) (anwl h2)))));

theorem divlem3: $ b != 0 -> E. q E. r (r < b /\ b * q + r = a) $ =
'(! indd _ x y _ $ E. q E. r (r < b /\ b * q + r = x) $ _ _ _ _
  (exbid @ exbid @ anbi2d eqeq2) (exbid @ exbid @ anbi2d eqeq2)
  (exbid @ exbid @ anbi2d eqeq2) (exbid @ exbid @ anbi2d eqeq2)
  (iexde @ iexde @ iand
    (mpbird (anwr lteq1) @ sylibr lt01 anll)
    (syl6eq add0 @ addeqd (syl6eq mul02 @ anwl @ anwr muleq2) anr))
  (imp @ syl5bi (!! cbvex _ u @ !! cbvexd _ v
    (anbid (anwr lteq1) @ eqeq1d @ addeqd (anwl muleq2) anr))
    (eexd @ eexda @ mpd (sylib leloe anrl) @ eorda
      (iexde @ iexde @ iand
        (mpbird (anwr lteq1) (anwll anr))
        (eqtrd (anwr addeq2) @ syl5eq addS @ suceqd @
          eqtrd (syl addeq1 @ syl muleq2 anlr) (anw3l anrr)))
      (iexde @ iexde @ iand
        (mpbird (anwr lteq1) (sylibr lt01 (anw3l anl)))
        (eqtrd (addeqd (syl muleq2 anlr) anr) @
          syl5eq add0 @ syl5eq mulS @ eqtr3d (syl addeq2 @ anwll anr) @
            syl5eq addS @ suceqd @ anw3l anrr)))));

theorem eqdivmod (h1: $ G -> R < b $) (h2: $ G -> b * Q + R = a $):
  $ G -> a // b = Q /\ a % b = R $ =
(focus
  (have 'eq $ G -> a // b = Q $
    '(!! eqtheabd q @ !! divlem2 r h1 h2))
  '(iand eq (syl eqsub2 @ eqtrd (syl addeq1 @ syl muleq2 eq) h2)));

pub theorem divmod (a b: nat): $ b * (a // b) + a % b = a $ =
(focus
  '(pncan3 @ cases _ _)
  (focus
    '(mpbiri le01 @ syl leeq1 @ syl6eq mul0 @ syl muleq2 @ syl6eq div0 diveq2))
  (focus
    '(mpd (!! divlem3 q r) @ eexd @ eexda @ mpbii leaddid2 _)
    '(syl leeq2 @ eqtrd (syl addeq1 @ syl muleq2 _) anrr)
    '(!! eqtheabd q @ !! divlem2 r anrl anrr)));

pub theorem modlt (a b: nat): $ b != 0 -> a % b < b $ =
'(mpd (!! divlem3 q r) @ eexd @ eexda @
  mpbird (syl lteq1 @ anrd @ eqdivmod anrl anrr) anrl);

theorem modle1: $ a % b <= a $ = '(mpbi (leeq2 divmod) leaddid1);

theorem div01: $ 0 // a = 0 $ =
'(cases (syl6eq div0 diveq2) @ anld @
  eqdivmod (bi2 lt01) (a1i @ eqtr add0 mul0));
theorem mod01: $ 0 % a = 0 $ =
'(cases (syl6eq mod0 modeq2) @ anrd @
  eqdivmod (bi2 lt01) (a1i @ eqtr add0 mul0));

theorem mod12: $ a % 1 = 0 $ = '(mpbi lt12 @ modlt d1ne0);
theorem div12: $ a // 1 = a $ =
'(eqtr3 (eqtr (addeq mul11 mod12) add02) divmod);

theorem muldiv2: $ b != 0 -> b * a // b = a $ =
'(anld @ eqdivmod (bi2 lt01) (a1i add0));
theorem muldiv1: $ b != 0 -> a * b // b = a $ =
'(eqtrd (diveqd (a1i mulcom) eqidd) muldiv2);
theorem mulmod1: $ b * a % b = 0 $ =
'(cases
  (eqtrd modeq2 @ syl5eq mod0 @ syl6eq mul01 muleq1)
  (anrd @ eqdivmod (bi2 lt01) (a1i add0)));
theorem mulmod2: $ a * b % b = 0 $ =
'(eqtr (modeqd id eqidd mulcom) mulmod1);

theorem lediv1: $ a <= b -> a // c <= b // c $ =
'(casesda (mpbiri le01 @ syl leeq1 @ syl6eq div0 (anwr diveq2))
  (divlem1 (anwr modlt) (anwr modlt) @ sylibr (leeq divmod divmod) anl));

theorem muldivle: $ b * (a // b) <= a $ = '(mpbi (leeq2 divmod) leaddid2);

theorem ledivmul1: $ c != 0 -> (a <= b // c <-> c * a <= b) $ =
'(ibida (letrd (anwr lemul2a) (a1i muldivle))
  (sylibr leltsuc @
    mpbird (syl ltmul2 @ sylibr lt01 anl) @ lelttrd anr @ anwl @
    sylibr (lteq2 mulS) @ sylib (lteq1 divmod) @ sylib ltadd2 @ modlt));
theorem ledivmul2: $ c != 0 -> (a <= b // c <-> a * c <= b) $ =
'(syl6bb (leeq1 mulcom) ledivmul1);
theorem ltdivmul1: $ b != 0 -> (a // b < c <-> a < b * c) $ =
'(syl5bb ltnle @ syl6bbr ltnle @ notbid @ledivmul1);
theorem ltdivmul2: $ b != 0 -> (a // b < c <-> a < c * b) $ =
'(syl6bb (lteq2 mulcom) ltdivmul1);

theorem diveq0: $ b != 0 -> (a // b = 0 <-> a < b) $ =
'(syl5bbr lt12 @ syl6bb (lteq2 mul12) ltdivmul1);

theorem divdiv: $ a // b // c = a // (b * c) $ =
'(cases (eqtr4d (syl6eq div01 @ syl diveq1 @ syl6eq div0 diveq2)
    (syl6eq div0 @ syl diveq2 @ syl6eq mul01 muleq1)) @
  casesda (anwr @ eqtr4d (syl6eq div0 diveq2)
    (syl6eq div0 @ syl diveq2 @ syl6eq mul02 muleq2)) @
  leasymd
    (mpbird (sylbir mulne0 ledivmul1) @ a1i @
      mpbir (leeq1 mulass) @ letr (lemul2a muldivle) muldivle)
    (mpbird (anwr ledivmul1) @ mpbird (anwl ledivmul1) @ a1i @
      mpbi (leeq1 mulass) muldivle));

theorem divmod1: $ a // b % c = a % (b * c) // b $ =
'(cases (eqtr4d (syl6eq mod01 @ syl modeq1 @ syl6eq div0 diveq2) @ syl6eq div0 diveq2) @
  casesda (anwr @ eqtr4d (syl6eq mod0 modeq2) @
    syl diveq1 @ syl6eq mod0 @ syl modeq2 @ syl6eq mul02 muleq2) @
  anrd @ eqdivmod (mpbird (anwl ltdivmul1) @ sylbir mulne0 modlt) @
  eqcomd @ anld @ eqdivmod (anwl modlt) @ a1i @
  eqtr (addeq1 muladd) @ eqtr addass @ eqtr (addeq2 divmod) @
  eqtr3 (addeq1 mulass) divmod);

theorem divmod2: $ a // b % c = a % (c * b) // b $ =
'(eqtr divmod1 @ diveq1 @ modeq2 mulcom);

def dvd (a b: nat): wff = $ E. c c * a = b $;
infixl dvd: $||$ prec 50;

theorem dvdeqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a || c <-> b || d) $ =
'(!! cbvexd x y @ eqeqd (muleqd anr @ anwl h1) (anwl h2));
theorem dvdeq1: $ a = b -> (a || c <-> b || c) $ = '(dvdeqd id eqidd);
theorem dvdeq2: $ b = c -> (a || b <-> a || c) $ = '(dvdeqd eqidd id);

theorem idvd: $ c * a = b -> a || b $ = '(!! iexe x @ eqeq1d muleq1);
theorem idvd2: $ a * c = b -> a || b $ = '(sylbi (eqeq1 mulcom) idvd);

theorem divmul: $ b || a -> a // b * b = a $ =
(focus
  '(!! eex x @ eqtr3d (syl muleq1 diveq1) @ syl5eq _ id)
  '(cases (eqtr4d (syl6eq mul0 muleq2) (syl6eq mul0 muleq2)) (syl muleq1 muldiv1)));
theorem muldiv3: $ b || a -> b * (a // b) = a $ = '(syl5eq mulcom divmul);

theorem dvdadd1: $ n || a -> (n || b <-> n || a + b) $ =
(focus
  '(!! eex x @ ibid _ _)
  (focus
    '(!! eexda y @ syl idvd @ syl5eq addmul @ imp addeq))
  (focus
    '(!! eexda z @ syl idvd @ sylib addcan2 _)
    '(eqtr3d (anwl addeq1) @ syl5eqr addmul @ eqtrd _ anr)
    '(casesda (anwr @ eqtr4d (syl6eq mul0 muleq2) (syl6eq mul0 muleq2)) _)
    '(syl muleq1 @ syl pncan3 _)
    '(mpbiri leaddid2 @ bitrd (anwr @ sylbir lt01 @ lemul1) @ leeqd anll anlr)));

theorem dvdadd2: $ n || a -> (n || b <-> n || b + a) $ =
'(syl6bb (dvdeqd eqidd id addcom) dvdadd1);

theorem dvdmul1: $ a || b * a $ = '(idvd eqid);
theorem dvdmul2: $ a || a * b $ = '(mpbi (dvdeq2 mulcom) dvdmul1);

theorem dvdtr: $ a || b -> b || c -> a || c $ =
'(!! eex x @ !! eexda y @ syl idvd @ eqtrd (anwl @ syl5eq mulass muleq2) anr);

theorem dvdmul12: $ a || b -> a || c * b $ = '(mpi dvdmul1 dvdtr);
theorem dvdmul11: $ a || b -> a || b * c $ = '(mpi dvdmul2 dvdtr);

theorem modeq0: $ a % n = 0 <-> n || a $ =
'(ibii
  (!! iexde x @ eqtrd (anwr muleq1) @ syl5eq mulcom @
    syl5eqr add0 @ eqtr3d (anwl addeq2) @ a1i divmod)
  (eex @ syl6eq mulmod2 @ modeqd eqcom eqidd));

theorem dvd02: $ a || 0 $ = '(idvd mul01);
theorem dvd01: $ 0 || a <-> a = 0 $ =
'(ibii (!! eex x @ eqcomd @ bi1 @ eqeq1 mul02) (mpbiri dvd02 dvdeq2));

theorem dvdid: $ a || a $ = '(idvd mul11);

theorem dvdle (h1: $ G -> b != 0 $) (h2: $ G -> a || b $): $ G -> a <= b $ =
'(mpd h2 @ !! eexda x @ mpbid (leeqd (a1i mul11) anr) @
  syl lemul1a @ sylibr lt01 @ mtand (anwl h1) @
  eqtr3d anlr @ syl6eq mul01 (anwr muleq1));

theorem dvdasymd (h1: $ G -> a || b $) (h2: $ G -> b || a $): $ G -> a = b $ =
'(casesda (eqtr4d anr (sylib dvd01 @ mpbid (anwr dvdeq1) (anwl h1))) @
  casesda (eqtr4d (sylib dvd01 @ mpbid (anwr dvdeq1) (anwll h2)) anr) @
  leasymd (dvdle anr @ anwll h1) (dvdle anlr @ anwll h2));

theorem dvd11: $ 1 || a $ = '(idvd mul12);
theorem dvd12: $ a || 1 <-> a = 1 $ =
'(ibii (leasymd (dvdle (a1i d1ne0) id) @
    sylibr le11 @ mtani d1ne0 @ sylib dvd01 @ mpbid (anwr dvdeq1) anl)
  (mpbiri dvdid dvdeq1));

theorem d2dvd1: $ ~2 || 1 $ = '(mt (dvdle (a1i d1ne0) id) @ mpbi ltnle d1lt2);

theorem d2dvdS: $ 2 || suc n <-> ~2 || n $ =
'(ibii
  (mtd (a1i d2dvd1) @ exp @ mpbird (syl6bb (dvdeq2 add12) (anwr dvdadd1)) anl)
  (! ind x y _ $ 2 || x \/ 2 || suc x $ _ _ _ _
  (orbid dvdeq2 @ syl dvdeq2 suceq)
  (orbid dvdeq2 @ syl dvdeq2 suceq)
  (orbid dvdeq2 @ syl dvdeq2 suceq)
  (orbid dvdeq2 @ syl dvdeq2 suceq)
  (orl dvd02)
  (eor (orrd @ sylib (dvdeq2 @ eqtr addS @ suceq add12) @ mpbii dvdid dvdadd1) orl)));

theorem modlteq: $ a < n -> a % n = a $ =
'(anrd @ eqdivmod id @ a1i @ eqtr (addeq1 mul0) add01);

theorem modmodid: $ a % n % n = a % n $ =
'(cases (modeqd (syl6eq mod0 modeq2) eqidd) (syl modlteq modlt));

theorem dvdsubmod: $ n || a - a % n $ = '(idvd2 @ eqcom @ eqsub1 @ divmod);

theorem boolmod2: $ bool (n % 2) $ = '(modlt d2ne0);

local def eqm (n a b) = $ a % n = b % n $;
notation eqm (n a b) = ($mod($:50) n ($):$:50) a ($=$:50) b;

theorem eqmid: $ mod(n): a = a $ = 'eqid;
theorem eqmtr: $ mod(n): a = b -> mod(n): b = c -> mod(n): a = c $ = 'eqtr;
theorem eqmcom: $ mod(n): a = b -> mod(n): b = a $ = 'eqcom;
theorem eqmcomb: $ mod(n): a = b <-> mod(n): b = a $ = '(ibii eqmcom eqmcom);

theorem eqmeqd (h1: $ G -> m = n $) (h2: $ G -> a = b $) (h3: $ G -> c = d $):
  $ G -> (mod(m): a = c <-> mod(n): b = d) $ = '(eqeqd (modeqd h2 h1) (modeqd h3 h1));
theorem eqmeq23d (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (mod(n): a = c <-> mod(n): b = d) $ = '(eqmeqd eqidd h1 h2);
theorem eqmeq1: $ m = n -> (mod(m): a = b <-> mod(n): a = b) $ = '(eqmeqd id eqidd eqidd);
theorem eqmeq2: $ a = b -> (mod(n): a = c <-> mod(n): b = c) $ = '(eqmeq23d id eqidd);
theorem eqmeq3: $ b = c -> (mod(n): a = b <-> mod(n): a = c) $ = '(eqmeq23d eqidd id);

theorem eqeqm: $ a = b -> mod(n): a = b $ = '(mpbii eqmid eqmeq3);

theorem eqmmod: $ mod(n): a % n = a $ = 'modmodid;

theorem eqm03: $ mod(n): a = 0 <-> n || a $ = '(bitr (eqeq2 mod01) modeq0);

theorem eqmdvdsub: $ a <= b -> (mod(n): a = b <-> n || b - a) $ =
(focus
  (have 'h $ a <= b -> b - a % n = b - a + (a - a % n) $
    '(syl eqsub1 @ syl5eq addass @ syl5eq (addeq2 @ npcan modle1) npcan))
  '(ibida
    (sylibr (dvdadd2 dvdsubmod) @
      mpbiri dvdsubmod @ dvdeqd eqidd @ eqtr3d (anwl h) (anwr subeq2))
    (casesda _ _))
  (focus
    '(syl modeq1 @ eqtr3d
      (syl6eq add01 @ syl addeq1 @ sylib dvd01 @ mpbid (anwr dvdeq1) anlr)
      (anwll npcan)))
  (focus
    '(eqcomd @ anrd @ eqdivmod (anwr modlt) @ eqtrd
      (syl addeq1 @ syl5eq muladd @ eqtr4d _ @ anwll h)
      (syl npcan @ letrd (a1i modle1) anll))
    '(addeqd (syl muldiv3 anlr) @ a1i @ eqcom @ eqsub1 divmod)));

theorem eqmaddlem (h1: $ G -> a <= b $) (h2: $ G -> mod(n): a = b $):
  $ G -> mod(n): a + c = b + c $ =
'(mpbird (rsyl h1 @ sylbi leadd1 eqmdvdsub)
  (sylibr (dvdeq2 pnpcan2) @ mpbid (syl eqmdvdsub h1) h2));

theorem eqmadd1d (h: $ G -> mod(n): a = b $): $ G -> mod(n): a + c = b + c $ =
'(eor (exp @ eqmaddlem anl @ anwr h)
  (exp @ syl eqmcom @ eqmaddlem anl @ anwr @ syl eqmcom h) leorle);
theorem eqmadd2d (h: $ G -> mod(n): b = c $): $ G -> mod(n): a + b = a + c $ =
'(mpbid (eqmeq23d (a1i addcom) (a1i addcom)) (eqmadd1d h));

theorem eqmaddd (h1: $ G -> mod(n): a = b $) (h2: $ G -> mod(n): c = d $):
  $ G -> mod(n): a + c = b + d $ =
'(sylc eqmtr (eqmadd1d h1) (eqmadd2d h2));

theorem dvdeqm (h1: $ G -> m || n $)
  (h2: $ G -> mod(n): a = b $): $ G -> mod(m): a = b $ =
'(mpi leorle @ eorda
  (mpbird (anwr eqmdvdsub) @ sylc dvdtr (anwl h1) @ mpbid (anwr eqmdvdsub) (anwl h2))
  (syl eqmcom @
    mpbird (anwr eqmdvdsub) @ sylc dvdtr (anwl h1) @
    mpbid (anwr eqmdvdsub) (anwl @ syl eqmcom h2)));

theorem modmod: $ m || n -> a % n % m = a % m $ = '(dvdeqm id @ a1i eqmmod);

theorem eqm11: $ mod(1): a = b $ = '(eqtr4 mod12 mod12);
theorem eqm01: $ mod(0): a = b <-> a = b $ = '(eqeq mod0 mod0);

def b0 (n: nat): nat = $ n + n $;
def b1 (n: nat): nat = $ suc (b0 n) $;
def odd (n: nat): wff = $ n % 2 = 1 $;

theorem b0eq: $ a = b -> b0 a = b0 b $ = '(addeqd id id);
theorem b1eq: $ a = b -> b1 a = b1 b $ = '(suceqd b0eq);
theorem oddeq: $ a = b -> (odd a <-> odd b) $ = '(eqeq1d modeq1);

theorem b0mul21: $ 2 * n = b0 n $ = 'mul21;
theorem b0mul22: $ n * 2 = b0 n $ = 'mul22;

theorem b1mul21: $ 2 * n + 1 = b1 n $ = '(eqtr (addeq1 b0mul21) add12);

theorem b0dvd2: $ 2 || b0 n $ = '(idvd b0mul22);
theorem b1dvd2: $ ~2 || b1 n $ = '(mpbi (con2b d2dvdS) b0dvd2);

theorem dfodd2: $ odd n <-> true (n % 2) $ = '(bicom @ dftrue2 boolmod2);
theorem odddvd: $ odd n <-> ~ 2 || n $ = '(bitr dfodd2 @ notbi modeq0);

theorem b0odd: $ ~odd (b0 n) $ = '(mpbi (con2b odddvd) b0dvd2);
theorem b1odd: $ odd (b1 n) $ = '(mpbir odddvd b1dvd2);

theorem b0div2: $ b0 n // 2 = n $ = '(eqtr3 (diveq1 b0mul21) (muldiv2 d2ne0));
theorem b1div2: $ b1 n // 2 = n $ =
'(trud @ anld @ eqdivmod (a1i d1lt2) (a1i b1mul21));
theorem b0can: $ b0 a = b0 b <-> a = b $ =
'(ibii (sylib (eqeq b0div2 b0div2) diveq1) b0eq);
theorem b1can: $ b1 a = b1 b <-> a = b $ =
'(ibii (sylib (eqeq b1div2 b1div2) diveq1) b1eq);
theorem b1neb0: $ b1 a != b0 b $ = '(mt (mpbii b1odd oddeq) b0odd);
theorem b0neb1: $ b0 a != b1 b $ = '(necom b1neb0);

theorem b0orb1: $ n = b0 (n // 2) \/ n = b1 (n // 2) $ =
'(rsyl (con3 @ eqcomd @ syl5eqr b0mul21 muldiv3) @
  sylbir odddvd @ syl5eqr divmod @ syl6eq b1mul21 addeq2);

theorem odd0: $ ~ odd 0 $ = '(mtbir (eqeq1 mod01) (mt eqcom d1ne0));
theorem oddS: $ odd (suc n) <-> ~odd n $ =
'(bitr odddvd @ notbi @ bitr4 d2dvdS odddvd);
theorem odd1: $ odd 1 $ = '(mpbir oddS odd0);

def pr (a b: nat): nat = $ (a + b) * suc (a + b) // 2 + b $;
infixr pr: $<>$ prec 54;

theorem preqd (h1: $ G -> a = b $) (h2: $ G -> c = d $): $ G -> a <> c = b <> d $ =
'(addeqd (syl diveq1 @ muleqd (addeqd h1 h2) (suceqd @ addeqd h1 h2)) h2);
theorem preq1: $ a = b -> a <> c = b <> c $ = '(preqd id eqidd);
theorem preq2: $ b = c -> a <> b = a <> c $ = '(preqd eqidd id);
theorem nfpr (a b: nat x) (h1: $ FN/ x a $) (h2: $ FN/ x b $): $ FN/ x a <> b $ =
'(!! nfnlem2 _ y z (preqd anl anr) h1 h2);

theorem prlem1: $ 2 || n * suc n $ = '(cases dvdmul11 @ sylbir d2dvdS dvdmul12);

theorem prlem2: $ a <> c <= b <> d -> a + c <= b + d $ =
(focus
  '(sylibr lenlt @ mtd (sylib ltnle _) (exp @ sylibr (lemul2 d0lt2) _))
  '(lelttrd (letr leaddid2) @ a1i @ mpbi ltadd2 @ mpbi leltsuc leaddid1)
  '(mpbird
    (leeqd
      (syl6eqr addmul @ syl5eq muladd @ syl addeq1 @ a1i @ muldiv3 prlem1)
      (a1i @ eqtr (muldiv3 prlem1) mulcom))
    (lemuld (sylibr (leeq1 addS) @ sylib lesuc @ sylibr (leeq1 add12) anr) anr)));

theorem prth: $ a <> c = b <> d <-> a = b /\ c = d $ =
(focus
  '(ibii _ (preqd anl anr))
  (have 'h $ (a <> c = b <> d) -> a + c = b + d $
    '(leasymd (syl prlem2 eqle) (syl prlem2 eqler)))
  (have 'h2 $ (a <> c = b <> d) -> c = d $
    '(sylib addcan2 @ mpbid (rsyl h @ eqeq1d @
      syl addeq1 @ syl diveq1 @ muleqd id suceq) id))
  '(iand (sylib addcan1 @ eqtr4d h @ sylibr addcan2 h2) h2));

abstract def fst (a: nat): nat = $ the {x | E. y a = x <> y} $;
abstract def snd (a: nat): nat = $ the {y | E. x a = x <> y} $;

pub theorem pr0: $ 0 <> 0 = 0 $ =
'(eqtr (addeq1 @ eqtr (diveq1 @ eqtr (muleq1 add0) mul01) div01) add0);

theorem expr: $ E. x E. y a = x <> y $ =
(focus
  '(! ind u v _ $ E. x E. y u = x <> y $ _ _ _ _
    (exbid @ exbid eqeq1) (exbid @ exbid eqeq1)
    (exbid @ exbid eqeq1) (exbid @ exbid eqeq1)
    (trud @ iexde @ iexde @ syl5eqr pr0 @ eqcomd @ preqd anlr anr)
    (sylib (cbvex @ cbvexd @ eqeq2d @ preqd anl anr) _))
  '(eex @ eex @ casesd _ _)
  (focus
    '(exp @ !! iexde m @ !! iexde n _)
    (have 'h3 $ _ /\ m = suc y /\ n = 0 -> m + n = suc y $
      '(syl6eq add0 (addeqd anlr anr)))
    (have 'h4 $ _ /\ x = 0 /\ m = suc y /\ n = 0 -> x + y = y $
      '(syl6eq add01 @ syl addeq1 @ anwll anr))
    '(eqtrd (suceqd an3l) @ syl5eqr addS @ eqtr4d (sylib (mulcan2 d2ne0) _)
      (syl6eq add0 @ addeqd (syl diveq1 @ muleqd h3 @ suceqd h3) anr))
    '(syl5eq muladd @ syl6eqr (eqtr (muldiv3 prlem1) mulcom) _)
    '(eqtrd
      (syl addeq1 @ syl5eq (muldiv3 prlem1) @ muleqd h4 @ suceqd h4)
      (syl5eqr addmul @ a1i @ muleq1 @ eqtr addS @ suceq add12)))
  (focus
    (have 'h $ _ /\ suc z = x /\ m = z /\ n = suc y -> x + y = m + n $
      '(eqtr4d
        (syl6eq addSass @ eqcomd @ anwll @ anwr addeq1)
        (addeqd anlr anr)))
    '(syl5bi exsuc @ !! eexda z @ !! iexde m @ !! iexde n @
      eqtrd (anw3l suceq) @ syl5eqr addS @ addeqd
      (syl diveq1 @ muleqd h @ suceqd h) (eqcomd anr))));

theorem fsteq: $ a = b -> fst a = fst b $ =
'(theeqd @ !! cbvabd x1 x2 @ !! cbvexd y1 y2 @ eqeqd anll @ preqd anlr anr);
theorem sndeq: $ a = b -> snd a = snd b $ =
'(theeqd @ !! cbvabd y1 y2 @ !! cbvexd x1 x2 @ eqeqd anll @ preqd anr anlr);

pub theorem fstpr (a b: nat): $ fst (a <> b) = a $ =
'(trud @ !! eqtheabd x @ a1i @ ibii
  (!! eex y @ sylbi prth @ eqcomd anl)
  (rsyl (eqcomd preq1) @ iexe @ eqeq2d preq2));
pub theorem sndpr (a b: nat): $ snd (a <> b) = b $ =
'(trud @ !! eqtheabd y @ a1i @ ibii
  (!! eex x @ sylbi prth @ eqcomd anr)
  (rsyl (eqcomd preq2) @ iexe @ eqeq2d preq1));
pub theorem fstsnd (a: nat): $ fst a <> snd a = a $ =
'(!! eex x (!! eex y @ eqtr4d (preqd (syl6eq fstpr fsteq) (syl6eq sndpr sndeq)) id) expr);

theorem fst0: $ fst 0 = 0 $ = '(eqtr3 (fsteq pr0) fstpr);
theorem snd0: $ snd 0 = 0 $ = '(eqtr3 (sndeq pr0) sndpr);

def pi11 (n: nat): nat = $ fst (fst n) $;
def pi12 (n: nat): nat = $ snd (fst n) $;
def pi21 (n: nat): nat = $ fst (snd n) $;
def pi22 (n: nat): nat = $ snd (snd n) $;
def pi221 (n: nat): nat = $ fst (pi22 n) $;
def pi222 (n: nat): nat = $ snd (pi22 n) $;

theorem pi11eq: $ a = b -> pi11 a = pi11 b $ = '(syl fsteq fsteq);
theorem pi12eq: $ a = b -> pi12 a = pi12 b $ = '(syl sndeq fsteq);
theorem pi21eq: $ a = b -> pi21 a = pi21 b $ = '(syl fsteq sndeq);
theorem pi22eq: $ a = b -> pi22 a = pi22 b $ = '(syl sndeq sndeq);
theorem pi221eq: $ a = b -> pi221 a = pi221 b $ = '(syl fsteq pi22eq);
theorem pi222eq: $ a = b -> pi222 a = pi222 b $ = '(syl sndeq pi22eq);

theorem pi11pr: $ pi11 ((a <> b) <> c) = a $ = '(eqtr (fsteq fstpr) fstpr);
theorem pi12pr: $ pi12 ((a <> b) <> c) = b $ = '(eqtr (sndeq fstpr) sndpr);
theorem pi21pr: $ pi21 (a <> b <> c) = b $ = '(eqtr (fsteq sndpr) fstpr);
theorem pi22pr: $ pi22 (a <> b <> c) = c $ = '(eqtr (sndeq sndpr) sndpr);
theorem pi221pr: $ pi221 (a <> b <> c <> d) = c $ = '(eqtr (fsteq pi22pr) fstpr);
theorem pi222pr: $ pi222 (a <> b <> c <> d) = d $ = '(eqtr (sndeq pi22pr) sndpr);

def isfun (A: set): wff =
$ A. a A. b A. b2 (a <> b e. A -> a <> b2 e. A -> b = b2) $;

theorem isfund (h1: $ G -> isfun F $)
  (h2: $ G -> a <> b e. F $) (h3: $ G -> a <> b2 e. F $):
  $ G -> b = b2 $ =
'(mpd h3 @ mpd h2 @ mpd h1 @ !! ealde x @ !! ealde y @ !! ealde z @ bi1d @
  imbid (eleq1d @ preqd anllr anlr) @
  imbid (eleq1d @ preqd anllr anr) @ eqeqd anlr anr);

theorem isfunbd (h1: $ G -> isfun F $) (h2: $ G -> a <> b e. F $):
  $ G -> (a <> b2 e. F <-> b = b2) $ =
'(ibida (isfund (anwl h1) (anwl h2) anr) @ mpbid (eleq1d @ anwr preq2) (anwl h2));

theorem isfuneq: $ A == B -> (isfun A <-> isfun B) $ =
'(!! cbvald a1 a2 @ !! cbvald b1 b2 @ !! cbvald c1 c2 @
  imbid (eleqd (preqd anllr anlr) an3l) @
  imbid (eleqd (preqd anllr anr) an3l) @ eqeqd anlr anr);

theorem isfunss: $ A C_ B -> isfun B -> isfun A $ =
'(exp @ !! iald a @ !! iald b @ !! iald c @ exp @ exp @
  isfund anllr (sseld an3l anlr) (sseld an3l anr));

def opab {x y: nat} (p: wff x y): set =
$ {z | E. x E. y (z = x <> y /\ p)} $;

theorem elopabs (p: wff x y): $ a <> b e. opab x y p <-> [a / x] [b / y] p $ =
'(!! elabe z @ syl6bbr dfsb3 @ exbid @ syl6bbr (anbi2i dfsb3) @ syl6bb exan1 @
  exbid @ syl6bb anass @ anbi1d @ syl6bb prth @ syl6bb eqcomb eqeq1);

theorem elopabd (p: wff x y) (h: $ G /\ x = a /\ y = b -> (p <-> q) $):
  $ G -> (a <> b e. opab x y p <-> q) $ = '(syl5bb elopabs @ sbed @ sbed h);
theorem elopab (p: wff x y) (h: $ x = a /\ y = b -> (p <-> q) $):
  $ a <> b e. opab x y p <-> q $ = '(bitr elopabs @ sbe @ sbed h);

theorem nfopab1 (p: wff x y): $ FS/ x opab x y p $ = '(!! nfab _ z nfex1);
theorem nfopab2 (p: wff x y): $ FS/ y opab x y p $ = '(!! nfab _ z @ nfex nfex1);
theorem nfopab (p: wff x y z) (h: $ F/ x p $): $ FS/ x opab y z p $ =
'(!! nfab _ w @ nfex @ nfex @ nfan nfv h);

def Xp (A B: set): set = $ opab x y (x e. A /\ y e. B) $;

theorem nfxp (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ FS/ x Xp A B $ =
'(!! nfopab _ y z @ nfan (nfel2 h1) (nfel2 h2));
theorem prelxp: $ a <> b e. Xp A B <-> a e. A /\ b e. B $ =
'(!! elopab x y (anbid (eleq1d anl) (eleq1d anr)));
theorem elxp: $ a e. Xp A B <-> fst a e. A /\ snd a e. B $ =
'(bitr3 (eleq1 fstsnd) prelxp);

def Dom (A: set): set = $ {x | E. y x <> y e. A} $;
def Ran (A: set): set = $ {y | E. x x <> y e. A} $;

def Im (F A: set): set = $ {y | E. x (x e. A /\ x <> y e. F)} $;
infixl Im: $''$ prec 80;

def cnv (A: set): set = $ opab x y (y <> x e. A) $;

def comp (F G: set): set =
$ opab x z (E. y (x <> y e. G /\ y <> z e. F)) $;
infixr comp: $o.$ prec 90;

local def res (A B: set): set = $ A i^i Xp B V $;
infixl res: $|`$ prec 55;

theorem nfres (h1: $ FS/ x A $) (h2: $ FS/ x B $): $ FS/ x A |` B $ =
'(nfin h1 @ nfxp h2 nfsv);
theorem elres: $ a e. A |` B <-> a e. A /\ fst a e. B $ =
'(bitr elin @ anbi2i @ bitr4 elxp @ bian2 eluniv);
theorem prelres: $ a <> b e. A |` B <-> a <> b e. A /\ a e. B $ =
'(bitr elres @ anbi2i @ eleq1 fstpr);
theorem resss: $ A |` B C_ A $ = 'inss1;

def lam {x: nat} (a: nat x): set = $ {p | E. x p = x <> a} $;
notation lam {x: nat} (a: nat x): set = ($\$:30) x ($,$:0) a;

theorem lameq (a b: nat x): $ A. x a = b -> (\ x, a) == (\ x, b) $ =
'(!! cbvabd p1 p2 @ syl exbi @ ialdh (nfan nfal1 nfv) @
  eqeqd anr @ anwl @ syl preq2 eal);
theorem lameqd (G: wff) (a b: nat x)
  (h: $ G -> a = b $): $ G -> (\ x, a) == (\ x, b) $ = '(syl lameq (iald h));

theorem nflam1 (a: nat x): $ FS/ x \ x, a $ = '(!! nfab _ p nfex1);
theorem nflam (a: nat x y) (h: $ FN/ x a $): $ FS/ x \ y, a $ =
'(!! nfab _ p @ nfex @ nfeq nfnv @ nfpr nfnv h);
theorem cbvlamh (a b: nat x y) (h1: $ FN/ y a $) (h2: $ FN/ x b $)
  (e: $ x = y -> a = b $): $ (\ x, a) == (\ y, b) $ =
'(!! cbvab p1 p2 @ cbvexd @ eqeqd anl @ anwr @ preqd id e);
theorem cbvlam (a: nat x) (b: nat y)
  (e: $ x = y -> a = b $): $ (\ x, a) == (\ y, b) $ = '(cbvlamh nfnv nfnv e);
theorem cbvlams (a: nat x): $ (\ x, a) == (\ y, N[y / x] a) $ = '(cbvlamh nfnv nfsbn1 sbneq);
theorem cbvlamd (G: wff) (a: nat x) (b: nat y)
  (h: $ G /\ x = y -> a = b $): $ G -> (\ x, a) == (\ y, b) $ =
'(eqstrd (a1i cbvlams) @ lameqd @ syl sbnet @ iald @ exp h);

theorem lamisf (a: nat x): $ isfun (\ x, a) $ =
'(!! ax_gen u @ !! ax_gen v @ !! ax_gen w @
  sylbi (!! elabe p @ exbid eqeq1) @ eexh (nfim (nfel2 nflam1) nfv) @ sylbi prth @
  syl5bi (bitr (!! elabe p @ exbid eqeq1) @
    cbvexh nfv (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbneq) @
  !! eexd y @ syl5bi prth @ exp @ eqtr4d anlr @ eqtr4d anrr @ syl sbneq @
  eqtr3d anll anrl);

theorem finlam (v: nat x): $ finite A -> finite ((\ x, v) |` A) $ =
(focus
  (have 'h '(! ind a b _ $ E. n A. x (x < a -> x <> v < n) $ _ _ _ _
    (exbid @ albid @ imbi1d @ lteq2) (exbid @ albid @ imbi1d @ lteq2)
    (exbid @ albid @ imbi1d @ lteq2) (exbid @ albid @ imbi1d @ lteq2)
    (trud @ ! iexde _ _ $0$ _ @ iald @ a1i @ absurd lt02)
    (sylibr (!! cbvex _ m @ albid @ imbi2d @ lteq2) @
      eex @ syl (iexe @ albidh (nfeq2 @ nfmax nfnv @ nfsuc @ nfpr nfnv nfsbn1) @ imbi2d @ lteq2) @
      alimi @ syl5bir leltsuc @ syl5bi leloe @ eord
        (imim2i @ mpi lemax1 ltletr)
        (a1i @ mpbii lemax2 @ syl lteq2 @
          maxeqd eqidd @ suceqd @ preqd id sbneq))))
  '(!! eex n @ mpi h @ eximd @ syl6 _ @ al2imi @ exp @ syld anr anl)
  '(!! iald p @ syl5bi elres @ sylibr impexp @
    syl5bi (!! elabe q @ exbid eqeq1) @ sylibr eexb @ alimi @
    syl5ibrcom (imbid (eleq1d @ syl6eq fstpr fsteq) lteq1) id));

def app (F: set) (x: nat): nat = $ the {y | x <> y e. F} $;
infixl app: $@$ prec 200;

theorem appeqd (h1: $ G -> A == B $) (h2: $ G -> a = b $): $ G -> A @ a = B @ b $ =
'(theeqd @ !! cbvabd y1 y2 @ eleqd (preqd (anwl h2) anr) (anwl h1));
theorem appeq2d (h: $ G -> a = b $): $ G -> F @ a = F @ b $ = '(appeqd eqsidd h);
theorem appeq1: $ A == B -> A @ a = B @ a $ = '(appeqd id eqidd);
theorem appeq2: $ a = b -> F @ a = F @ b $ = '(appeq2d id);

theorem isfappd (h1: $ G -> isfun F $) (h2: $ G -> a <> b e. F $):
  $ G -> F @ a = b $ =
'(!! eqtheabd x @ syl6bb eqcomb @ isfunbd h1 h2);

theorem resapp: $ a e. A -> (F |` A) @ a = F @ a $ =
'(theeqd @ !! cbvabd y z @ syl5bb prelres @
  bitr3d (anwl bian2) @ anwr @ eleq1d preq2);

theorem lamapps (a b: nat x): $ (\ x, a) @ b = N[b / x] a $ =
'(trud @ isfappd (a1i lamisf) @ a1i @ mpbir
  (!! elabe p @ syl5bb
    (cbvexh nfv (nfeq2 @ nfpr nfnv nfsbn1) @ eqeq2d @ preqd id sbneq)
    (!! exbid z eqeq1))
  (iexe (eqeq2d @ preqd id sbneq1) eqid));
theorem lamapp (a: nat x): $ (\ x, a) @ x = a $ = '(eqtr lamapps sbnid);
theorem lamappe (a: nat x) (e: $ x = b -> a = c $):
  $ (\ x, a) @ b = c $ = '(eqtr lamapps @ sbne e);

def case (A B: set): set =
  $ \ n, if (odd n) (B @ (n // 2)) (A @ (n // 2)) $;

theorem caseeqd (h1: $ G -> A1 == A2 $) (h2: $ G -> B1 == B2 $):
  $ G -> case A1 B1 == case A2 B2 $ =
'(!! cbvlamd n1 n2 @ ifeqd (anwr oddeq)
  (appeqd (anwl h2) (anwr diveq1)) (appeqd (anwl h1) (anwr diveq1)));

pub theorem casel (A B: set) (n: nat): $ case A B @ b0 n = A @ n $ =
'(!! lamappe i @ eqtrd
  (syl ifneg @ mtbird oddeq (a1i b0odd))
  (appeq2d @ syl6eq b0div2 diveq1));
pub theorem caser (A B: set) (n: nat): $ case A B @ b1 n = B @ n $ =
'(!! lamappe i @ eqtrd
  (syl ifpos @ mpbird oddeq (a1i b1odd))
  (appeq2d @ syl6eq b1div2 diveq1));

abstract def Sum (A B: set): set =
$ {n | ifp (odd n) (n // 2 e. B) (n // 2 e. A)} $;
pub theorem Suml (A B: set) (n: nat): $ b0 n e. Sum A B <-> n e. A $ =
'(!! elabe i @ bitrd
  (syl ifpneg @ mtbird oddeq @ a1i b0odd)
  (eleq1d @ syl6eq b0div2 diveq1));
pub theorem Sumr (A B: set) (n: nat): $ b1 n e. Sum A B <-> n e. B $ =
'(!! elabe i @ bitrd
  (syl ifppos @ mpbird oddeq @ a1i b1odd)
  (eleq1d @ syl6eq b1div2 diveq1));

local def least (A: set): nat = $ the {x | x e. A /\ A. y (y e. A -> x <= y)} $;

theorem leasteq: $ A == B -> least A = least B $ =
'(theeqd @ !! cbvabd x1 x2 @ anbid (eleqd anr anl) @
  !! cbvald y1 y2 @ imbid (eleqd anr anll) (leeqd anlr anr));

theorem leastlem: $ a e. A -> least A e. A /\ A. z (z e. A -> least A <= z) $ =
(focus
  (have 'h1 $ A. z (z e. A -> a < z) \/ E. u (u e. A /\ A. z (z e. A -> u <= z)) $
    '(!! ind x y
      (orbi1d @ albid @ imbi2d lteq1) (orbi1d @ albid @ imbi2d lteq1)
      (orbi1d @ albid @ imbi2d lteq1) (orbi1d @ albid @ imbi2d lteq1)
      (cases
        (orrd @ sylan (iexe @ anbid eleq1 @ albid @ imbi2d leeq1)
          id (a1i @ ax_gen @ a1i le01))
        (orld @ iald @ exp @ sylibr lt01 @
          mtd anl @ com12 @ syl5 anr (bi1d eleq1)))
      (eor
        (casesda
          (orrd @ sylan (iexe @ anbid eleq1 @ albid @ imbi2d leeq1) anr anl)
          (orld @ ialdh (nfan nfal1 nfv) @ exp @ sylibr ltlene
            (iand (imp @ anwl eal) (mtand anlr @ mpbird (anwr eleq1) anlr))))
        orr)))
  (have 'h2 $ a e. A -> E. u (u e. A /\ A. z (z e. A -> u <= z)) $
    '(syl h1 @ mtd (a1i ltirr) @ com12 @ eale @ imbid eleq1 lteq2))
  (have 'h3 $ u e. A /\ A. z (z e. A -> u <= z) -> least A = u $
    '(!! eqtheabd v @ ibid
      (exp @ leasymd
        (mpd anll @ anwr @ anwr @ eale @ imbid eleq1 leeq2)
        (mpd anrl @ anwl @ anwr @ eale @ imbid eleq1 leeq2))
      (com12 @ bi2d @ anbid eleq1 @ albid @ imbi2d leeq1)))
  '(rsyl h2 @ eex @ mpbird (anbid (eleq1d h3) (albid @ imbi2d @ syl leeq1 h3)) id));

theorem leastel: $ a e. A -> least A e. A $ = '(anld @ !! leastlem x);

theorem leastle: $ a e. A -> least A <= a $ =
'(mpd (!! leastlem x) @ com12 @ anwr @ eale @ imbid eleq1 leeq2);

theorem least0: $ ~E. x x e. A -> least A = 0 $ =
'(! eqthe0abd _ y $ _ /\ A. z _ $ @ com12 @ syl absurdr @ anwl @ iexe eleq1);

local def znsub (m n) = $ if (m < n) (b1 (n - suc m)) (b0 (m - n)) $;
infixl znsub: $-ZN$ prec 65;

theorem znsubeqd (h1: $ G -> m1 = m2 $) (h2: $ G -> n1 = n2 $):
  $ G -> m1 -ZN n1 = m2 -ZN n2 $ =
'(ifeqd (lteqd h1 h2) (syl b1eq @ subeqd h2 @ suceqd h1)
  (syl b0eq @ subeqd h1 h2));

local def zfst (n) = $ case (\ mpos, mpos) (\ mneg, 0) @ n $;
local def zsnd (n) = $ case (\ mpos, 0) (\ mneg, suc mneg) @ n $;

theorem zfsteq: $ m = n -> zfst m = zfst n $ =
'(appeqd (caseeqd (!! cbvlamd mp1 mp2 anr) (!! cbvlamd mn1 mn2 eqidd)) id);
theorem zsndeq: $ m = n -> zsnd m = zsnd n $ =
'(appeqd (caseeqd (!! cbvlamd mp1 mp2 eqidd) (!! cbvlamd mn1 mn2 @ suceqd anr)) id);
theorem zfstb0: $ zfst (b0 n) = n $ =
'(eqtr (! casel $\ x, x$ $\ y, 0$ _) @ lamappe id);
theorem zfstb1: $ zfst (b1 n) = 0 $ =
'(eqtr (! caser $\ x, x$ $\ y, 0$ _) @ lamappe eqidd);
theorem zsndb0: $ zsnd (b0 n) = 0 $ =
'(eqtr (! casel $\ x, 0$ $\ y, suc y$ _) @ lamappe eqidd);
theorem zsndb1: $ zsnd (b1 n) = suc n $ =
'(eqtr (! caser $\ x, 0$ $\ y, suc y$ _) @ lamappe suceq);

theorem zfstsnd: $ zfst n -ZN zsnd n = n $ =
'(eor
  (eqtrd (syl ifneg @ sylib lenlt @ mpbiri le01 @
      leeqd (syl6eq zsndb0 zsndeq) (syl6eq zfstb0 zfsteq)) @
    eqtr4d (syl b0eq @ syl6eq sub02 @
      subeqd (syl6eq zfstb0 zfsteq) (syl6eq zsndb0 zsndeq)) id)
  (eqtrd (syl ifpos @ mpbiri lt01S @
      lteqd (syl6eq zfstb1 zfsteq) (syl6eq zsndb1 zsndeq)) @
    eqtr4d (syl b1eq @ syl6eq (eqtr subSS sub02) @
      subeqd (syl6eq zsndb1 zsndeq) (suceqd @ syl6eq zfstb1 zfsteq)) id)
  b0orb1);

theorem zfstznsub: $ zfst (m -ZN n) = m - n $ =
'(cases
  (eqtr4d (syl6eq zfstb1 @ syl zfsteq ifpos) ltsubeq0)
  (syl6eq zfstb0 @ syl zfsteq ifneg));

theorem zfstsnd0: $ zfst n = 0 \/ zsnd n = 0 $ =
'(eor (orrd @ syl6eq zsndb0 zsndeq) (orld @ syl6eq zfstb1 zfsteq) b0orb1);

theorem zneqb (a b c d): $ a -ZN c = b -ZN d <-> a + d = b + c $ =
(focus
  '(cases (casesda _ _) (casesda _ _))
  '(bitrd (eqeqd (anwl ifpos) (anwr ifpos)) @
    syl5bb (bitr4 b1can @ bitr addcan2 eqcomb) @ eqeqd
      (syl5eq (eqtr3 (addeq1 addS2) addass) @ syl addeq2 @ anwr pncan3)
      (syl5eq (eqtr3 (addeq1 @ eqtr addcom addS1) addass) @ syl addeq2 @ anwl pncan3))
  '(bitrd (eqeqd (anwl ifpos) (anwr ifneg)) @ binthd (a1i b1neb0) @
    syl ltne @ ltletrd (sylib ltadd1 anl) @
    sylib (leeq2 addcom) @ sylib leadd2 @ sylibr lenlt anr)
  '(bitrd (eqeqd (anwl ifneg) (anwr ifpos)) @ binthd (a1i b0neb1) @
    syl ltner @ lelttrd (sylib leadd2 @ sylibr lenlt anl) @
    sylib (bitr ltadd2 @ lteq1 addcom) anr)
  '(bitrd (eqeqd (anwl ifneg) (anwr ifneg)) @
    syl5bb b0can @ syl5bbr addcan1 @ eqeqd
      (syl5eqr addass @ syl addeq1 @ syl npcan @ sylibr lenlt anl)
      (syl5eqr addass @ syl5eq add32 @ syl addeq1 @ syl npcan @ sylibr lenlt anr)));

local def zneg (n) = $ zsnd n -ZN zfst n $;
prefix zneg: $-uZ$ prec 100;

theorem znegeq: $ m = n -> -uZ m = -uZ n $ = '(znsubeqd zsndeq zfsteq);

theorem znegzn: $ -uZ (a -ZN b) = b -ZN a $ =
'(mpbir zneqb @ eqtr addcom @ eqtr3 (mpbi zneqb zfstsnd) addcom);

theorem znegneg: $ -uZ -uZ n = n $ = '(eqtr znegzn zfstsnd);

theorem zfstneg: $ zfst (-uZ n) = zsnd n $ =
'(eqtr (zfsteq @ eqtr3 znegzn @ znegeq zfstsnd) @
  eqtr zfstznsub @
  eor (syl6eq sub02 subeq2) (eqtr4d subeq1 @ syl6eqr sub01 id) zfstsnd0);

theorem zsndneg: $ zsnd (-uZ n) = zfst n $ = '(eqtr3 zfstneg @ zfsteq znegneg);

theorem zsndznsub: $ zsnd (m -ZN n) = n - m $ =
'(eqtr3 zfstneg @ eqtr (zfsteq znegzn) zfstznsub);

local def zadd (m n) = $ (zfst m + zfst n) -ZN (zsnd m + zsnd n) $;
infixl zadd: $+Z$ prec 65;

theorem zaddzn: $ (a -ZN c) +Z (b -ZN d) = (a + b) -ZN (c + d) $ =
'(mpbir zneqb @ eqtr add4 @
  eqtr (addeq (mpbi zneqb zfstsnd) (mpbi zneqb zfstsnd)) add4);

local def zmul (m n) =
$ (zfst m * zfst n + zsnd m * zsnd n) -ZN
  (zfst m * zsnd n + zsnd m * zfst n) $;
infixl zmul: $*Z$ prec 70;

theorem zmulznlem (a1 b1 c1 d1 a2 b2 c2 d2)
  (h1: $ a1 + c2 = a2 + c1 $) (h2: $ b1 + d2 = b2 + d1 $):
  $ (a1 * b1 + c1 * d1) + (a2 * d2 + b2 * c2) =
    (a2 * b2 + c2 * d2) + (a1 * d1 + c1 * b1) $ =
(focus
  (have 'h3 $ b1 * c2 + (a1 * b1 + a2 * d2) = a2 * b2 + c1 * b1 + a2 * d1 $
    '(eqtr addcom @ eqtr add32 @
      eqtr (addeq1 @ eqtr (addeq2 mulcom) @ eqtr3 addmul @ eqtr (muleq1 h1) addmul) @
      eqtr add32 @
      eqtr (addeq1 @ eqtr3 muladd @ eqtr (muleq2 h2) muladd)
      add32))
  (have 'h4 $ b1 * c2 + (c2 * d2 + a1 * d1) = a2 * d1 + (c1 * d1 + b2 * c2) $
    '(eqtr3 addass @
      eqtr (addeq1 @ eqtr (addeq2 mulcom) @ eqtr3 addmul @ eqtr (muleq1 h2) @ addmul) @
      eqtr addass @
      eqtr4 (addeq2 @
        eqtr (addeq1 mulcom) @ eqtr addcom @
        eqtr3 addmul @ eqtr (muleq1 h1) addmul) @
      eqtr3 addass addcom))
  '(eqtr add4 @ eqtr (mpbi addcan2 _) @ eqtr add4 (addeq2 addcom))
  '(eqtr3 addass @ eqtr (addeq1 h3) @
    eqtr addass @ eqtr3 (addeq2 h4) @
    eqtr3 addass @ eqtr (addeq1 addcom) addass));

theorem zmulzn: $ (a -ZN c) *Z (b -ZN d) = (a * b + c * d) -ZN (a * d + b * c) $ =
'(mpbir zneqb @ zmulznlem (mpbi zneqb zfstsnd) (mpbi zneqb zfstsnd));

local def zabs (n) = $ zfst n + zsnd n $;

theorem zabsb0: $ zabs (b0 n) = n $ = '(eqtr (addeq zfstb0 zsndb0) add0);
theorem zabsneg: $ zabs (-uZ n) = zabs n $ = '(eqtr addcom @ addeq zsndneg zfstneg);
theorem zabszn: $ zabs (m -ZN n) = (m - n) + (n - m) $ = '(addeq zfstznsub zsndznsub);
theorem lezabszn: $ n <= m -> zabs (m -ZN n) = m - n $ =
'(syl5eq zabszn @ syl6eq add0 @ sylbi lesubeq0 addeq2);
theorem zabscom: $ zabs (m -ZN n) = zabs (n -ZN m) $ =
'(eqtr zabszn @ eqtr4 addcom zabszn);

local def zdvd (m n) = $ zabs m || zabs n $;
infixl zdvd: $|Z$ prec 50;

theorem eqmdvdsub2: $ mod(n): a = b <-> n || zabs (b -ZN a) $ =
'(eor (bitr4d eqmdvdsub @ syl dvdeq2 lezabszn)
  (syl5bb eqmcomb @ bitr4d eqmdvdsub @
    syl dvdeq2 @ syl5eq zabscom lezabszn)
  leorle);

theorem eqmzdvdsub: $ mod(n): a = b <-> b0 n |Z b -ZN a $ =
'(bitr4 eqmdvdsub2 @ dvdeq1 zabsb0);

local def zmod (a n: nat): nat = $ (zfst a + n - zsnd a % n) % n $;
infixl zmod: $%Z$ prec 70;

local def gcd (a b: nat): nat = $ the {d | A. x (x || d <-> x || a /\ x || b)} $;

theorem gcdeqd (a1 a2 b1 b2) (h1: $ G -> a1 = a2 $) (h2: $ G -> b1 = b2 $):
  $ G -> gcd a1 b1 = gcd a2 b2 $ =
'(theeqd @ !! cbvabd d1 d2 @ !! cbvald x1 x2 @
  bibid (dvdeqd anr anlr) @ anbid (dvdeqd anr @ anwll h1) (dvdeqd anr @ anwll h2));
theorem gcdeq1: $ a = b -> gcd a c = gcd b c $ = '(gcdeqd id eqidd);
theorem gcdeq2: $ b = c -> gcd a b = gcd a c $ = '(gcdeqd eqidd id);

theorem gcdcom: $ gcd a b = gcd b a $ =
'(theeqd id @ !! cbvab d1 d2 @ !! cbvald x y @ bibid (dvdeqd anr anl) @
  syl5bb ancomb @ anwr @ anbid dvdeq1 dvdeq1);

theorem eqgcd {x} (h: $ G -> (x || d <-> x || a /\ x || b) $):
  $ G -> gcd a b = d $ =
(focus
  (def h1 '(rsyl (anwl @ iald h) @ eale @ bibid dvdeq1 @ anbid dvdeq1 dvdeq1))
  (def h2 '(anwr @ eale @ bibid dvdeq1 @ anbid dvdeq1 dvdeq1))
  '(!! eqtheabd d2 @ ibida
    (dvdasymd (mpbird ,h1 @ mpbii dvdid ,h2) (mpbird ,h2 @ mpbii dvdid ,h1))
    (mpbird
      (!! cbvald y x @ bibid (dvdeqd anr anlr) (anwr @ anbid dvdeq1 dvdeq1))
      (anwl @ iald h))));

theorem gcd00: $ gcd 0 0 = 0 $ =
'(trud @ !! eqgcd x @ a1i @ bith dvd02 @ ian dvd02 dvd02);

local def bgcd (a b: nat): nat = $ least {d | 0 < d /\ E. x E. y x * a = y * b + d} $;

theorem dfbgcd: $ bgcd a b = least {d | 0 < d /\ E. x E. y x * a = y * b + d} $ =
'(leasteq @ !! cbvab d2 d @ anbid lteq2 @ !! cbvexd z x @ !! cbvexd w y @
    eqeqd (syl muleq1 anlr) @ addeqd (anwr muleq1) anll);

theorem bgcdeqd (a1 a2 b1 b2) (h1: $ G -> a1 = a2 $) (h2: $ G -> b1 = b2 $):
  $ G -> bgcd a1 b1 = bgcd a2 b2 $ =
'(syl5eq dfbgcd @ syl leasteq @ !! abeqd d @ anbi2d @ !! exbid x @ !! exbid y @
  eqeqd (syl muleq2 h1) @ syl addeq1 @ syl muleq2 h2);

theorem bgcdeq1: $ a = b -> bgcd a c = bgcd b c $ = '(bgcdeqd id eqidd);
theorem bgcdeq2: $ b = c -> bgcd a b = bgcd a c $ = '(bgcdeqd eqidd id);

theorem bgcd01: $ bgcd 0 b = 0 $ =
'(least0 @ !! ngen d @ mt (sylbi
  (!! elabe d2 @ anbid lteq2 @ exbid @ exbid @
    eqeqd (a1i mul02) addeq2) @
  imp @ !! eexd x @ !! eexd y @
  syl absurd @ syl ltne @ mpi leaddid1 ltletr) notfal);

theorem bgcdlem: $ a != 0 -> 0 < bgcd a b /\ E. x E. y x * a = y * b + bgcd a b $ =
'(sylib
  (!! elabe d @ anbid lteq2 @ !! cbvexd z x @ !! cbvexd w y @
    eqeqd (syl muleq1 anlr) @ addeqd (anwr muleq1) anll) @
  syl leastel @ sylibr (elabe @ anbid lteq2 @ exbid @ exbid @ eqeq2d addeq2) @
  iand (bi2 lt01) @ iexde @ iexde @
  eqtr4d (syl6eq mul11 @ syl muleq1 anlr) @
  syl6eq add01 @ syl addeq1 @ syl6eq mul01 @ anwr muleq1);

theorem bgcdpos: $ a != 0 -> 0 < bgcd a b $ = '(anld @ ! bgcdlem a b x y);

theorem bgcdbezout: $ E. x E. y x * a = y * b + bgcd a b $ =
'(cases
  (iexde @ iexde @ eqtr4d (muleqd anlr anll) @ syl6eqr mul01 @
    syl6eq add0 @ addeqd (syl6eq mul01 @ anwr muleq1) (syl6eq bgcd01 @ syl bgcdeq1 anll))
  (anrd bgcdlem));

theorem bgcdled (h: $ G -> 0 < d $) (h2: $ G -> x * a = y * b + d $):
  $ G -> bgcd a b <= d $ =
'(syl leastle @ sylibr (!! elabe d2 @ anbid lteq2 @ exbid @ exbid @ eqeq2d addeq2) @
  iand h @ !! iexde z @ !! iexde w @
  mpbird (eqeqd (syl muleq1 anlr) (syl addeq1 @ anwr muleq1)) (anwll h2));

theorem bgcd02: $ bgcd a 0 = a $ =
'(cases (eqtr4d (syl6eq bgcd01 bgcdeq1) id) @ leasymd
  (bgcdled (bi2i lt01) @ a1i @ eqtr mul11 @ eqcom @ eqtr (addeq1 mul01) add01)
  (mpi (!! bgcdbezout x y) @ eexd @ eexda @
    mpbid (leeqd (a1i mul11) @ syl6eq add01 @ syl6eq (addeq1 mul0) anr) @
    syl lemul1a @ sylibr lt01 @ mtand (anwl @ syl ltner bgcdpos) @ eqtr3d
      (anwl @ syl6eq add01 @ syl6eq (addeq1 mul0) anr)
      (syl6eq mul01 @ anwr muleq1)));

theorem dvdbgcd: $ d || a /\ d || b -> d || bgcd a b $ =
'(mpi (!! bgcdbezout x y) @ eexd @ eexda @
  mpbird (syl dvdadd1 @ syl dvdmul12 anlr) @
  mpbid (anwr dvdeq2) (anwll dvdmul12));

theorem bgcddvd1lem (h1: $ G -> a != 0 $) (h2: $ G -> x * a = y * b + d $)
  (h3: $ G -> b != 0 $) (h4: $ G -> d * q + r = a $)
  (h5: $ G -> x <= u $) (h6: $ G -> y <= u $):
  $ G -> suc ((u * b - x) * q) * a = (u * a - y) * q * b + r $ =
'(sylib addcan1 @ syl5eqr addass @
  eqtr4d (syl addeq1 @ syl5eqr addmul @ syl muleq1 @
    syl5eq addS1 @ suceqd @ syl5eqr addmul @ syl muleq1 @
    syl npcan @ letrd h5 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h3) @
  syl5eq (addeq2 addcom) @ syl5eqr addass @
  eqtr4d (syl addeq1 @ syl5eq add32 @ syl addeq1 @
    syl5eqr addmul @ syl muleq1 @ syl5eqr addmul @ syl muleq1 @
    syl npcan @ letrd h6 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h1) @
  syl6eqr add32 @ syl6eqr addass @
  syl5eq (addeq1 @ eqtr mulS1 @ addeq1 @
    eqtr mulass @ eqtr mulass @
    eqtr4 (muleq2 @ eqtr mulcom @ muleq1 mulcom) @
    eqtr (muleq1 mulass) mulass) @
  syl5eq addass @ syl addeq2 @ syl5eq addcom @
  eqtr3d (syl addeq2 h4) @ syl5eqr addass @ syl addeq1 @
  syl5eq (addeq1 mul32) @ syl5eqr addmul @ syl6eq mul32 @
  syl muleq1 @ eqcomd h2);

theorem bgcddvd2lem (h1: $ G -> a != 0 $) (h2: $ G -> x * a = y * b + d $)
  (h3: $ G -> b != 0 $) (h4: $ G -> d * q + r = b $)
  (h5: $ G -> x * q <= u $) (h6: $ G -> y * q < u $):
  $ G -> (u * b - x * q) * a = (u * a - suc (y * q)) * b + r $ =
'(sylib addcan1 @ syl5eqr addass @
  eqtr4d (syl addeq1 @ syl5eqr addmul @ syl muleq1 @
    syl npcan @ letrd h5 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h3) @
  syl5eq (addeq2 addcom) @ syl5eqr addass @
  eqtr4d (syl addeq1 @ syl5eq add32 @ syl addeq1 @ syl5eqr addmul @ syl muleq1 @
    syl npcan @ letrd h6 @ sylib (leeq1 mul12) @ syl lemul2a @ sylibr lt01 h1) @
  syl6eqr add32 @ syl6eqr addass @
  syl5eq (addeq1 mul32) @ syl addeq2 @
  syl5eq mulS1 @ eqtr3d (syl addeq2 h4) @
  syl5eqr addass @ syl addeq1 @ syl5eq (addeq1 mul32) @
  syl5eqr addmul @ syl6eq mul32 @ syl muleq1 @ eqcomd h2);

theorem bgcddvd1: $ bgcd a b || a $ =
'(cases (mpbiri dvd02 dvdeq2) @ mpi (! bgcdbezout a b x y) @ eexd @ eexda @
  casesda (anwr @ mpbii dvdid @ syl dvdeq2 @ syl6eq bgcd02 bgcdeq2) @
  sylib modeq0 @ mpd (anwll @ syl modlt @ sylib lt01 bgcdpos) @
  syl5bi ltnle @ con1d @ exp @ bgcdled (sylibr lt01 anr) @
  bgcddvd1lem an3l anllr anlr (a1i divmod) (a1i lemax1) (a1i lemax2));

theorem bgcddvd2: $ a != 0 -> bgcd a b || b $ =
'(casesda (anwr @ mpbiri dvd02 dvdeq2) @ mpi (! bgcdbezout a b x y) @ eexd @ eexda @
  sylib modeq0 @ mpd (anwll @ syl modlt @ sylib lt01 bgcdpos) @
  syl5bi ltnle @ con1d @ exp @ bgcdled (sylibr lt01 anr) @
  bgcddvd2lem an3l anlr anllr (a1i divmod) (a1i lemax1) (a1i lemax2));

theorem dvdbgcdb: $ a != 0 -> (d || bgcd a b <-> d || a /\ d || b) $ =
'(ibid
  (exp @ iand (sylc dvdtr anr (a1i bgcddvd1)) (sylc dvdtr anr (anwl bgcddvd2)))
  (a1i dvdbgcd));

theorem gcdbgcd: $ a != 0 -> gcd a b = bgcd a b $ = '(!! eqgcd d dvdbgcdb);

theorem gcd01: $ gcd 0 b = b $ = '(trud @ !! eqgcd d @ a1i @ bian1 dvd02);

theorem dvdgcdlem {x} (h: $ G -> (x || d <-> x || a /\ x || b) $):
  $ G -> (c || gcd a b <-> c || a /\ c || b) $ =
'(bitrd (syl dvdeq2 @ eqgcd h) @
  syl (eale @ bibid dvdeq1 @ anbid dvdeq1 dvdeq1) (iald h));

theorem dvdgcd: $ d || gcd a b <-> d || a /\ d || b $ =
'(cases (!! dvdgcdlem x @ syl bian1 @ mpbiri dvd02 dvdeq2) (!! dvdgcdlem x dvdbgcdb));
theorem gcddvd1: $ gcd a b || a $ = '(anl @ mpbi dvdgcd dvdid);
theorem gcddvd2: $ gcd a b || b $ = '(anr @ mpbi dvdgcd dvdid);

theorem gcd02: $ gcd a 0 = a $ = '(eqtr gcdcom gcd01);

theorem bezout: $ a != 0 -> E. x E. y x * a = y * b + gcd a b $ =
'(mpbiri bgcdbezout @ exbid @ exbid @ eqeq2d @ syl addeq2 gcdbgcd);

local def coprime (a b: nat): wff = $ gcd a b = 1 $;

theorem copcom: $ coprime a b <-> coprime b a $ = '(eqeq1 gcdcom);

theorem dvdcop (h1: $ G -> coprime a b $)
  (h2: $ G -> d || a $) (h3: $ G -> d || b $): $ G -> d = 1 $ =
'(sylib dvd12 @ mpbid (syl dvdeq2 h1) @ sylibr dvdgcd @ iand h2 h3);

theorem dfcop2: $ coprime a b <-> A. x (x || a -> x || b -> x = 1) $ =
'(ibii
  (iald @ exp @ exp @ dvdcop anll anlr anr)
  (!! eqgcd y @ ibid
    (a1i @ iand (mpi dvd11 dvdtr) (mpi dvd11 dvdtr))
    (exp @ sylibr dvd12 @ mpd anrr @ mpd anrl @ anwl @
      eale @ imbid dvdeq1 @ imbid dvdeq1 eqeq1)));

theorem copbezout (h1: $ G -> coprime a b $) (h2: $ G -> a != 0 $):
  $ G -> E. x E. y x * a = y * b + 1 $ =
'(mpbid (exbid @ exbid @ eqeq2d @ syl addeq2 h1) (syl bezout h2));

theorem copdvdmul2 (h1: $ G -> coprime a b $) (h2: $ G -> a || b * c $): $ G -> a || c $ =
'(casesda
  (mpbid (syl dvdeq2 @ syl6eq mul11 @
    syl muleq1 @ eqtr3d (anwr @ syl6eq gcd01 gcdeq1) (anwl h1)) (anwl h2))
  (mpd (copbezout (anwl h1) anr) @ !! eexd x @ !! eexda y @
    mpbird (syl dvdadd1 @ syl dvdmul11 @ anwll h2) @ mpbii dvdmul1 @
    syl dvdeq2 @ syl5eq mul32 @ syl6eq (addeq mul32 mul11) @
    syl6eq addmul @ syl muleq1 @ syl6eq (addeq1 mulcom) anr));

theorem copdvdmul1 (h1: $ G -> coprime a c $) (h2: $ G -> a || b * c $): $ G -> a || b $ =
'(copdvdmul2 h1 @ sylib (dvdeq2 mulcom) h2);

local def invm (a n: nat): nat = $ least {b | mod(n): a * b = 1} $;

theorem mulinvmlem (h: $ G -> mod(n): a * b = 1 $): $ G -> mod(n): a * invm a n = 1 $ =
'(sylib (!! elabe x @ syl eqmeq2 muleq2) @ syl leastel @ sylibr (elabe @ syl eqmeq2 muleq2) h);

theorem mulinvm (h: $ G -> coprime a n $):
  $ G -> mod(n): a * invm a n = 1 $ =
'(casesda (mpbiri eqm11 @ syl eqmeq1 @ eqtr3d (syl6eq gcd01 @ anwr gcdeq1) (anwl h)) @
  casesda (mulinvmlem @ syl eqeqm @ syl5eq mul12 @ eqtr3d (syl6eq gcd02 @ anwr gcdeq2) (anwll h)) @
  mpd (copbezout (anwll h) anlr) @ !! eexd x @ !! eexda y @ mulinvmlem @
  mpbid (eqmeq23d (eqtr3d anr @ a1i mulcom) (a1i add01)) @
  eqmadd1d @ a1i @ mpbir eqm03 dvdmul1);

local def pset (a: nat): set = $ {n | 0 < fst a /\ 0 < snd a /\
  A. x (0 < x /\ x <= n -> x || fst a) /\ suc (fst a * suc n) || snd a} $;

theorem pseteq: $ a = b -> pset a == pset b $ =
'(!! cbvabd n1 n2 @ anbid (anbid (anbid (syl lteq2 @ anwl fsteq) (syl lteq2 @ anwl sndeq)) @
    !! cbvald x1 x2 @ imbid (anbid (anwr lteq2) (leeqd anr anlr)) (dvdeqd anr @ anwll fsteq)) @
  dvdeqd (suceqd @ muleqd (anwl fsteq) @ suceqd anr) (anwl sndeq));

theorem elpset: $ n e. pset (m <> v) <-> 0 < m /\ 0 < v /\
  A. x (0 < x /\ x <= n -> x || m) /\ suc (m * suc n) || v $ =
'(!! elabe y @ anbid (anbid (anbid (syl lteq2 @ a1i @ fstpr) (syl lteq2 @ a1i @ sndpr)) @
    !! cbvald x1 _ @ imbid (anbid (anwr lteq2) (leeqd anr anl)) (dvdeqd anr (a1i fstpr))) @
  dvdeqd (suceqd @ muleqd (a1i fstpr) suceq) @ a1i sndpr);

theorem elpset1: $ ~n e. pset (m <> 1) $ =
'(inot @ sylbi (!! elpset x) @
  sylc absurd (sylib lenlt @ syl (sylibr mulpos @ iand id @ a1i lt01S) an3l) @
  dvdle (a1i d1ne0) anr);

theorem psetSlem1 (h1: $ G -> A. x (0 < x /\ x < n -> x || m) $)
  (h2: $ G -> i < j $) (h3: $ G -> j < n $):
  $ G -> coprime (suc (m * suc i)) (suc (m * suc j)) $ =
(focus
  '(sylibr dfcop2 @ !! iald u @ exp @ exp @
    sylib dvd12 @ mpbird _ (sylibr (dvdeq2 add12) anlr))
  '(syl dvdadd1 @ syl dvdmul11 @
    sylc dvdtr (mpbird
      (syl dvdadd1 @ anwr dvdmul11)
      (mpbird (syl dvdeq2 _) (syl dvdmul11 anlr))) @
    sylc (eale @ imbid (anbid lteq2 lteq1) dvdeq1) (anwll h1) @
    iand (sylib subpos @ anwll h2) @ lelttrd (a1i subleid) (anwll h3))
  '(syl5eq (addeq1 mulS1) @ syl5eq addass @
    syl6eqr mulS1 @ syl6eq (addeq1 mul32) @ syl addeq2 @
    syl5eq addS1 @ suceqd @ syl pncan3 @ syl ltle @ anwll h2));

theorem psetSlem2 (h1: $ G -> A. x (0 < x /\ x < n -> x || m) $) (h2: $ G -> a != b $)
  (h3: $ G -> a < n $) (h4: $ G -> b < n $):
  $ G -> coprime (suc (m * suc a)) (suc (m * suc b)) $ =
'(mpd (sylib neltlt h2) @ eorda
  (psetSlem1 (anwl h1) anr (anwl h4))
  (sylib copcom @ psetSlem1 (anwl h1) anr (anwl h3)));

theorem psetS (h1: $ G -> 0 < m $) (h2: $ G -> 0 < v $)
  (h3: $ G -> A. x (0 < x /\ x <= n -> x || m) $): $ G ->
  (a e. pset (m <> v * suc (m * suc n)) <-> a e. pset (m <> v) \/ a = n) $ =
(focus
  '(syl5bb elpset @ syl6bbr (orbi1i elpset) @ ibid
    (exp @ syl orcom @ exp @ iand (iand (iand
      (anwll h1)
      (anld @ sylib mulpos @ syl anllr anlr))
      (syl anlr anlr))
      (copdvdmul1 (psetSlem2 (sylc _ (syl anlr anlr) (anwll h3))
        anr (a1i lemax1) (a1i lemax2)) (anwl anrr)))
    (eord (animd (a1i @ anim1 @ anim2 @ sylibr mulpos @ iand id @ a1i lt01S)
      (a1i dvdmul11)) @
      syl5ibrcom (anbid (anbi2d @ albid @ imbi1d @ anbi2d leeq2) @
        syl dvdeq1 @ suceqd @ syl muleq2 suceq) @
      iand (iand (iand h1 (sylibr mulpos @ iand h2 @ a1i lt01S)) h3) @ a1i dvdmul1))
  '(al2imi @ syl6 (imim1i @ sylib andi @ anim2 @
    sylbi ltmax @ bi2 @ orbii leltsuc leltsuc) eor));

theorem lcmex: $ E. m (0 < m /\ A. x (0 < x /\ x <= n -> x || m)) $ =
'(! ind u v _ $ E. m (0 < m /\ A. x (0 < x /\ x <= u -> x || m)) $ _ _ _ _
  (exbid @ anbi2d @ albid @ imbi1d @ anbi2d leeq2)
  (exbid @ anbi2d @ albid @ imbi1d @ anbi2d leeq2)
  (exbid @ anbi2d @ albid @ imbi1d @ anbi2d leeq2)
  (exbid @ anbi2d @ albid @ imbi1d @ anbi2d leeq2)
  (iexe (anbid leeq2 @ albid @ imbi2d dvdeq2) @
    ian d0lt1 @ ax_gen @ imp @ sylbi ltnle absurd)
  (sylbi (!! cbvex _ a @ anbid leeq2 @ albid @ imbi2d dvdeq2) @ eex @ sylan
    (iexe @ anbid leeq2 @ albid @ imbi2d dvdeq2)
    (sylibr mulpos @ iand anl @ a1i lt01S)
    (anwr @ alimi @ sylbi impexp @ sylibr impexp @ imim2 @ syl5bi leloe @ eord
      (syl5bir leltsuc @ imim2i dvdmul11)
      (a1i @ mpbii dvdmul1 @ syl dvdeq2 muleq2))));

theorem psetsep (p: wff x): $ E. b pset b == {x | x < n /\ p} $ =
(focus
  (have 'h1 $ y < suc v /\ ([y / x] p) <-> y < v /\ ([y / x] p) \/ y = v /\ ([v / x] p) $
    '(bitr (anbi1i @ bitr3 leltsuc leloe) @ bitr andir @ orbi2i @ anbi2a sbeq1))
  (have 'h2 $ 0 < m /\ A. x (0 < x /\ x <= n -> x || m) ->
              E. a (0 < a /\ pset (m <> a) == {x | x < n /\ p}) $
    '(! indlt _ u v _
        $ E. a (0 < a /\ pset (m <> a) == {x | x < u /\ p}) $ _ _ _ _
      (exbid @ anbi2d @ eqseq2d @ abeqd @ anbi1d lteq2)
      (exbid @ anbi2d @ eqseq2d @ abeqd @ anbi1d lteq2)
      (exbid @ anbi2d @ eqseq2d @ abeqd @ anbi1d lteq2)
      (exbid @ anbi2d @ eqseq2d @ abeqd @ anbi1d lteq2)
      (a1i @ iexe (anbid lteq2 @ eqseq1d @ syl pseteq preq2) @
        ian d0lt1 @ eqab2i @ binth elpset1 @ mt anl lt02)
      (imp @ casesda
        (syl6ibr (!! cbvex _ b @ anbid lteq2 @ eqseq1d @ syl pseteq preq2) @
          eexda @ syl (iexe @ anbid lteq2 @ eqseq1d @ syl pseteq preq2) @
          iand (sylibr mulpos @ iand anrl @ a1i lt01S) @ !! eqrd y @
          syl6bbr (bitr elab @ sbeh (nfan nfv nfsb1) @ anbid lteq1 sbeq) @
          bitrd (psetS (anld an3l) anrl @ mpd (anrd an3l) @
            rsyl (syl (letr lesucid) anllr) @ alimd @ imim1d @ anim2d @ com12 letr) @
          bitrd (orbi1d @ syl6bb
            (bitr elab @ sbeh (nfan nfv nfsb1) @ anbid lteq1 sbeq) @ eleq2d anrr) @
          syl6bbr h1 @ orbi2d @ syl bian2 anlr)
        (bi2d @ exbid @ anbi2d @ eqseq2d @ !! eqrd y @
          syl5bb (bitr elab @ sbeh (nfan nfv nfsb1) @ anbid lteq1 sbeq) @
          syl6bbr (bitr elab @ sbeh (nfan nfv nfsb1) @ anbid lteq1 sbeq) @
          syl5bb h1 @ bicomd @ syl bior2 @ anwr @ con3 anr))))
  '(eex (mpd h2 @ eexda @ !! iexde b @ eqstrd (anwr pseteq) (anwl anrr)) lcmex));

theorem expset: $ finite A <-> E. a pset a == A $ =
(focus
  (have 'h '(sylib (!! elpset y) @ mpbird (eleq2d @ eqstrd (a1i @ pseteq fstsnd) anll) anr))
  '(ibii
    (!! eex n @ mpbiri psetsep @ exbid @ eqseq2d @ !! eqab2d y @ syl bian1a @
      !! eale x @ imbid eleq1 lteq1)
    (!! eex a @ iexde @ iald @ exp @
      letrd (syl (mpi lesucid letr) @
        sylib (leeq1 mul11) @ syl lemul1a @ syl an3l h) @
      letrd (dvdle (syl ltner @ syl anllr h) (anrd h)) @
      syl eqler anlr)));

theorem psetfn (p: wff x) (v: nat x):
  $ finite {x | p} -> E. a A. x (p -> pset a @ x = v) $ =
'(rsyl (sylib expset finlam) @ eximi @
  ialdh (nfeqs nfsv @ nfres nflam1 nfab1) @ exp @
  eqtrd (anwl appeq1) @ syl6eq lamapp @ anwr @ sylbir abid resapp);

local def pab (A: set): nat = $ least {a | pset a == A} $;

theorem psetpab: $ finite A <-> pset (pab A) == A $ =
'(bitr expset @ ibii
  (!! eex x @ sylib (!! elabe y @ syl eqseq1 pseteq) @
    sylbir (elabe @ syl eqseq1 pseteq) leastel)
  (iexe @ syl eqseq1 pseteq));

abstract def rec (z: nat) (S: set) (n: nat): nat =
$ the {v | E. a (pset a @ 0 = z /\ pset a @ n = v /\
    A. i (i < n -> pset a @ suc i = S @ (pset a @ i)))} $;

theorem receqd
  (h1: $ G -> z1 = z2 $) (h2: $ G -> S1 == S2 $) (h3: $ G -> n1 = n2 $):
  $ G -> rec z1 S1 n1 = rec z2 S2 n2 $ =
'(theeqd @ !! abeqd v @ !! exbid a @ anbid (anbid (eqeq2d h1) (eqeq1d @ syl appeq2 h3)) @
  !! albid i @ imbid (syl lteq2 h3) @ eqeq2d @ syl appeq1 h2);

theorem receq1: $ z1 = z2 -> rec z1 S n = rec z2 S n $ = '(receqd id eqsidd eqidd);
theorem receq2: $ S1 == S2 -> rec z S1 n = rec z S2 n $ = '(receqd eqidd id eqidd);
theorem receq3: $ n1 = n2 -> rec z S n1 = rec z S n2 $ = '(receqd eqidd eqsidd id);

theorem reclem {i}
  (h1: $ G -> pset a @ 0 = z $) (h2: $ G -> pset a @ n = v $)
  (h3: $ G -> A. i (i < n -> pset a @ suc i = S @ (pset a @ i)) $):
  $ G -> rec z S n = v $ =
(focus
  '(!! eqtheabd u @ ibid
    (eexda @ eqtr3d (anwr anlr) @ eqtrd _ (anwl h2))
    (exp @ !! iexde b @ iand (iand
        (eqtrd (syl appeq1 @ anwr pseteq) (anwll h1))
        (eqtrd (syl appeq1 @ anwr pseteq) @ eqtr4d (anwll h2) anlr)) @
      mpbird (albid @ imbi2d @ eqeqd (syl appeq1 @ anwr pseteq) @
        syl appeq2 @ syl appeq1 @ anwr pseteq) (anwll h3)))
  '(! indlt _ x y _ $ pset b @ x = pset a @ x $ _ _ _ _
    (eqeqd appeq2 appeq2) (eqeqd appeq2 appeq2)
    (eqeqd appeq2 appeq2) (eqeqd appeq2 appeq2)
    (eqtr4d (anwr anll) (anwl h1))
    (eqtrd (mpd anlr @ rsyl anllr @ anwr @ eale @ imbid lteq1 @
        eqeqd (syl appeq2 suceq) (syl appeq2 appeq2)) @
      eqtr4d (anwr appeq2) @
      mpd anlr @ anw3l @ rsyl h3 @ eale @ imbid lteq1 @
        eqeqd (syl appeq2 suceq) (syl appeq2 appeq2))));

pub theorem rec0 (z: nat) (S: set): $ rec z S 0 = z $ =
(focus
  (have 'h $ A. x (x = 0 -> pset a @ x = z) -> pset a @ 0 = z $
    '(mpi eqid (eale @ imbid eqeq1 @ eqeq1d appeq2)))
  '(eex (reclem h h @ a1i @ !! ax_gen i @ absurd lt02) (psetfn finsn)));

pub theorem recS (z: nat) (S: set) (n: nat):
  $ rec z S (suc n) = S @ rec z S n $ =
(focus
  '(trud @ ! indstr _ m k _ $ rec z S (suc m) = S @ rec z S m $ _ _
    (eqeqd (syl receq3 suceq) (syl appeq2 receq3))
    (eqeqd (syl receq3 suceq) (syl appeq2 receq3)) @ anwr @
    mpi (psetfn finle) @ ! eexda _ _ $ A. x (x <= suc k ->
      pset a @ x = if (x = suc k) (S @ rec z S k) (rec z S x)) $ _ @
    reclem
      (anwr @ syl6eq rec0 @ mpi le01 @ eale @ imbid leeq1 @ eqeqd appeq2 @
        eqtrd (syl ifneg @ mpbiri (necom peano1) neeq1) receq3)
      (anwr @ mpi leid @ eale @ imbid leeq1 @ eqeqd appeq2 ifpos)
      (!! iald y @ syl5bir leltsuc @ exp @
        eqtrd (mpd (sylib lesuc anr) @ rsyl anlr @ eale @ imbid leeq1 @
          eqeqd appeq2 @ ifeqd (syl6bb peano2 eqeq1) eqidd receq3) _))
  (have 'h
    $ A. m (m < k -> rec z S (suc m) = S @ rec z S m) /\
      A. x (x <= suc k -> pset a @ x = if (x = suc k) (S @ rec z S k) (rec z S x)) /\
      y <= k -> rec z S y = pset a @ y $
    '(mpd anlr @ anwr @ ealde @ syl6 eqcom @ bi1d @
      bitr3d (syl biim1 @ mpbird (anwr leeq1) @ letrd anl @ a1i lesucid) @
      eqeqd (anwr appeq2) @
      eqtrd (syl ifneg @ syl ltne @ sylib leltsuc @ imp @ syl5ibrcom leeq1 id) @
      anwr receq3))
  '(casesda
    (eqtr4d (anwr ifpos) @ syl appeq2 @ eqtr3d (anwl h) (anwr receq3))
    (eqtrd (anwr ifneg) @
      eqtrd (mpd (imp @ syl orcom @ sylib leloe anr) @
        rsyl an3l @ eale @ imbid lteq1 @
        eqeqd (syl receq3 suceq) (syl appeq2 receq3)) @
      syl appeq2 @ anwl h)));

abstract def pow (a b: nat): nat = $ rec 1 (\ n, a * n) b $;
infixr pow: $^$ prec 80;

theorem poweqd (a1 a2 b1 b2) (h1: $ G -> a1 = a2 $) (h2: $ G -> b1 = b2 $):
  $ G -> a1 ^ b1 = a2 ^ b2 $ = '(receqd eqidd (!! lameqd n @ syl muleq1 h1) h2);
theorem poweq1: $ a = b -> a ^ c = b ^ c $ = '(poweqd id eqidd);
theorem poweq2: $ b = c -> a ^ b = a ^ c $ = '(poweqd eqidd id);

pub theorem pow0: $ a ^ 0 = 1 $ = '(! rec0 _ (lam n _));
pub theorem powS: $ a ^ suc b = a * a ^ b $ =
'(eqtr recS @ !! lamappe n muleq2);
theorem powS2: $ a ^ suc b = a ^ b * a $ = '(eqtr powS mulcom);
theorem pow12: $ a ^ 1 = a $ = '(eqtr powS @ eqtr (muleq2 pow0) mul12);

theorem pow11: $ 1 ^ b = 1 $ =
'(!! ind x y
  (eqeq1d poweq2) (eqeq1d poweq2) (eqeq1d poweq2) (eqeq1d poweq2)
  pow0 (syl5eq powS @ syl5eq mul11 id));

theorem powpos: $ 0 < a -> 0 < a ^ b $ =
'(!! indd x y
  (syl lteq2 @ syl6eq pow0 poweq2) (syl lteq2 poweq2)
  (syl lteq2 @ syl6eq powS poweq2) (syl lteq2 poweq2)
  (a1i d0lt1) (bi2i mulpos));
theorem powne0: $ a != 0 -> a ^ b != 0 $ = '(sylbir lt01 @ sylib lt01 powpos);
theorem pow2ne0: $ 2 ^ b != 0 $ = '(powne0 d2ne0);

theorem powltid2: $ 1 < a -> b < a ^ b $ =
'(!! indd x y
  (lteqd id @ syl6eq pow0 poweq2) (lteqd id poweq2)
  (lteqd id @ syl6eq powS poweq2) (lteqd id poweq2)
  (a1i d0lt1)
  (lelttrd anr @ sylib (lteq1 mul11) @
    mpbid (syl ltmul1 @ syl powpos @ anwl @ lttr d0lt1) anl));

theorem powadd: $ a ^ (b + c) = a ^ b * a ^ c $ =
'(!! ind x y
  (eqeqd (syl poweq2 @ syl6eq add0 addeq2) (syl muleq2 @ syl6eq pow0 poweq2))
  (eqeqd (syl poweq2 addeq2) (syl muleq2 poweq2))
  (eqeqd (syl6eq powS2 @ syl poweq2 @ syl6eq addS addeq2) (syl muleq2 @ syl6eq powS2 poweq2))
  (eqeqd (syl poweq2 addeq2) (syl muleq2 poweq2))
  (eqcom mul12) (syl6eq mulass muleq1));

theorem powmul: $ a ^ (b * c) = (a ^ b) ^ c $ =
'(!! ind x y
  (eqeqd (syl poweq2 @ syl6eq mul0 muleq2) poweq2)
  (eqeqd (syl poweq2 muleq2) poweq2)
  (eqeqd (syl6eq powadd @ syl poweq2 @ syl6eq mulS muleq2) (syl6eq powS2 poweq2))
  (eqeqd (syl poweq2 muleq2) poweq2)
  (eqtr4 pow0 pow0) muleq1);

theorem powdvd: $ b <= c -> a ^ b || a ^ c $ =
'(mpbii dvdmul1 @ syl dvdeq2 @ syl5eqr powadd @ syl poweq2 npcan);
theorem lepow2a: $ a != 0 /\ b <= c -> a ^ b <= a ^ c $ =
'(dvdle (anwl powne0) (anwr powdvd));

def shl (a n: nat): nat = $ a * 2 ^ n $;
def shr (a n: nat): nat = $ a // 2 ^ n $;

theorem shleqd (h1: $ G -> a1 = a2 $) (h2: $ G -> n1 = n2 $):
  $ G -> shl a1 n1 = shl a2 n2 $ = '(muleqd h1 @ syl poweq2 h2);
theorem shleq1: $ a = b -> shl a c = shl b c $ = '(shleqd id eqidd);
theorem shleq2: $ b = c -> shl a b = shl a c $ = '(shleqd eqidd id);
theorem shreqd (h1: $ G -> a1 = a2 $) (h2: $ G -> n1 = n2 $):
  $ G -> shr a1 n1 = shr a2 n2 $ = '(diveqd h1 @ syl poweq2 h2);
theorem shreq1: $ a = b -> shr a c = shr b c $ = '(shreqd id eqidd);
theorem shreq2: $ b = c -> shr a b = shr a c $ = '(shreqd eqidd id);

theorem shl01: $ shl 0 b = 0 $ = 'mul01;
theorem shl02: $ shl a 0 = a $ = '(eqtr (muleq2 pow0) mul12);
theorem shl11: $ shl 1 b = 2 ^ b $ = 'mul11;
theorem shl12: $ shl a 1 = b0 a $ = '(eqtr (muleq2 pow12) b0mul22);
theorem shlshl: $ shl (shl a b) c = shl a (b + c) $ = '(eqtr4 mulass (muleq2 powadd));
theorem shlpow2dvd: $ 2 ^ b || shl a b $ = 'dvdmul1;
theorem shl2dvd: $ 0 < b -> 2 || shl a b $ =
'(sylib (dvdeq1 pow12) @ rsyl powdvd @ mpi shlpow2dvd dvdtr);

theorem shr01: $ shr 0 b = 0 $ = 'div01;
theorem shr02: $ shr a 0 = a $ = '(eqtr (diveq2 pow0) div12);
theorem shr12: $ shr a 1 = a // 2 $ = '(diveq2 pow12);
theorem shrshr: $ shr (shr a b) c = shr a (b + c) $ = '(eqtr4 divdiv (diveq2 powadd));
theorem shrmodadd1: $ shr (a % 2 ^ (b + c)) b = shr a b % 2 ^ c $ =
'(eqtr4 (shreq1 @ modeq2 powadd) divmod1);
theorem shrmodadd2: $ shr (a % 2 ^ (b + c)) c = shr a c % 2 ^ b $ =
'(eqtr (shreq1 @ modeq2 @ poweq2 addcom) shrmodadd1);
theorem shrshlid: $ shr (shl a b) b = a $ = '(muldiv1 pow2ne0);
theorem shrshl1: $ c <= b -> shr (shl a b) c = shl a (b - c) $ =
'(syl6eq shrshlid @ syl shreq1 @ syl6eqr shlshl @ syl shleq2 @ eqcomd npcan);
theorem shrshl2: $ b <= c -> shr (shl a b) c = shr a (c - b) $ =
'(syl6eq (shreq1 shrshlid) @ syl6eqr shrshr @ syl shreq2 @ eqcomd pncan3);

theorem shreq0: $ shr a b = 0 <-> a < 2 ^ b $ = '(diveq0 pow2ne0);

def nel (a b: nat): wff = $ odd (shr b a) $;

theorem neleqd (a1 a2 b1 b2) (h1: $ G -> a1 = a2 $) (h2: $ G -> b1 = b2 $):
  $ G -> (nel a1 b1 <-> nel a2 b2) $ = '(syl oddeq @ shreqd h2 h1);
theorem neleq1: $ a = b -> (nel a c <-> nel b c) $ = '(neleqd id eqidd);
theorem neleq2: $ b = c -> (nel a b <-> nel a c) $ = '(neleqd eqidd id);

def ns (a .x: nat): set = $ {x | nel x a} $; coercion ns: nat > set;

theorem nseq: $ a = b -> ns a == ns b $ = '(!! abeqd x neleq2);
theorem elnel: $ a e. ns b <-> nel a b $ = '(!! elabe x neleq1);
theorem elneqd (h1: $ G -> a = b $) (h2: $ G -> c = d $):
  $ G -> (a e. ns c <-> b e. ns d) $ = '(eleqd h1 @ syl nseq h2);
theorem elneq2d (h: $ G -> b = c $): $ G -> (a e. ns b <-> a e. ns c) $ = '(elneqd eqidd h);
theorem elneq2: $ b = c -> (a e. ns b <-> a e. ns c) $ = '(elneq2d id);

theorem el01: $ 0 e. ns a <-> odd a $ = '(bitr elnel @ oddeq shr02);

theorem elshr: $ a e. shr b c <-> a + c e. ns b $ =
'(bitr elnel @ bitr4 (oddeq @ eqtr shrshr @ shreq2 addcom) elnel);

theorem elshl: $ a e. shl b c <-> c <= a /\ a - c e. ns b $ =
'(bitr elnel @
  rbid (sylbi odddvd @ con1 @ sylbir ltnle @
    mpbird (syl dvdeq2 @ rsyl ltle shrshl1) (sylbi subpos shl2dvd)) anl @
  bitrd (syl6bbr elnel @ syl oddeq shrshl2) bian1);

theorem eldiv2: $ a e. b // 2 <-> suc a e. ns b $ =
'(bitr3 (elneq2 shr12) @ bitr elshr @ eleq1 add12);
theorem elb0: $ a e. b0 b <-> 0 < a /\ a - 1 e. ns b $ = '(bitr3 (elneq2 shl12) elshl);
theorem elb1: $ a e. b1 b <-> a = 0 \/ a - 1 e. ns b $ =
'(cases (bithd (mpbiri (mpbir el01 b1odd) eleq1) orl) @
  bitr3d (syl5bb (bitr3 (elneq2 b1div2) eldiv2) @ eleq1d sub1can) bior1);

theorem bndext:
  $ A. x (x < n -> (x e. ns a <-> x e. ns b)) -> mod(2 ^ n): a = b $ =
'(!! ind i j
  (imbid (albid @ imbi1d lteq2) (syl eqmeq1 @ syl6eq pow0 poweq2))
  (imbid (albid @ imbi1d lteq2) (syl eqmeq1 poweq2))
  (imbid (albid @ imbi1d lteq2) (syl eqmeq1 poweq2))
  (imbid (albid @ imbi1d lteq2) (syl eqmeq1 poweq2))
  (a1i eqm11) @
  rsyl (imim1i @ alimi @ imim1i @ mpi ltsucid lttr) @
  a2i @ rsyl (mpi ltsucid @ eale @ imbid lteq1 (bibid eleq1 eleq1)) @ exp @
  syl5eq (eqtr3 divmod @ addeq (muleq2 @ eqtr4 (diveq1 @ modeq2 powS2) divmod1) (modmod @ powdvd lesucid)) @
  syl6eqr (eqtr3 divmod @ addeq (muleq2 @ eqtr4 (diveq1 @ modeq2 powS2) divmod1) (modmod @ powdvd lesucid)) @
  addeqd (syl muleq2 @ sylib (boolext boolmod2 boolmod2) @
    syl5bbr dfodd2 @ syl6bb dfodd2 @
    syl5bbr elnel @ syl6bb elnel anl) anr);

pub theorem axext: $ ns a == ns b -> a = b $ =
'(syl5eqr (modlteq @ lelttr lemax1 @ powltid2 d1lt2) @
  syl6eq (modlteq @ lelttr lemax2 @ powltid2 d1lt2) @
  syl bndext @ !! alimi x ax_1);
theorem nseqb: $ ns a == ns b <-> a = b $ = '(ibii axext nseq);

pub theorem ellt: $ a e. ns b -> a < b $ =
'(sylbi elnel @ sylbi dfodd2 @ con1 @ sylbir lenlt @
  syl6eq mod01 @ syl modeq1 @ sylibr (diveq0 pow2ne0) @
  mpi (powltid2 d1lt2) lelttr);

theorem el02: $ ~a e. 0 $ = '(mt ellt lt02);
pub theorem nel0: $ ~a e. 0 $ = 'el02;

theorem el12: $ a e. 1 <-> a = 0 $ =
'(ibii (sylib lt12 ellt) (mpbiri (mpbir el01 odd1) eleq1));

theorem elpow2: $ a e. 2 ^ n <-> a = n $ =
'(bitr3 (elneq2 shl11) @ bitr elshl @
  bitr4 (anbi2i @ bitr4 el12 lesubeq0) @ bitr eqcomb eqlele);

theorem finns (a: nat): $ finite a $ =
'(finss (mpbi ssab2 @ !! ax_gen x ellt) finlt);

def lower (A: set) (.n: nat): nat = $ the {n | n == A} $;
pub theorem eqlower: $ finite A <-> A == lower A $ =
(focus
  (have 'h1 '(! ind y z _ $ E. n A. x (x e. ns n <-> x + y e. A) -> E. n A == ns n $ _ _ _ _
    (imbi1d @ exbid @ albid @ bibi2d @ eleq1d addeq2)
    (imbi1d @ exbid @ albid @ bibi2d @ eleq1d addeq2)
    (imbi1d @ exbid @ albid @ bibi2d @ eleq1d addeq2)
    (imbi1d @ exbid @ albid @ bibi2d @ eleq1d addeq2)
    (eximi @ alimi @ bicomd @ syl6bb (eleq1 add0) id)
    (imim1i @ sylib (!! cbvex m _ @ !! cbvald y _ @
        bibid (elneqd anr anl) (eleq1d @ anwr addeq1)) @
      eex @ iexde @ iald @ impcom @ casesda
        (a1d @ mpbiri (bitr el01 @ ibii
            (ax_3 @ mtbird (syl oddeq ifneg) (a1i b0odd))
            (mpbiri b1odd @ syl oddeq ifpos)) @
          bibid (elneqd anr anl) (eleq1d @ syl6eq add01 @ anwr addeq1))
        (ealde @ bi1d @ bibid
          (mpbiri
            (bitr3 (elneq2 @ cases
              (syl6eq b1div2 @ syl diveq1 ifpos)
              (syl6eq b0div2 @ syl diveq1 ifneg)) eldiv2)
            (bibid (eleq1d anr) @ elneqd (eqcomd @ syl sub1can anlr) anll))
          (eleq1d @ syl5eqr addSass @ syl addeq1 @
            eqtrd (suceqd anr) (syl sub1can anlr))))))
  (have 'h2 $ finite A -> E. n A == ns n $
    '(!! eex z @ syl h1 @ iexde @ iald @
      bitrd (elneq2d anr) @ binthd (a1i el02) @
      mtd (a1i @ mpbi lenlt leaddid1) (anwl @ !! eale y @ imbid eleq1 lteq1)))
  '(ibii (rsyl h2 @ eex @ eqstrd id @ syl nseq @ eqcomd @
      !! eqtheabd x @ syl6bb nseqb eqseq2) (mpbiri finns fineq)));

theorem ellower: $ finite A -> (a e. lower A <-> a e. A) $ = '(bicomd @ eleq2d @ bi1 eqlower);

abstract def sn (a: nat): nat = $ 2 ^ a $;
pub theorem elsn (a b: nat): $ a e. sn b <-> a = b $ = 'elpow2;

abstract def ins (a b: nat): nat = $ lower {x | x = a \/ x e. b} $;
infixr ins: $;$ prec 84;
pub theorem elins (a b c: nat): $ a e. ins b c <-> a = b \/ a e. c $ =
'(bitr (ellower @ finss (mpbi ssab @
    ax_gen @ eor (mpbiri lemax1 leeq1) @
    rsyl ellt @ letrd ltle @ a1i lemax2) finle) @
  !! elabe x @ orbid eqeq1 eleq1);

def upto (n: nat): nat = $ 2 ^ n - 1 $;

theorem uptoeq: $ a = b -> upto a = upto b $ = '(syl subeq1 poweq2);
theorem upto0: $ upto 0 = 0 $ = '(eqtr (subeq1 pow0) subid);
theorem uptoadd1: $ upto n + 1 = 2 ^ n $ = '(npcan @ powpos d0lt2);
theorem sucupto: $ suc (upto n) = 2 ^ n $ = '(eqtr3 add12 uptoadd1);
theorem uptoS: $ upto (suc n) = b1 (upto n) $ =
'(mpbi addcan1 @ eqtr uptoadd1 @ eqtr powS @ eqtr3 (muleq2 sucupto) @
  eqtr mulS @ eqtr4 (addeq1 b0mul21) addSass);

theorem uptolem: $ shr (upto n) a = upto (n - a) /\ upto n % 2 ^ a = upto (min n a) $ =
'(trud @ eqdivmod
  (ltletrd
    (a1i @ subltid @ ian (powpos d0lt2) d0lt1)
    (a1i @ lepow2a @ ian d2ne0 minle2))
  (a1i @ mpbi addcan1 @ eqtr addass @ eqtr4 (addeq2 uptoadd1) @ eqtr4 uptoadd1 @
    eqtr3 (addeq (cases
      (syl muleq1 @ syl poweq2 mineq2)
      (syl (eqtr4d (syl6eq mul0 muleq2) (syl6eq mul0 muleq2)) @
        syl6eq upto0 @ syl uptoeq nlesubeq0)) mul12) @
    eqtr3 muladd @ eqtr (muleq2 uptoadd1) @ eqtr3 powadd @ poweq2 minaddsub));

theorem shrupto: $ shr (upto n) a = upto (n - a) $ = '(anl uptolem);

pub theorem elupto (k n: nat): $ k e. upto n <-> k < n $ =
'(bitr elnel @ bitr (oddeq shrupto) @
  bitr4 (ibii
    (mtd (a1i odd0) @ com12 @ bi1d @ syl oddeq @ syl6eq upto0 uptoeq)
    (mpbii b1odd @ syl oddeq @ syl5eqr uptoS @ syl uptoeq sub1can)) @
  bitr subpos lt01);

def Bool: nat = $ 0 ; sn 1 $;
def Option (A: set): set = $ {n | n = 0 \/ n - 1 e. A} $;

def Power (A: set): set = $ {x | ns x C_ A} $;
def power (a: nat): nat = $ lower (Power a) $;

def cons (a b: nat): nat = $ suc (a <> b) $; infixr cons: $:$ prec 90;

abstract def sep (n: nat) (A: set): nat = $ lower (n i^i A) $;
pub theorem elsep (n: nat) (A: set) (a: nat):
  $ a e. sep n A <-> a e. n /\ a e. A $ =
'(bitr (ellower @ finss inss1 finns) elin);

def Arrow (A B: set) (.f: nat): set =
$ {f | isfun f /\ Dom f == A /\ Ran f C_ B} $;

def write (F: set) (x y .a .b: nat): set =
  $ opab a b (a <> b e. F /\ a != x \/ a = x /\ b = y) $;
pub theorem writeEq (F: set) (x y: nat): $ write F x y @ x = y $;
pub theorem writeNe (F: set) (x y a: nat): $ a != x -> write F x y @ a = F @ a $;

abstract def srec (S: set) (n: nat): nat;
pub theorem srecval {i: nat} (S: set) (n: nat):
  $ srec S n = S @ lower ((\ i, srec S i) |` upto n) $;

abstract def srecp (A: set): set;
pub theorem srecpval (A: set) (n: nat):
  $ n e. srecp A <-> n <> sep n (srecp A) e. A $;

abstract def card (s: nat): nat;
pub theorem card0: $ card 0 = 0 $;
pub theorem cardS (a s: nat): $ ~a e. s -> card (a ; s) = suc (card s) $;

abstract def all (A: set) (n: nat): wff;
pub theorem all0 (A: set): $ all A 0 $;
pub theorem allS (A: set) (a b: nat): $ all A (a : b) <-> a e. A /\ all A b $;

def List (A: set) (.n: nat): set = $ {n | all A n} $;

abstract def in (a l: nat): wff; infixl in: $IN$ prec 50;
pub theorem id0 (a: nat): $ ~ a IN 0 $;
pub theorem inS (a b l: nat): $ a IN (b : l) <-> a = b \/ a IN l $;

abstract def lmems (l: nat): nat;
pub theorem ellmems (a l: nat): $ a e. lmems l <-> a IN l $;

abstract def lrec (z: nat) (S: set) (n: nat): nat;
pub theorem lrec0 (z: nat) (S: set): $ lrec z S 0 = z $;
pub theorem lrecS (z: nat) (S: set) (a b: nat):
  $ lrec z S (a : b) = S @ (a <> lrec z S b) $;

abstract def len (l: nat): nat;
pub theorem len0: $ len 0 = 0 $;
pub theorem lenS (a b: nat): $ len (a : b) = suc (len b) $;

def Array (A: set) (n .l: nat): set = $ {l | l e. List A /\ len l = n} $;

abstract def snoc (l a: nat): nat; infixl snoc: $|>$ prec 85;
pub theorem snoc0 (a: nat): $ 0 |> a = a : 0 $;
pub theorem snocS (a b c: nat): $ (a : b) |> c = a : (b |> c) $;
pub theorem snoclt (a b: nat): $ a < a |> b $;

abstract def append (l1 l2: nat): nat; infixl append: $++$ prec 85;
pub theorem append0 (a: nat): $ 0 ++ a = a $;
pub theorem appendS (a b c: nat): $ (a : b) ++ c = a : (b ++ c) $;

abstract def nth (n l: nat): nat;
pub theorem nth0 (n: nat): $ nth n 0 = 0 $;
pub theorem nthZ (a l: nat): $ nth 0 (a : l) = suc a $;
pub theorem nthS (n a l: nat): $ nth (suc n) (a : l) = nth n l $;

abstract def repeat (a n: nat): nat;
pub theorem repeat0 (a: nat): $ repeat a 0 = 0 $;
pub theorem repeatS (a n: nat): $ repeat a (suc n) = a : repeat a n $;

def sublistAt (n l l2 .l1 .l3: nat): wff =
$ E. l1 E. l3 (l = l1 ++ l2 ++ l3 /\ len l1 = n) $;
