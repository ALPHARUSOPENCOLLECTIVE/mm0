delimiter $ ( [ { ~ , $
          $ } ] ) ~ , $;
strict provable sort wff;
term im (ph ps: wff): wff; infixr im: $->$ prec 25;
term not (ph: wff): wff; prefix not: $~$ prec 40;

axiom ax_1 (ph ps: wff): $ ph -> ps -> ph $;
axiom ax_2 (ph ps ch: wff): $ (ph -> ps -> ch) -> (ph -> ps) -> ph -> ch $;
axiom ax_3 (ph ps: wff): $ (~ph -> ~ps) -> ps -> ph $;
axiom ax_mp (ph ps: wff): $ ph $ > $ ph -> ps $ > $ ps $;

do {
  (set-timeout 500)
  (def (foldl l z s) (if (null? l) z (foldl (tl l) (s z (hd l)) s)))
  (def (foldr l z s) (if (null? l) z (s (hd l) (foldr (tl l) z s))))
  (def (rev l) (foldl l () (fn (l a) (cons a l))))
  (def (verb e) (list ':verb e))
  (def (exact e) (refine (verb e)))
  (def refine-extra-args-orig refine-extra-args)
  (def (refine-extra-args refine p . ps)
    (foldl ps p
      (fn (acc p2)
        (refine (list 'ax_mp (verb p2) (verb acc))))))
  (def (result) (hd (get-goals)))
  (def (target) (goal-type (result)))
};

local theorem a1i (h: $ b $): $ a -> b $ = '(ax_1 h);
local theorem a2i (h: $ a -> b -> c $): $ (a -> b) -> (a -> c) $ = '(ax_2 h);
local theorem mpd (h1: $ a -> b $) (h2: $ a -> b -> c $): $ a -> c $ = '(ax_2 h2 h1);
local theorem mpi (h1: $ b $) (h2: $ a -> b -> c $): $ a -> c $ = '(mpd (a1i h1) h2);
local theorem id: $ a -> a $ = '(mpd (! ax_1 _ a) ax_1);
local theorem idd: $ a -> b -> b $ = '(a1i id);
local theorem syl (h1: $ a -> b $) (h2: $ b -> c $): $ a -> c $ = '(mpd h1 (a1i h2));
local theorem a1d (h: $ a -> b $): $ a -> c -> b $ = '(syl h ax_1);
local theorem a2d (h: $ a -> b -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl h ax_2);
local theorem a3d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl h ax_3);
local theorem sylc (h1: $ a -> b $) (h2: $ a -> c $) (h: $ b -> c -> d $): $ a -> d $ = '(mpd h2 (syl h1 h));
local theorem syld (h1: $ a -> b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(mpd h1 (a2d (a1d h2)));
local theorem syl5 (h1: $ b -> c $) (h2: $ a -> c -> d $): $ a -> b -> d $ = '(syld (a1i h1) h2);
local theorem syl6 (h1: $ a -> b -> c $) (h2: $ c -> d $): $ a -> b -> d $ = '(syld h1 (a1i h2));
local theorem imim2: $ (b -> c) -> (a -> b) -> (a -> c) $ = '(a2d ax_1);
local theorem imim2i (h: $ b -> c $): $ (a -> b) -> (a -> c) $ = '(imim2 h);
local theorem imim2d (h: $ a -> c -> d $): $ a -> (b -> c) -> (b -> d) $ = '(syl h imim2);
local theorem absurd: $ ~a -> a -> b $ = '(a3d ax_1);
local theorem com12 (h: $ a -> b -> c $): $ b -> a -> c $ = '(syl ax_1 (a2i h));
local theorem absurdr: $ a -> ~a -> b $ = '(com12 absurd);
local theorem imim1: $ (a -> b) -> (b -> c) -> (a -> c) $ = '(com12 imim2);
local theorem imim1i (h: $ a -> b $): $ (b -> c) -> (a -> c) $ = '(imim1 h);
local theorem imim1d (h: $ a -> b -> c $): $ a -> (c -> d) -> (b -> d) $ = '(syl h imim1);
local theorem imimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $):
  $ a -> (c -> d) -> (b -> e) $ = '(syld (imim1d h1) (imim2d h2));
local theorem imidm: $ (a -> a -> b) -> a -> b $ = '(a2i (com12 id));
local theorem contra: $ (~a -> a) -> a $ = '(imidm (a3d (a2i absurd)));
local theorem dne: $ ~~a -> a $ = '(syl absurd contra);
local theorem con2: $ (a -> ~b) -> (b -> ~a) $ = '(a3d (syl5 dne id));
local theorem notnot1: $ a -> ~~a $ = '(con2 id);
local theorem con3: $ (a -> b) -> (~b -> ~a) $ = '(syl (imim2i notnot1) con2);
local theorem mt2d (h1: $ a -> c $) (h2: $ a -> b -> ~c $): $ a -> ~b $ = '(sylc h2 h1 con2);
local theorem con1: $ (~a -> b) -> (~b -> a) $ = '(a3d (imim2i notnot1));
local theorem cases (h1: $ a -> b $) (h2: $ ~a -> b $): $ b $ = '(contra (syl (con1 h2) h1));
local theorem casesd (h1: $ a -> b -> c $) (h2: $ a -> ~b -> c $): $ a -> c $ =
'(cases (com12 h1) (com12 h2));
local theorem con1d (h: $ a -> ~b -> c $): $ a -> ~c -> b $ = '(syl h con1);
local theorem con2d (h: $ a -> b -> ~c $): $ a -> c -> ~b $ = '(syl h con2);
local theorem con3d (h: $ a -> b -> c $): $ a -> ~c -> ~b $ = '(syl h con3);
local theorem con4d (h: $ a -> ~b -> ~c $): $ a -> c -> b $ = '(syl h ax_3);

def an (a b: wff): wff = $ ~(a -> ~b) $;
infixl an: $/\$ prec 35;

local theorem anl: $ a /\ b -> a $ = '(con1 absurd);
local theorem anr: $ a /\ b -> b $ = '(con1 ax_1);
local theorem ian: $ a -> b -> a /\ b $ = '(syl (com12 id) con2);
local theorem iand (h1: $ a -> b $) (h2: $ a -> c $): $ a -> b /\ c $ = '(sylc h1 h2 ian);
local theorem iani (h1: $ a $) (h2: $ b $): $ a /\ b $ = '(ian h1 h2);
local theorem anwl (h: $ a -> c $): $ a /\ b -> c $ = '(syl anl h);
local theorem anwr (h: $ b -> c $): $ a /\ b -> c $ = '(syl anr h);
local theorem imp (h: $ a -> b -> c $): $ a /\ b -> c $ = '(sylc anl anr h);
local theorem exp (h: $ a /\ b -> c $): $ a -> b -> c $ = '(syl6 ian h);
local theorem animd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b /\ d -> c /\ e $ =
'(exp (iand (imp (syl5 anl h1)) (imp (syl5 anr h2))));
local theorem anim1d (h: $ a -> b -> c $): $ a -> b /\ d -> c /\ d $ = '(animd h idd);
local theorem anim2d (h: $ a -> c -> d $): $ a -> b /\ c -> b /\ d $ = '(animd idd h);

def iff (a b: wff): wff = $ (a -> b) /\ (b -> a) $;
infixl iff: $<->$ prec 20;

local theorem bi1: $ (a <-> b) -> a -> b $ = 'anl;
local theorem bi1i (h: $ a <-> b $): $ a -> b $ = '(bi1 h);
local theorem bi1d (h: $ a -> (b <-> c) $): $ a -> b -> c $ = '(syl h bi1);
local theorem bi2: $ (a <-> b) -> b -> a $ = 'anr;
local theorem bi2i (h: $ a <-> b $): $ b -> a $ = '(bi2 h);
local theorem bi2d (h: $ a -> (b <-> c) $): $ a -> c -> b $ = '(syl h bi2);
local theorem ibii (h1: $ a -> b $) (h2: $ b -> a $): $ a <-> b $ = '(iani h1 h2);
local theorem ibid (h1: $ a -> b -> c $) (h2: $ a -> c -> b $): $ a -> (b <-> c) $ = '(iand h1 h2);
local theorem biid: $ a <-> a $ = '(ibii id id);
local theorem biidd: $ a -> (b <-> b) $ = '(a1i biid);
local theorem mpbi (h1: $ a $) (h2: $ a <-> b $): $ b $ = '(bi1i h2 h1);
local theorem mpbir (h1: $ a $) (h2: $ b <-> a $): $ b $ = '(bi2i h2 h1);
local theorem con1b: $ (~a <-> b) -> (~b <-> a) $ = '(ibid (con1d bi1) (con2d bi2));
local theorem con2b: $ (a <-> ~b) -> (b <-> ~a) $ = '(ibid (con2d bi1) (con1d bi2));
local theorem con3b: $ (a <-> b) -> (~b <-> ~a) $ = '(ibid (con3d bi1) (con3d bi2));
local theorem con4b: $ (~a <-> ~b) -> (b <-> a) $ = '(ibid (con4d bi1) (con4d bi2));
local theorem notnot: $ a <-> ~~a $ = '(ibii notnot1 dne);
local theorem bicom: $ (a <-> b) -> (b <-> a) $ = '(ibid bi2 bi1);
local theorem bicomd (h: $ a -> (b <-> c) $): $ a -> (c <-> b) $ = '(syl h bicom);
local theorem bitrd (h1: $ a -> (b <-> c) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ =
'(ibid (syld (bi1d h1) (bi1d h2)) (syld (bi2d h2) (bi2d h1)));
local theorem bitr3d (h1: $ a -> (c <-> b) $) (h2: $ a -> (c <-> d) $): $ a -> (b <-> d) $ = '(bitrd (bicomd h1) h2);
local theorem bitr4d (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> c) $): $ a -> (b <-> d) $ = '(bitrd h1 (bicomd h2));
local theorem bitr: $ (a <-> b) -> (b <-> c) -> (a <-> c) $ = '(exp (bitrd anl anr));
local theorem bitr3: $ (b <-> a) -> (b <-> c) -> (a <-> c) $ = '(exp (bitr3d anl anr));
local theorem bitr4: $ (a <-> b) -> (c <-> b) -> (a <-> c) $ = '(exp (bitr4d anl anr));
local theorem sylib (h1: $ a -> b $) (h2: $ b <-> c $): $ a -> c $ = '(syl h1 (bi1i h2));
local theorem sylbi (h1: $ a <-> b $) (h2: $ b -> c $): $ a -> c $ = '(syl (bi1i h1) h2);
local theorem notbi: $ (a <-> b) -> (~a <-> ~b) $ = '(bicomd con3b);
local theorem notbii (h: $ a <-> b $): $ ~a <-> ~b $ = '(notbi h);
local theorem notbid (h: $ a -> (b <-> c) $): $ a -> (~b <-> ~c) $ = '(syl h notbi);
local theorem imbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b -> d <-> c -> e) $ =
'(ibid (imimd (bi2d h1) (bi1d h2)) (imimd (bi1d h1) (bi2d h2)));
local theorem imbi1d (h: $ a -> (b <-> c) $): $ a -> (b -> d <-> c -> d) $ = '(imbid h biidd);
local theorem imbi2d (h: $ a -> (c <-> d) $): $ a -> (b -> c <-> b -> d) $ = '(imbid biidd h);
local theorem imbi1i (h: $ a <-> b $): $ a -> c <-> b -> c $ = '(imbi1d id h);
local theorem imbi2i (h: $ b <-> c $): $ a -> b <-> a -> c $ = '(imbi2d id h);
local theorem anbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b /\ d <-> c /\ e) $ =
'(ibid (animd (bi1d h1) (bi1d h2)) (animd (bi2d h1) (bi2d h2)));
local theorem anbi1d (h: $ a -> (b <-> c) $): $ a -> (b /\ d <-> c /\ d) $ = '(anbid h biidd);
local theorem anbi2d (h: $ a -> (c <-> d) $): $ a -> (b /\ c <-> b /\ d) $ = '(anbid biidd h);
local theorem anbi1i (h: $ a <-> b $): $ a /\ c <-> b /\ c $ = '(anbi1d id h);
local theorem anbi2i (h: $ b <-> c $): $ a /\ b <-> a /\ c $ = '(anbi2d id h);

def or (a b: wff): wff = $ ~a -> b $;
infixl or: $\/$ prec 30;

local theorem orl: $ a -> a \/ b $ = 'absurdr;
local theorem orr: $ b -> a \/ b $ = 'ax_1;
local theorem eori (h1: $ a -> c $) (h2: $ b -> c $): $ a \/ b -> c $ =
'(casesd (a1i h1) (imim2i h2));
local theorem eord (h1: $ a -> b -> d $) (h2: $ a -> c -> d $):
  $ a -> b \/ c -> d $ = '(com12 (eori (com12 h1) (com12 h2)));
local theorem eor: $ (a -> c) -> (b -> c) -> a \/ b -> c $ = '(exp (eord anl anr));
local theorem orimd (h1: $ a -> b -> c $) (h2: $ a -> d -> e $): $ a -> b \/ d -> c \/ e $ =
'(eord (syl6 h1 orl) (syl6 h2 orr));
local theorem orim1d (h: $ a -> b -> c $): $ a -> b \/ d -> c \/ d $ = '(orimd h idd);
local theorem orim2d (h: $ a -> c -> d $): $ a -> b \/ c -> b \/ d $ = '(orimd idd h);
local theorem orbid (h1: $ a -> (b <-> c) $) (h2: $ a -> (d <-> e) $): $ a -> (b \/ d <-> c \/ e) $ =
'(ibid (orimd (bi1d h1) (bi1d h2)) (orimd (bi2d h1) (bi2d h2)));
local theorem orbi1d (h: $ a -> (b <-> c) $): $ a -> (b \/ d <-> c \/ d) $ = '(orbid h biidd);
local theorem orbi2d (h: $ a -> (c <-> d) $): $ a -> (b \/ c <-> b \/ d) $ = '(orbid biidd h);
local theorem orbi1i (h: $ a <-> b $): $ a \/ c <-> b \/ c $ = '(orbi1d id h);
local theorem orbi2i (h: $ b <-> c $): $ a \/ b <-> a \/ c $ = '(orbi2d id h);
local theorem orbii (h1: $ a <-> b $) (h2: $ c <-> d $): $ a \/ c <-> b \/ d $ = '(bitr (orbi1i h1) (orbi2i h2));
local theorem notan: $ ~(a /\ b) <-> (~a \/ ~b) $ = '(bitr3 notnot (imbi1i notnot));
local theorem notor: $ ~(a \/ b) <-> (~a /\ ~b) $ = '(con1b (bitr4 notan (orbii notnot notnot)));

term wtru: wff; prefix wtru: $T.$ prec max;
axiom tru: $ T. $;
def fal: wff = $ ~T. $; prefix fal: $F.$ prec max;

local theorem trud (h: $ T. -> a $): $ a $ = '(h tru);
local theorem notfal: $ ~F. $ = '(notnot1 tru);
local theorem efal: $ F. -> a $ = '(absurd notfal);

sort nat;
term al {x: nat} (ph: wff x): wff; prefix al: $A.$ prec 40;

def ex {x: nat} (ph: wff x): wff = $ ~(A. x ~ph) $;
prefix ex: $E.$ prec 40;

term eq (a b: nat): wff; infixl eq: $=$ prec 50;

axiom ax_gen (ph: wff) {x: nat}: $ ph $ > $ A. x ph $;
axiom ax_4 {x: nat} (ph ps: wff x): $ A. x (ph -> ps) -> A. x ph -> A. x ps $;
axiom ax_5 {x: nat} (ph: wff): $ ph -> A. x ph $;
axiom ax_6 (a: nat) {x: nat}: $ E. x x = a $;
axiom ax_7 (a b c: nat): $ a = b -> a = c -> b = c $;
axiom ax_10 {x: nat} (ph: wff x): $ ~(A. x ph) -> A. x ~ (A. x ph) $;
axiom ax_11 {x y: nat} (ph: wff x y): $ A. x A. y ph -> A. y A. x ph $;
axiom ax_12 {x y: nat} (ph: wff y): $ A. y ph -> A. x (x = y -> ph) $;

local theorem alimi (a b: wff x) (h: $ a -> b $): $ A. x a -> A. x b $ = '(ax_4 (ax_gen h));
local theorem albii (a b: wff x) (h: $ a <-> b $): $ A. x a <-> A. x b $ =
'(ibii (alimi (bi1i h)) (alimi (bi2i h)));
local theorem alimd (a: wff) (b c: wff x) (h: $ a -> b -> c $):
  $ a -> A. x b -> A. x c $ = '(syl (syl h ax_5) ax_4);
local theorem alan (a b: wff x): $ A. x (a /\ b) <-> A. x a /\ A. x b $ =
'(ibii (iand (alimi anl) (alimi anr)) (imp (syl (alimi ian) ax_4)));
local theorem exim (a b: wff x): $ A. x (a -> b) -> E. x a -> E. x b $ =
'(syl (syl (alimi con3) ax_4) con3);
local theorem iex (a: wff x): $ a -> E. x a $ =
'(syl (syl (!! ax_5 y) ax_12) (mpi ax_6 exim));
local theorem alnex (a: wff x): $ A. x ~a <-> ~(E. x a) $ = 'notnot;
local theorem alex (a: wff x): $ A. x a <-> ~(E. x ~a) $ =
'(bitr (albii notnot) alnex);
local theorem exnal (a: wff x): $ E. x ~a <-> ~(A. x a) $ = '(con2b alex);
local theorem eal (a: wff x): $ A. x a -> a $ = '(ax_3 (sylib iex exnal));
local theorem iald (a: wff) (b: wff x) (h: $ a -> b $): $ a -> A. x b $ = '(syl ax_5 (alimi h));
local theorem exor (a b: wff x): $ E. x (a \/ b) <-> E. x a \/ E. x b $ =
'(bitr (notbii (bitr (albii notor) alan)) notan);
local theorem exim2 (a b: wff x): $ E. x (a -> b) <-> (A. x a -> E. x b) $;

local def nf {x: nat} (a: wff x): wff = $ A. x (a -> A. x a) $;
prefix nf: $F/$ prec 10;

local theorem nfv: $ F/ x a $ = '(ax_gen ax_5);
local theorem nfi (a: wff x) (h: $ F/ x a $): $ a -> A. x a $ = '(eal h);
local theorem nfri (a: wff x) (h: $ a -> A. x a $): $ F/ x a $ = '(ax_gen h);
local theorem nfal1 (a: wff x): $ F/ x A. x a $ = '(ax_gen ax_5);
local theorem nfal (a: wff x y) (h: $ F/ x a $): $ F/ x A. y a $ =
'(nfri (syl (alimi (nfi h)) ax_11));

local theorem eexb (a: wff x) (b: wff): $ E. x (a -> b) <-> (A. x a -> b) $;
local theorem eale (a: nat) (b: wff x) (c: wff)
  (e: $ x = a -> (b <-> c) $): $ A. x b -> c $;

def ne (a b: nat): wff = $ ~ a = b $; infixl ne: $!=$ prec 50;

def sb (a: nat) {x .y: nat} (ph: wff x): wff =
  $ A. y (y = a -> A. x (x = y -> ph)) $;
notation sb (a x ph) = ($[$:30) a ($/$:0) x ($]$:0) ph;

strict sort set;
term ab {x: nat} (ph: wff x): set;
notation ab {x: nat} (ph: wff x): set = (${$:max) x ($|$:0) ph ($}$:0);
term el: nat > set > wff; infixl el: $e.$ prec 50;
axiom elab (a: nat) {x: nat} (ph: wff x):
  $ a e. {x | ph} <-> [a / x] ph $;

def eqs (A B: set) {.x: nat}: wff = $ A. x (x e. A <-> x e. B) $;
infixl eqs: $==$ prec 50;

term the: set > nat;
axiom the_eq {x: nat} (a: nat): $ the {x | x = a} = a $;
axiom eqthe (A B: set): $ A == B -> the A = the B $;

def Inter (A B: set) (.x: nat): set = $ {x | x e. A /\ x e. B} $;
infixl Inter: $i^i$ prec 70;

def Union (A B: set) (.x: nat): set = $ {x | x e. A \/ x e. B} $;
infixl Union: $u.$ prec 65;

def Univ (.x: nat): set = $ {x | T.} $; prefix Univ: $V$ prec max;

def sbs (a: nat) {x .y: nat} (A: set x): set = $ {y | [a / x] y e. A} $;
notation sbs (a: nat) {x: nat} (A: set x): set =
  ($S[$:70) a ($/$:0) x ($]$:0) A;

def sbn (a: nat) {x .y: nat} (b: nat x): nat = $ the (S[a / x] {y | y = b}) $;
notation sbn (a: nat) {x: nat} (b: nat x): nat =
  ($N[$:70) a ($/$:0) x ($]$:0) b;

term d0: nat; prefix d0: $0$ prec max;
term suc: nat > nat;

def d1:  nat = $suc 0$; prefix d1:  $1$  prec max;
def d2:  nat = $suc 1$; prefix d2:  $2$  prec max;
def d3:  nat = $suc 2$; prefix d3:  $3$  prec max;
def d4:  nat = $suc 3$; prefix d4:  $4$  prec max;
def d5:  nat = $suc 4$; prefix d5:  $5$  prec max;
def d6:  nat = $suc 5$; prefix d6:  $6$  prec max;
def d7:  nat = $suc 6$; prefix d7:  $7$  prec max;
def d8:  nat = $suc 7$; prefix d8:  $8$  prec max;
def d9:  nat = $suc 8$; prefix d9:  $9$  prec max;
def d10: nat = $suc 9$; prefix d10: $10$ prec max;

axiom peano1 (a: nat): $ ~(0 = suc a) $;
axiom peano2 (a b: nat): $ suc a = suc b <-> a = b $;
axiom peano5 {x: nat} (ph: wff x):
  $ [0 / x] ph -> A. x (ph -> [suc x / x] ph) -> A. x ph $;

term add: nat > nat > nat; infixl add: $+$ prec 65;
term mul: nat > nat > nat; infixl mul: $*$ prec 70;

axiom add0 (a: nat): $ a + 0 = a $;
axiom addS (a b: nat): $ a + suc b = suc (a + b) $;
axiom mul0 (a: nat): $ a * 0 = 0 $;
axiom mulS (a b: nat): $ a * suc b = a * b + a $;

def le (a b .x: nat): wff = $ E. x a + x = b $;
infixl le: $<=$ prec 50;

def lt (a b: nat): wff = $ suc a <= b $;
infixl lt: $<$ prec 50;

abstract def ifp (ph a b: wff): wff = $ ph /\ a \/ ~ph /\ b $;
theorem ifptrue (ph a b: wff): $ ph -> ifp ph a b <-> a $;
theorem ifpfalse (ph a b: wff): $ ~ph -> ifp ph a b <-> b $;

abstract def if (ph: wff) (a b: nat): nat =
$ the {n | ifp ph (n = a) (n = b)} $;
theorem iftrue (ph: wff) (a b: nat): $ ph -> if ph a b = a $;
theorem iffalse (ph: wff) (a b: nat): $ ~ph -> if ph a b = b $;

def true (n: nat): wff = $ n != 0 $;
def bool (n: nat): wff = $ n < 2 $;
def nat (ph: wff): nat = $ if ph 1 0 $;

def min (a b: nat): nat = $ if (a < b) a b $;
def max (a b: nat): nat = $ if (a < b) b a $;

def pr (a b: nat): nat; infixr pr: $<>$ prec 54;
def fst (a: nat): nat;
def snd (a: nat): nat;

theorem fstpr (a b: nat): $ fst (a <> b) = a $;
theorem sndpr (a b: nat): $ snd (a <> b) = b $;
theorem fstsnd (a: nat): $ fst a <> snd a = a $;

theorem fst0: $ fst 0 = 0 $;
theorem snd0: $ snd 0 = 0 $;
theorem pr0: $ 0 <> 0 = 0 $;

def pi11 (n: nat): nat = $ fst (fst n) $;
def pi12 (n: nat): nat = $ snd (fst n) $;
def pi21 (n: nat): nat = $ fst (snd n) $;
def pi22 (n: nat): nat = $ snd (snd n) $;
def pi221 (n: nat): nat = $ fst (pi22 n) $;
def pi222 (n: nat): nat = $ snd (pi22 n) $;

def rec (z: nat) {x: nat} (s: nat x) (n: nat): nat;
theorem rec0 (z: nat) {x: nat} (s: nat x): $ rec z x s 0 = z $;
theorem recS (z: nat) {x: nat} (s: nat x) (n: nat):
  $ rec z x s (suc n) = N[rec z x s n / x] s $;

def sub (a b: nat): nat; infixl sub: $-$ prec 65;
theorem sub0 (a: nat): $ a - 0 = a $;
theorem subZ (b: nat): $ 0 - b = 0 $;
theorem subSS (a b: nat): $ suc a - suc b = a - b $;

def pow (a b: nat): nat; infixr pow: $^$ prec 80;
theorem pow0 (a: nat): $ a ^ 0 = 1 $;
theorem powS (a b: nat): $ a ^ suc b = a * a ^ b $;

def div (a b: nat): nat; infixl div: $//$ prec 70;
def mod (a b: nat): nat; infixl mod: $%$ prec 70;
theorem div0 (a: nat): $ a // 0 = 0 $;
theorem divmod (a b: nat): $ b * (a // b) + a % b = a $;
theorem modlt (a b: nat): $ b != 0 -> a % b < a $;

def dvd (a b .c: nat): wff = $ E. c c * a = b $;

def b0 (n: nat): nat = $ n + n $;
def b1 (n: nat): nat = $ suc (b0 n) $;
def odd (n: nat): wff = $ n % 2 = 1 $;

def shl (a n: nat): nat = $ a * 2 ^ n $;
def shr (a n: nat): nat = $ a // 2 ^ n $;

def nel (a b: nat): wff = $ odd (shr a b) $;
def ns (a .x: nat): set = ${x | nel x a}$; coercion ns: nat > set;
theorem axext {x: nat} (a b: nat): $ a == b -> a = b $;
theorem extlt (a b: nat): $ a e. b -> a < b $;
theorem nel0 (a: nat): $ ~ a e. 0 $;

def finite (A: set) (.n: nat): wff = $ E. n n == A $;

def lower (A: set) (.n: nat): nat = $ the {n | n == A} $;

def sn (a: nat): nat;
theorem elsn (a b: nat): $ a e. sn b <-> a = b $;

def ins (a b: nat): nat; infixr ins: $;$ prec 84;
theorem elins (a b c: nat): $ a e. ins b c <-> a = b \/ a e. c $;

def upto (n: nat): nat = $ 2 ^ n - 1 $;
theorem elupto (k n: nat): $ k e. upto n <-> k < n $;

def Bool: nat = $ 0 ; sn 1 $;
def Option (A: set) (.n: nat): set = $ {n | n = 0 \/ n - 1 e. A} $;

def subset (A B: set) (.x: nat): wff = $ A. x (x e. A -> x e. B) $;
infixl subset: $C_$ prec 50;

def Power (A: set) (.x: nat): set = $ {x | x C_ A} $;
def power (a: nat): nat = $ lower (Power a) $;

def card (s: nat): nat;
theorem card0: $ card 0 = 0 $;
theorem cardS (a s: nat): $ ~a e. s -> card (a ; s) = suc (card s) $;

def cons (a b: nat): nat = $ suc (a <> b) $; infixr cons: $:$ prec 90;

def sep (n: nat) (A: set): nat;
theorem elsep (n: nat) (A: set) (a: nat):
  $ a e. sep n A <-> a e. n /\ a e. A $;

def isfun (A: set) (.a .b .b2: nat): wff =
$ A. a A. b A. b2 (a <> b e. A -> a <> b2 e. A -> b = b2) $;

def opab {x y .z: nat} (ph: wff x y): set =
$ {z | E. x E. y (z = x <> y /\ ph)} $;

def Xp (A B: set) (.x .y .z: nat): set = $ opab x y (x e. A /\ y e. B) $;

def Dom (A: set) (.x .y: nat): set = $ {x | E. y x <> y e. A} $;
def Ran (A: set) (.x .y: nat): set = $ {y | E. x x <> y e. A} $;

def Im (F A: set) (.x .y: nat): set = $ {y | E. x (x e. A /\ x <> y e. F)} $;
infixl Im: $''$ prec 80;

def cnv (A: set) (.x .y: nat): set = $ opab x y (y <> x e. A) $;

def comp (F G: set) (.x .y .z: nat): set =
$ opab x z (E. y (x <> y e. G /\ y <> z e. F)) $;
infixr comp: $o.$ prec 90;

def res (A: set) (n: nat): nat = $ sep (lower (Xp n V)) A $;
infixl res: $|`$ prec 55;
theorem elres (n a b: nat) (A: set):
  $ isfun A -> (a <> b e. A |` n <-> a e. n /\ a <> b e. A) $;

def Arrow (A B: set) (.f: nat): set =
$ {f | isfun f /\ Dom f == A /\ Ran f C_ B} $;

def lam {x .p: nat} (a: nat x): set = ${p | E. x p = x <> a}$;
notation lam {x: nat} (a: nat x): set = ($\$:30) x ($,$:0) a;

def app (F: set) (x .y: nat): nat = $ the {y | x <> y e. F} $;
infixl app: $@$ prec 200;

def write (f x y .a .b: nat): nat =
  $ lower (opab a b (a <> b e. f /\ a != x \/ a = x /\ b = y)) $;
theorem writeEq (f x y: nat): $ write f x y @ x = y $;
theorem writeNe (f x y a: nat): $ a != x -> write f x y @ a = f @ a $;

def srec {x: nat} (s: nat x): set;
theorem srecval {x y: nat} (s: nat x) (n: nat):
  $ srec x s @ n = N[srec x s |` upto n / x] s $;

def srecp (A: set): set;
theorem srecpval (A: set) (n: nat):
  $ n e. srecp A <-> n <> sep n (srecp A) e. A $;

def case (A B: set) (.n: nat): set =
  $ \ n, if (odd n) (B @ (n // 2)) (A @ (n // 2)) $;
theorem casel (A B: set) (n: nat): $ case A B @ (b0 n) = A @ n $;
theorem caser (A B: set) (n: nat): $ case A B @ (b1 n) = B @ n $;

def Sum (A B: set): set;
theorem Suml (A B: set) (n: nat): $ b0 n e. Sum A B <-> n e. A $;
theorem Sumr (A B: set) (n: nat): $ b1 n e. Sum A B <-> n e. B $;

def all (A: set) (n: nat): wff;
theorem all0 (A: set): $ all A 0 $;
theorem allS (A: set) (a b: nat): $ all A (a : b) <-> a e. A /\ all A b $;

def List (A: set) (.n: nat): set = $ {n | all A n} $;

def in (a l: nat): wff; infixl in: $IN$ prec 50;
theorem id0 (a: nat): $ ~ a IN 0 $;
theorem inS (a b l: nat): $ a IN (b : l) <-> a = b \/ a IN l $;

def lmems (l: nat): nat;
theorem ellmems (a l: nat): $ a e. lmems l <-> a IN l $;

def lrec (z: nat) (S: set) (n: nat): nat;
theorem lrec0 (z: nat) (S: set): $ lrec z S 0 = z $;
theorem lrecS (z: nat) (S: set) (a b: nat):
  $ lrec z S (a : b) = S @ (a <> lrec z S b) $;

def len (l: nat): nat;
theorem len0: $ len 0 = 0 $;
theorem lenS (a b: nat): $ len (a : b) = suc (len b) $;

def Array (A: set) (n .l: nat): set = $ {l | l e. List A /\ len l = n} $;

def snoc (l a: nat): nat; infixl snoc: $|>$ prec 85;
theorem snoc0 (a: nat): $ 0 |> a = a : 0 $;
theorem snocS (a b c: nat): $ (a : b) |> c = a : (b |> c) $;
theorem snoclt (a b: nat): $ a < a |> b $;

def append (l1 l2: nat): nat; infixl append: $++$ prec 85;
theorem append0 (a: nat): $ 0 ++ a = a $;
theorem appendS (a b c: nat): $ (a : b) ++ c = a : (b ++ c) $;

def nth (n l: nat): nat;
theorem nth0 (n: nat): $ nth n 0 = 0 $;
theorem nthZ (a l: nat): $ nth 0 (a : l) = suc a $;
theorem nthS (n a l: nat): $ nth (suc n) (a : l) = nth n l $;

def repeat (a n: nat): nat;
theorem repeat0 (a: nat): $ repeat a 0 = 0 $;
theorem repeatS (a n: nat): $ repeat a (suc n) = a : repeat a n $;

def sublistAt (n l l2 .l1 .l3: nat): wff =
$ E. l1 E. l3 (l = l1 ++ l2 ++ l3 /\ len l1 = n) $;
