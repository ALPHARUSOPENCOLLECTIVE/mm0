import "compiler.mm1";
import "mm0.mm1";

---------------------------------------
-- Specification of a valid verifier --
---------------------------------------

--| The actual verifier ELF
def Verifier: string;

--| The verifier file is a valid ELF file
theorem Verifier_basicElf: $ isBasicElf Verifier $;

--| Given `mm0_file` on input, the verifier always terminates,
--| ensuring that the final input is empty (the entire input was consumed),
--| the output is empty (it outputs nothing), and the theorems in the
--| mm0 file are derivable.
theorem Verifier_terminates {input output: nat} (k mm0_file: nat):
  $ initialConfig Verifier mm0_file k ->
    terminates_ensuring k (S\ input, {output |
      input = 0 /\ output = 0 /\ Valid mm0_file}) $;

--| Unpacking the above claim: if we set up an initial configuration
--| such that `mm0_file` is on standard in, and it runs to completion
--| having consumed the input and produced no output with exit code 0,
--| then the theorems in the input are derivable.
theorem Verifier_Valid (k mm0_file i o: nat):
  $ initialConfig Verifier mm0_file k /\ succeeds k 0 0 ->
    Valid mm0_file $ =
(named '(mpd (sylan terminates_ensuring_succeeds (anwl Verifier_terminates) anr) @
  eexsabd @ eelabd @ a1i anr));

def Represents (env a_sorts a_terms a_thms: nat) = $ T. $;

do {
  -- Import some constants from MM1
  (mmc-add @ map (fn (x) '(const {{,x : u64} := (pure ,x)}))
    '(O_RDONLY O_WRONLY O_CREAT O_TRUNC
      MAP_FAILED MAP_PRIVATE MAP_ANONYMOUS))

  -- This is just a scratchpad for now, some thoughts on MMC syntax and primitives.
  (mmc-add '(
    (struct CStr
      {(ghost len) : nat}
      {buf : (array u8 {len + 1})}
      {eq0 : (pure $ A. i (nth buf i = suc 0 <-> i = len) $)})

    (struct Stat
      {st_dev : u64} {st_ino : u64} {st_nlink : u64}
      {st_mode : u32} {st_uid : u32} {st_gid : u32} {_ : i32}
      {st_rdev : u64} {st_size : i64}
      {st_blksize : i64} {st_blocks : i64}
      {st_atime : i64} {st_atime_nsec : i64}
      {st_mtime : i64} {st_mtime_nsec : i64}
      {st_ctime : i64} {st_ctime_nsec : i64}
      {_ : (array i64 3)})

    (intrinsic (sys_fstat {fd : u32}
      {(ghost (mut buf)) : (? Stat)} {p : (&sn buf)} :
      {(out buf) : Stat}
      u32))
    (intrinsic (sys_open
      {fname : (& CStr)}
      {flags : {(sn O_RDONLY) or (sn {O_WRONLY + O_CREAT + O_TRUNC})}} :
      u32))
    (intrinsic (sys_mmap {pos : (sn {0 : u64})} {len : u64} {prot : u32}
      {(ghost anon) : bool}
      {flags : (sn {(if anon MAP_PRIVATE {MAP_PRIVATE + MAP_ANONYMOUS}) : u64})}
      {fd : (if anon (sn {(- 1) : i64}) i64)}
      {off : (sn {0 : u64})} :
      {ret : (or
        (struct {err : i64} (pure $ isIOError err $))
        (own @ struct {ret : (array u8 len)} (pure $ anon -> all (sn 0) ret $)))}))

    (global {{g_file : u64} := uninit})
    (global {{g_end : u64} := uninit})

    (struct Header0
      {magic : u32} {version : u8} {num_sorts : u8} {_ : u16}
      {num_terms : u32} {num_thms : u32}
      {p_terms : u32} {p_thms : u32}
      {p_proof : u32} {_ : u32}
      {p_index : u64})

    (struct Header {h : Header0} {sorts : (array u8 (h . num_sorts))})

    (const {{MM0B_MAGIC : u32} := 0x42304D4D})
    (const {{MM0B_VERSION : u8} := 1})
    (const {{MAX_SORTS : u8} := 128})

    (struct Term0 {num_args : u16} {sort : u8} {_ : u8} {p_args : u32})
    (struct Thm0 {num_args : u16} {_ : u16} {p_args : u32})

    (global {{g_num_sorts : u32} := uninit} {{g_sorts : u64} := uninit})
    (global {{g_num_terms : u32} := uninit} {{g_terms : u64} := uninit})
    (global {{g_num_thms : u32} := uninit} {{g_thms : u64} := uninit})

    (struct Sort {s : u8} {h : {s < g_sorts}})
    (struct Env {e : nat} {h : (pure $ Env e $)})

    (const {{CMD_END : u8} := 0})

    (func (cmd_unpack {cmd : (& (array u8 5))} : u8 u8 u32)
      {v := (index cmd 0)}
      {w := {v band 0x3F}}
      (match {v shr 6}
        {0 => (return w 1 0)}
        {1 => (return w 2 {(slice cmd 1) : u8})}
        {2 => (return w 3 {(slice cmd 1) : u16})}
        {3 => (return w 5 {(slice cmd 1) : u32})}))

    (proc (verify
        {len : u64}
        {file : (& (array u8 len))}
        {(ghost (mut input)) : Input} :
        (pure $ Valid input $))
      {g_file <- file}
      {g_end <- (cast {file + len})}
      {{p : (& Header0)} := (pun file (assert {(sizeof Header0) <= len}))}
      (assert {(p . magic) = MM0B_MAGIC})
      (assert {(p . version) = MM0B_VERSION})
      {nsorts := (p . num_sorts)}
      {h2 := (assert {nsorts <= MAX_SORTS})}
      {g_num_sorts <- 0}
      {{g_sorts : (& (array u8 nsorts))} <- (& (slice file (sizeof Header)))}
      {(ghost a_sorts) := (sn {(slice g_sorts 0) : (& (array Sort g_num_sorts))})}
      {{h_sorts : {g_num_sorts <= nsorts}} := _}
      {g_num_terms <- 0}
      {p_terms := (p . p_terms)} {nterms := (p . num_terms)}
      {{g_terms : (& (array Term0 nterms))} <- (& (slice file p_terms))}
      {(ghost a_terms) := (sn {(slice g_terms 0) : (& (array Sort g_num_terms))})}
      {{h_terms : {g_num_terms <= nterms}} := _}
      {g_num_thms <- 0}
      {p_thms := (p . p_thms)} {nthms := (p . num_thms)}
      {{g_thms : (& (array Thm0 nthms))} <- (& (slice file p_thms))}
      {(ghost a_thms) := (sn {(& (slice g_thms 0)) : (& (array Sort g_num_thms))})}
      {{h_thms : {g_num_thms <= nthms}} := _}
      {(ghost remainder) := {len - (p . p_proof)}}
      {remainder_bd := (assert {{(p . p_proof) + 5} <= len})}
      {{stmt : (& (array u8 remainder))} :=
        (& (slice file (p . p_proof) (entail remainder_bd _)))}
      {{suff : {{stmt + remainder} = g_end}} := (entail _)}

      {{(ghost env) : Env} := _}
      {{(ghost env2) : Env} := _}
      {{ext : (pure $ EnvExtend env env2 $)} := _}
      {{repr : (pure @ Represents env2 a_sorts a_terms a_thms)} := _}

      (while {(index stmt 0 (entail remainder_bd _)) != CMD_END}
        (variant {(p . p_proof) + 5} <= len := remainder_bd)

        {((w sz data) h_unpack) := (sn (cmd_unpack stmt))}
        {{remainder <- {remainder - data}} with {remainder -> old_rem}}
        {next_stmt_bd := (assert {{stmt + data + 5} <= g_end})}
        {remainder_bd <- (entail next_stmt_bd _)}
        {{next_stmt : (& (array u8 remainder))} := (& (slice stmt data
          (entail next_stmt_bd suff _)))}

        (match w
          {CMD_STMT_SORT => (begin
            (assert {data = sz})
            {h := (assert {g_num_sorts < nsorts})}
            {(h_sorts repr2) :=
              (parse_until CMD_STMT_SORT h (mut env env2 ext) repr)}
            {(g_num_sorts _) <- (succ_lt g_num_sorts h)}
            {h_sorts := (pun h_sorts _)})}

          {{CMD_STMT_DEF or CMD_STMT_LOCAL_DEF} => (begin
              _ -- this marks unfinished code, the compiler will give an error
                -- and provide the current type context
            )}
        )

        {stmt <- next_stmt}
        {suff <- (entail suff _)}
        (continue
          (variant (entail h_unpack remainder
            -- proof of
            -- w <> sz <> data = cmd_unpack (* stmt),
            -- remainder = old_rem - data |- remainder < old_rem
            _))))
      (assert {g_num_sorts = nsorts})
      (assert {g_num_terms = nterms})
      (assert {g_num_thms = nthms})
      (entail (parse_until CMD_END) _))

    (proc (main
        {argc : u32}
        {args : (& (array (& CStr) argc))}
        (mut {(ghost input) : Input})
        (mut {(ghost output) : (sn {0 : Output})}) :
        (out {output : Output})
        (pure $ output = 0 /\ Valid input $))
      {(output2 oz) := output}
      {output <- output2}
      (begin
        {n := (sys_open (index args 1) O_RDONLY)}
        (assert {0 <= {n as i64}}))
      {{buf : (? Stat)} := uninit}
      (begin
        {n := (sys_fstat fd (mut buf) _)}
        (assert {0 <= {n as i64}}))
      {len := (buf . st_size)}
      {(ptr h) := (typeof! (sys_mmap 0 len PROT_READ #f MAP_PRIVATE))}
      {{ptr : (own (array u8 len))} :=
        (pun ptr (entail h (assert {ptr != MAP_FAILED})
          -- proof of
          -- ptr :: (union (sn {MAP_FAILED : u64})
          --   (own (Sigma {ret : (array u8 len)} $ fd = bitsNeg 32 1 -> all (sn 0) ret $))) /\
          -- ptr != MAP_FAILED
          -- |- (ptr :: (own (array u8 len))
          _))}
      (list oz (verify len ptr input)))
  ))
};
