/-#
This file is not autogenerated, but it is meant as a prelude for the
autogenerated set.mm import. To use this file, you should run mm0-hs on set.mm
to generate the MM0 files out.mm0 and out.mmu, and then feed these back into
mm0-hs to generate files setN.lean in this directory.

* The `-a .basic` says that all axioms should be commented out and this
  file should be referenced to find the definitions. (This will cause errors in
  the resulting lean file because this file doesn't yet have every axiom and
  definition in set.mm.)
* The `-c 2000` says to chunk up the output lean file
  every 2000 statements; this helps keep lean performant and allows for
  incremental builds. (You may want to adjust this value smaller, 2000 statements
  means the files are around 30000 lines which is quite high by lean standards.)

```
stack exec -- mm0-hs from-mm set.mm -o out.mm0 out.mmu
stack exec -- mm0-hs to-lean out.mm0 out.mmu -a .basic -c 2000 -o mm0-lean/mm0/set/set.lean
```

-/
import set_theory.zfc

namespace mm0

def wff : Type := Prop
def wff.proof : wff → Prop := id
def wff.forget {p : Prop} (h : wff → p) : p := h true
prefix `⊦ `:26 := wff.proof
def wi : wff → wff → wff := (→)
def wn : wff → wff := not

theorem ax_1 {ph ps : wff} : ph → ps → ph := λ h _, h
theorem ax_2 {ph ps ch : wff} :
  (ph → ps → ch) → (ph → ps) → ph → ch := λ h1 h2 h3, h1 h3 (h2 h3)
theorem ax_3 {ph ps : wff} : (¬ ph → ¬ ps) → ps → ph :=
λ h1 h2, classical.by_contradiction $ λ h3, h1 h3 h2
theorem ax_mp {ph ps : wff} : ph → (ph → ps) → ps := λ h1 h2, h2 h1

def wb : wff → wff → wff := iff

theorem df_an {ph ps : wff} : ph ∧ ps ↔ ¬ (ph → ¬ ps) :=
⟨λ ⟨h1, h2⟩ h3, h3 h1 h2, λ h1, classical.by_contradiction $
  λ h2, h1 $ λ h3 h4, h2 ⟨h3, h4⟩⟩

theorem df_bi.aux {ph ps : Prop} : (ph ↔ ps) ↔ ¬((ph → ps) → ¬(ps → ph)) :=
iff_def.trans df_an

theorem df_bi {ph ps : wff} :
  ¬(((ph ↔ ps) → ¬((ph → ps) → ¬(ps → ph))) →
  ¬(¬((ph → ps) → ¬(ps → ph)) → (ph ↔ ps))) :=
df_bi.aux.1 df_bi.aux

def wo : wff → wff → wff := or

theorem df_or {ph ps : wff} : ph ∨ ps ↔ (¬ ph → ps) :=
classical.or_iff_not_imp_left

def wa : wff → wff → wff := and

def w3o (p q r : wff) : wff := p ∨ q ∨ r

def w3a (p q r : wff) : wff := p ∧ q ∧ r

theorem df_3or {ph ps ch : Prop} : ph ∨ ps ∨ ch ↔ (ph ∨ ps) ∨ ch :=
or.assoc.symm

theorem df_3an {a b c : Prop} : a ∧ b ∧ c ↔ (a ∧ b) ∧ c :=
and.assoc.symm

def wnan (ph ps : wff) : wff := ¬ (ph ∧ ps)

theorem df_nan {ph ps : wff} : wb (wnan ph ps) (wn (wa ph ps)) :=
iff.rfl

def wxo : wff → wff → wff := xor

theorem df_xor {ph ps : wff} : xor ph ps ↔ ¬ (ph ↔ ps) :=
⟨λ h1 h2, or.cases_on h1 (λ ⟨h3, h4⟩, h4 (h2.1 h3)) (λ ⟨h3, h4⟩, h4 (h2.2 h3)),
 λ h1, classical.by_contradiction $ λ h2, h1
  ⟨λ h, classical.by_contradiction $ λ hn, h2 (or.inl ⟨h, hn⟩),
   λ h, classical.by_contradiction $ λ hn, h2 (or.inr ⟨h, hn⟩)⟩⟩

def wtru := true
def wfal := false

theorem df_tru {ph : wff} : wb wtru (wb ph ph) :=
(iff_true_intro iff.rfl).symm

theorem df_fal : wb wfal (wn wtru) := not_true_iff.symm

def whad (ph ps ch : wff) : wff := wxo (wxo ph ps) ch

def wcad (ph ps ch : wff) : wff := wo (wa ph ps) (wa ch (wxo ph ps))

theorem df_had {ph ps ch : wff} : wb (whad ph ps ch) (wxo (wxo ph ps) ch) := iff.rfl

theorem df_cad {ph ps ch : wff} : wb (wcad ph ps ch) (wo (wa ph ps) (wa ch (wxo ph ps))) := iff.rfl

theorem ax_meredith {ph ps ch th ta : wff}
  (h1 : (((ph → ps) → ¬ ch → ¬ th) → ch) → ta)
  (h2 : ta → ph) (h3 : th) : ph :=
classical.by_contradiction $ λ hn, hn $ h2 $ h1 $ λ h,
classical.by_contradiction $ λ hc, h (not.elim hn) hc h3

@[reducible] def setvar : Type 1 := Set

def setvar.forget {p : Prop} (h : setvar → p) : p := h (∅ : Set)
def wal (P : setvar → wff) : wff := ∀ x, P x

def wex : (setvar → wff) → wff := Exists

theorem df_ex {ph : setvar → wff} : (∃ x, ph x) ↔ ¬ ∀ x, ¬ ph x :=
by classical; exact not_forall_not.symm

def wnf (ph : setvar → wff) : wff := ∀ x, ph x → ∀ y, ph y

theorem df_nf {ph : setvar → wff} : wnf ph ↔ ∀ x, ph x → ∀ y, ph y := iff.rfl

theorem ax_gen {ph : setvar → wff} (h : ∀ x, ph x) : ∀ x, ph x := h

theorem ax_4 {ph ps : setvar → wff} (h : ∀ x, ph x → ps x)
  (h2 : ∀ x, ph x) (x) : ps x := h x (h2 x)

theorem ax_5 {ph : wff} (h : ph) (x : setvar) : ph := h

@[reducible] def «class» : Type 1 := Class

def «class».forget {p : Prop} (h : «class» → p) : p := h ∅
def cv : setvar → «class» := Class.of_Set

def wceq : «class» → «class» → wff := eq
local notation x ` ≡ ` y := eq (↑x : «class») ↑y

@[simp] theorem weq' {x y : setvar} : x ≡ y ↔ x = y := ⟨Class.of_Set.inj, congr_arg _⟩

def wsb (ph : setvar → wff) : setvar → wff := ph

theorem df_sb {ph : setvar → wff} {y : setvar} (x : setvar) :
  ph y ↔ (x ≡ y → ph x) ∧ ∃ x : setvar, x ≡ y ∧ ph x :=
⟨λ h, ⟨λ e, weq'.1 e.symm ▸ h, _, rfl, h⟩, λ ⟨_, x, e, h⟩, weq'.1 e ▸ h⟩

theorem df_sb_b {ph : setvar → wff} (x : setvar) :
  ph x ↔ (x ≡ x → ph x) ∧ ∃ x : setvar, x ≡ x ∧ ph x :=
⟨λ h, ⟨λ _, h, _, rfl, h⟩, λ ⟨h, _⟩, h rfl⟩

theorem ax_6 {y : setvar} : ¬ ∀ x:setvar, ¬ x ≡ y :=
df_ex.1 ⟨_, rfl⟩

theorem ax_7 {x y z : setvar} : x ≡ y → x ≡ z → y ≡ z :=
λ h1 h2, h1.symm.trans h2
theorem ax_7_b {x : setvar} : x ≡ x → x ≡ x → x ≡ x := ax_7
theorem ax_7_b1 {x z : setvar} : x ≡ x → x ≡ z → x ≡ z := ax_7
theorem ax_7_b2 {x y : setvar} : x ≡ y → x ≡ x → y ≡ x := ax_7
theorem ax_7_b3 {x y : setvar} : x ≡ y → x ≡ y → y ≡ y := ax_7

def wcel : «class» → «class» → wff := (∈)
local infix ` ∈' `:50 := (∈)
local notation x ` ∈ ` y := (x : «class») ∈ (y : «class»)
theorem ax_8 {x y z : setvar} (h : x ≡ y) (h' : x ∈ z) : y ∈ z := h ▸ h'
theorem ax_8_b {x y : setvar} : x ≡ y → x ∈ x → y ∈ x := ax_8
theorem ax_8_b1 {x y : setvar} : x ≡ y → x ∈ y → y ∈ y := ax_8

theorem ax_9 {x y z : setvar} (h : x ≡ y) (h' : z ∈ x) : z ∈ y := h ▸ h'
theorem ax_9_b {x y : setvar} : x ≡ y → x ∈ x → x ∈ y := ax_9
theorem ax_9_b1 {x y : setvar} : x ≡ y → y ∈ x → y ∈ y := ax_9

theorem ax_10 {ph : setvar → wff} (h : ¬ ∀ x, ph x) (x:setvar) : ¬ ∀ x, ph x := h

theorem ax_11 {ph : setvar → setvar → wff} (h : ∀ x y, ph x y) (y x) : ph x y := h x y

theorem ax_11_b {ph : setvar → wff} (h : ∀ x x : setvar, ph x) : ∀ x x : setvar, ph x := h

theorem ax_12 {ph : setvar → setvar → wff} (x y) (h : x ≡ y) (h2 : ∀ y, ph x y) (x') (h3 : x' ≡ y) : ph x' y :=
weq'.1 (h.trans h3.symm) ▸ h2 y

theorem ax_12_b {ph : setvar → wff} (x : setvar) (h : x ≡ x) (h2 : ∀ x, ph x) (x') (h3 : x' ≡ x') : ph x' := h2 x'

theorem ax_13 {y z : setvar} (x:setvar) (_ : ¬ x ≡ y) (h : y ≡ z) (x':setvar) : y ≡ z := h
theorem ax_13_b {z : setvar} (x:setvar) (h : ¬ x ≡ x) (_ : x ≡ z) (x':setvar) : x' ≡ z := h.elim rfl

theorem ax_c5 {ph : setvar → wff} (x : setvar) (h : ∀ x, ph x) : ph x := h x

theorem ax_c4 {ph ps : setvar → wff} (H : ∀ x, (∀ x, ph x) → ps x) (h : ∀ x, ph x) (x: setvar) : ps x := H x h

theorem ax_c7 {ph : setvar → wff} (x: setvar) (H : ¬ ∀ x':setvar, ¬ ∀ x, ph x) : ph x :=
let ⟨_, h⟩ := df_ex.2 H in h x

theorem ax_c10 {ph : setvar → wff} {y : setvar} (x : setvar)
  (H : ∀ x:setvar, x ≡ y → ∀ x, ph x) : ph x := H _ rfl _
theorem ax_c10_b {ph : setvar → wff} (x : setvar)
  (H : ∀ x:setvar, x ≡ x → ∀ x, ph x) : ph x := H x rfl _

theorem ax_c11 {ph : setvar → setvar → wff} (x y) (H : ∀ x : setvar, x ≡ y)
  (h : ∀ x, ph x y) (y') : ph x y' := weq'.1 ((H y).trans (H y').symm) ▸ h _
theorem ax_c11_b {ph : setvar → wff} (_ : ∀ x : setvar, x ≡ x) (h : ∀ x, ph x) : ∀ x, ph x := h

theorem ax_c11n (x y : setvar) (H : ∀ x:setvar, x ≡ y) (y':setvar) : y' ≡ x :=
(H _).trans (H _).symm

theorem ax_c15 {ph : setvar → wff} {y : setvar} (x : setvar)
  (_ : ¬ ∀ x:setvar, x ≡ y) (h : x ≡ y) (h2 : ph x) (x') (h3 : x' ≡ y) : ph x' :=
weq'.1 (h.trans h3.symm) ▸ h2

theorem ax_c9 {x y : setvar} (_ : ¬ ∀ z:setvar, z ≡ x) (_ : ¬ ∀ z:setvar, z ≡ y)
  (h : x ≡ y) (z':setvar) : x ≡ y := h
theorem ax_c9_b (z:setvar) (_ : ¬ ∀ z:setvar, z ≡ z) (_ : ¬ ∀ z:setvar, z ≡ z)
  (h : z ≡ z) (z':setvar) : z' ≡ z' := rfl
theorem ax_c9_b1 {x : setvar} (_ : ¬ ∀ z:setvar, z ≡ x) (_ : ¬ ∀ z:setvar, z ≡ x)
  (h : x ≡ x) (z':setvar) : x ≡ x := rfl
theorem ax_c9_b2 {y : setvar} (z : setvar) (H : ¬ ∀ z:setvar, z ≡ z) (_ : ¬ ∀ z:setvar, z ≡ y)
  (_ : z ≡ y) (z':setvar) : z' ≡ y := H.elim (λ _, rfl)
theorem ax_c9_b3 {x : setvar} (z : setvar) (_ : ¬ ∀ z:setvar, z ≡ x) (H : ¬ ∀ z:setvar, z ≡ z)
  (_ : x ≡ z) (z':setvar) : x ≡ z' := H.elim (λ _, rfl)

theorem ax_c14 {x y : setvar} (_ : ¬ ∀ z:setvar, z ≡ x) (_ : ¬ ∀ z:setvar, z ≡ y)
  (h : x ∈ y) (z':setvar) : x ∈ y := h

theorem ax_c16 {ph : setvar → wff} {y : setvar} (x : setvar)
  (H : ∀ x:setvar, x ≡ y) (h : ph x) (x') : ph x' :=
weq'.1 ((H x).trans (H x').symm) ▸ h

def weu : (setvar → wff) → wff := exists_unique
theorem df_eu {ph : setvar → wff} : (∃! x, ph x) ↔ (∃ y:setvar, ∀ x, ph x ↔ x ≡ y) :=
⟨λ ⟨x, hx, H⟩, ⟨x, λ y, ⟨λ h, weq'.2 (H _ h), λ e, weq'.1 e.symm ▸ hx⟩⟩,
 λ ⟨x, hx⟩, ⟨x, (hx _).2 rfl, λ y hy, weq'.1 ((hx _).1 hy)⟩⟩

def wmo (ph : setvar → wff) : wff := ∀ x y, ph x → ph y → x = y
theorem df_mo {ph : setvar → wff} : wmo ph ↔ ((∃ x, ph x) → (∃! x, ph x)) :=
⟨λ H ⟨x, hx⟩, ⟨x, hx, λ y hy, H _ _ hy hx⟩,
 λ H x y hx hy, let ⟨z, _, hz⟩ := H ⟨x, hx⟩ in
   (hz _ hx).trans (hz _ hy).symm⟩

theorem ax_7d {ph : setvar → setvar → wff} (H : ∀ x y:setvar, ph x y) (y x) : ph x y := H x y
def ax_8d := @ax_7
theorem ax_9d1 : ¬ ∀ x:setvar, ¬ x ≡ x := df_ex.1 ⟨∅, rfl⟩
def ax_9d2 := @ax_6
def ax_10d := @ax_c11n
def ax_11d := @ax_12

@[simp] theorem wel' {x y : setvar} : x ∈ y ↔ x ∈' y :=
(Class.mem_hom_left _ _).trans (Class.mem_hom_right _ _)

theorem ax_ext {x y : setvar} : (∀ z:setvar, z ∈ x ↔ z ∈ y) → x ≡ y :=
by simpa using @Set.ext x y

def cab (ph : setvar → wff) : «class» := {x | ph x}

theorem df_clab {ph : setvar → wff} {x : setvar} : x ∈ cab ph ↔ ph x :=
Class.mem_hom_left _ _

theorem df_clab_b {ph : setvar → wff} (y : setvar) : ↑y ∈ cab ph ↔ ph y := df_clab

-- y and z are quantified in the wrong place
theorem df_cleq {y z : setvar} {A B : «class»}
  (_ : (∀ x, x ∈ y ↔ x ∈ z) → y = z) :
  A = B ↔ ∀ x:setvar, x ∈ A ↔ x ∈ B :=
by simp; exact set.ext_iff A B

end mm0
