/-#
This file is not autogenerated, but it is meant as a prelude for the
autogenerated set.mm import. To use this file, you should run mm0-hs on set.mm
to generate the MM0 files out.mm0 and out.mmu, and then feed these back into
mm0-hs to generate files setN.lean in this directory.

* The `-a .basic` says that all axioms should be commented out and this
  file should be referenced to find the definitions. (This will cause errors in
  the resulting lean file because this file doesn't yet have every axiom and
  definition in set.mm.)
* The `-c 2000` says to chunk up the output lean file
  every 2000 statements; this helps keep lean performant and allows for
  incremental builds. (You may want to adjust this value smaller, 2000 statements
  means the files are around 30000 lines which is quite high by lean standards.)

```
stack exec -- mm0-hs from-mm set.mm -o out.mm0 out.mmu
stack exec -- mm0-hs to-lean out.mm0 out.mmu -a .basic -c 2000 -o mm0-lean/mm0/set/set.lean
```

-/
import .zfc_extra

namespace mm0

def wff : Type := Prop
def wff.proof : wff → Prop := id
def wff.forget {p : Prop} (h : wff → p) : p := h true
prefix `⊦ `:26 := wff.proof
def wi : wff → wff → wff := (→)
def wn : wff → wff := not

theorem ax_1 {ph ps : wff} : ph → ps → ph := λ h _, h
theorem ax_2 {ph ps ch : wff} :
  (ph → ps → ch) → (ph → ps) → ph → ch := λ h1 h2 h3, h1 h3 (h2 h3)
theorem ax_3 {ph ps : wff} : (¬ ph → ¬ ps) → ps → ph :=
λ h1 h2, classical.by_contradiction $ λ h3, h1 h3 h2
theorem ax_mp {ph ps : wff} : ph → (ph → ps) → ps := λ h1 h2, h2 h1

def wb : wff → wff → wff := iff

theorem df_an {ph ps : wff} : ph ∧ ps ↔ ¬ (ph → ¬ ps) :=
⟨λ ⟨h1, h2⟩ h3, h3 h1 h2, λ h1, classical.by_contradiction $
  λ h2, h1 $ λ h3 h4, h2 ⟨h3, h4⟩⟩

theorem df_bi.aux {ph ps : Prop} : (ph ↔ ps) ↔ ¬((ph → ps) → ¬(ps → ph)) :=
iff_def.trans df_an

theorem df_bi {ph ps : wff} :
  ¬(((ph ↔ ps) → ¬((ph → ps) → ¬(ps → ph))) →
  ¬(¬((ph → ps) → ¬(ps → ph)) → (ph ↔ ps))) :=
df_bi.aux.1 df_bi.aux

def wo : wff → wff → wff := or

theorem df_or {ph ps : wff} : ph ∨ ps ↔ (¬ ph → ps) :=
classical.or_iff_not_imp_left

def wa : wff → wff → wff := and

def w3o (p q r : wff) : wff := p ∨ q ∨ r

def w3a (p q r : wff) : wff := p ∧ q ∧ r

theorem df_3or {ph ps ch : Prop} : ph ∨ ps ∨ ch ↔ (ph ∨ ps) ∨ ch :=
or.assoc.symm

theorem df_3an {a b c : Prop} : a ∧ b ∧ c ↔ (a ∧ b) ∧ c :=
and.assoc.symm

def wnan (ph ps : wff) : wff := ¬ (ph ∧ ps)

theorem df_nan {ph ps : wff} : wb (wnan ph ps) (wn (wa ph ps)) :=
iff.rfl

def wxo : wff → wff → wff := xor

theorem df_xor {ph ps : wff} : xor ph ps ↔ ¬ (ph ↔ ps) :=
⟨λ h1 h2, or.cases_on h1 (λ ⟨h3, h4⟩, h4 (h2.1 h3)) (λ ⟨h3, h4⟩, h4 (h2.2 h3)),
 λ h1, classical.by_contradiction $ λ h2, h1
  ⟨λ h, classical.by_contradiction $ λ hn, h2 (or.inl ⟨h, hn⟩),
   λ h, classical.by_contradiction $ λ hn, h2 (or.inr ⟨h, hn⟩)⟩⟩

def wtru := true
def wfal := false

theorem df_tru {ph : wff} : wb wtru (wb ph ph) :=
(iff_true_intro iff.rfl).symm

theorem df_fal : wb wfal (wn wtru) := not_true_iff.symm

def whad (ph ps ch : wff) : wff := wxo (wxo ph ps) ch

def wcad (ph ps ch : wff) : wff := wo (wa ph ps) (wa ch (wxo ph ps))

theorem df_had {ph ps ch : wff} : wb (whad ph ps ch) (wxo (wxo ph ps) ch) := iff.rfl

theorem df_cad {ph ps ch : wff} : wb (wcad ph ps ch) (wo (wa ph ps) (wa ch (wxo ph ps))) := iff.rfl

theorem ax_meredith {ph ps ch th ta : wff}
  (h1 : (((ph → ps) → ¬ ch → ¬ th) → ch) → ta)
  (h2 : ta → ph) (h3 : th) : ph :=
classical.by_contradiction $ λ hn, hn $ h2 $ h1 $ λ h,
classical.by_contradiction $ λ hc, h (not.elim hn) hc h3

@[reducible] def setvar : Type 1 := Set

def setvar.forget {p : Prop} (h : setvar → p) : p := h (∅ : Set)
def wal (P : setvar → wff) : wff := ∀ x, P x

def wex : (setvar → wff) → wff := Exists

theorem df_ex {ph : setvar → wff} : (∃ x, ph x) ↔ ¬ ∀ x, ¬ ph x :=
by classical; exact not_forall_not.symm

def wnf (ph : setvar → wff) : wff := ∀ x, ph x → ∀ y, ph y

theorem df_nf {ph : setvar → wff} : wnf ph ↔ ∀ x, ph x → ∀ y, ph y := iff.rfl

theorem ax_gen {ph : setvar → wff} (h : ∀ x, ph x) : ∀ x, ph x := h

theorem ax_4 {ph ps : setvar → wff} (h : ∀ x, ph x → ps x)
  (h2 : ∀ x, ph x) (x) : ps x := h x (h2 x)

theorem ax_5 {ph : wff} (h : ph) (x : setvar) : ph := h

@[reducible] def «class» : Type 1 := Class

def «class».forget {p : Prop} (h : «class» → p) : p := h ∅
def cv : setvar → «class» := Class.of_Set

def wceq : «class» → «class» → wff := eq
local notation x ` ≡ ` y := eq (↑x : «class») ↑y

@[simp] theorem weq' {x y : setvar} : x ≡ y ↔ x = y := ⟨Class.of_Set.inj, congr_arg _⟩

def wsb (ph : setvar → wff) : setvar → wff := ph

theorem df_sb {ph : setvar → wff} {y : setvar} (x : setvar) :
  ph y ↔ (x ≡ y → ph x) ∧ ∃ x : setvar, x ≡ y ∧ ph x :=
⟨λ h, ⟨λ e, weq'.1 e.symm ▸ h, _, rfl, h⟩, λ ⟨_, x, e, h⟩, weq'.1 e ▸ h⟩

theorem df_sb_b {ph : setvar → wff} (x : setvar) :
  ph x ↔ (x ≡ x → ph x) ∧ ∃ x : setvar, x ≡ x ∧ ph x :=
⟨λ h, ⟨λ _, h, _, rfl, h⟩, λ ⟨h, _⟩, h rfl⟩

theorem ax_6 {y : setvar} : ¬ ∀ x:setvar, ¬ x ≡ y :=
df_ex.1 ⟨_, rfl⟩

theorem ax_7 {x y z : setvar} : x ≡ y → x ≡ z → y ≡ z :=
λ h1 h2, h1.symm.trans h2
theorem ax_7_b {x : setvar} : x ≡ x → x ≡ x → x ≡ x := ax_7
theorem ax_7_b1 {x z : setvar} : x ≡ x → x ≡ z → x ≡ z := ax_7
theorem ax_7_b2 {x y : setvar} : x ≡ y → x ≡ x → y ≡ x := ax_7
theorem ax_7_b3 {x y : setvar} : x ≡ y → x ≡ y → y ≡ y := ax_7

def wcel : «class» → «class» → wff := (∈)
local infix ` ∈' `:50 := (∈)
local notation x ` ∈ ` y := (x : «class») ∈ (y : «class»)
theorem ax_8 {x y z : setvar} (h : x ≡ y) (h' : x ∈ z) : y ∈ z := h ▸ h'
theorem ax_8_b {x y : setvar} : x ≡ y → x ∈ x → y ∈ x := ax_8
theorem ax_8_b1 {x y : setvar} : x ≡ y → x ∈ y → y ∈ y := ax_8

theorem ax_9 {x y z : setvar} (h : x ≡ y) (h' : z ∈ x) : z ∈ y := h ▸ h'
theorem ax_9_b {x y : setvar} : x ≡ y → x ∈ x → x ∈ y := ax_9
theorem ax_9_b1 {x y : setvar} : x ≡ y → y ∈ x → y ∈ y := ax_9

theorem ax_10 {ph : setvar → wff} (h : ¬ ∀ x, ph x) (x:setvar) : ¬ ∀ x, ph x := h

theorem ax_11 {ph : setvar → setvar → wff} (h : ∀ x y, ph x y) (y x) : ph x y := h x y

theorem ax_11_b {ph : setvar → wff} (h : ∀ x x : setvar, ph x) : ∀ x x : setvar, ph x := h

theorem ax_12 {ph : setvar → setvar → wff} (x y) (h : x ≡ y) (h2 : ∀ y, ph x y) (x') (h3 : x' ≡ y) : ph x' y :=
weq'.1 (h.trans h3.symm) ▸ h2 y

theorem ax_12_b {ph : setvar → wff} (x : setvar) (h : x ≡ x) (h2 : ∀ x, ph x) (x') (h3 : x' ≡ x') : ph x' := h2 x'

theorem ax_13 {y z : setvar} (x:setvar) (_ : ¬ x ≡ y) (h : y ≡ z) (x':setvar) : y ≡ z := h
theorem ax_13_b {z : setvar} (x:setvar) (h : ¬ x ≡ x) (_ : x ≡ z) (x':setvar) : x' ≡ z := h.elim rfl

theorem ax_c5 {ph : setvar → wff} (x : setvar) (h : ∀ x, ph x) : ph x := h x

theorem ax_c4 {ph ps : setvar → wff} (H : ∀ x, (∀ x, ph x) → ps x) (h : ∀ x, ph x) (x: setvar) : ps x := H x h

theorem ax_c7 {ph : setvar → wff} (x: setvar) (H : ¬ ∀ x':setvar, ¬ ∀ x, ph x) : ph x :=
let ⟨_, h⟩ := df_ex.2 H in h x

theorem ax_c10 {ph : setvar → wff} {y : setvar} (x : setvar)
  (H : ∀ x:setvar, x ≡ y → ∀ x, ph x) : ph x := H _ rfl _
theorem ax_c10_b {ph : setvar → wff} (x : setvar)
  (H : ∀ x:setvar, x ≡ x → ∀ x, ph x) : ph x := H x rfl _

theorem ax_c11 {ph : setvar → setvar → wff} (x y) (H : ∀ x : setvar, x ≡ y)
  (h : ∀ x, ph x y) (y') : ph x y' := weq'.1 ((H y).trans (H y').symm) ▸ h _
theorem ax_c11_b {ph : setvar → wff} (_ : ∀ x : setvar, x ≡ x) (h : ∀ x, ph x) : ∀ x, ph x := h

theorem ax_c11n (x y : setvar) (H : ∀ x:setvar, x ≡ y) (y':setvar) : y' ≡ x :=
(H _).trans (H _).symm

theorem ax_c15 {ph : setvar → wff} {y : setvar} (x : setvar)
  (_ : ¬ ∀ x:setvar, x ≡ y) (h : x ≡ y) (h2 : ph x) (x') (h3 : x' ≡ y) : ph x' :=
weq'.1 (h.trans h3.symm) ▸ h2

theorem ax_c9 {x y : setvar} (_ : ¬ ∀ z:setvar, z ≡ x) (_ : ¬ ∀ z:setvar, z ≡ y)
  (h : x ≡ y) (z':setvar) : x ≡ y := h
theorem ax_c9_b (z:setvar) (_ : ¬ ∀ z:setvar, z ≡ z) (_ : ¬ ∀ z:setvar, z ≡ z)
  (h : z ≡ z) (z':setvar) : z' ≡ z' := rfl
theorem ax_c9_b1 {x : setvar} (_ : ¬ ∀ z:setvar, z ≡ x) (_ : ¬ ∀ z:setvar, z ≡ x)
  (h : x ≡ x) (z':setvar) : x ≡ x := rfl
theorem ax_c9_b2 {y : setvar} (z : setvar) (H : ¬ ∀ z:setvar, z ≡ z) (_ : ¬ ∀ z:setvar, z ≡ y)
  (_ : z ≡ y) (z':setvar) : z' ≡ y := H.elim (λ _, rfl)
theorem ax_c9_b3 {x : setvar} (z : setvar) (_ : ¬ ∀ z:setvar, z ≡ x) (H : ¬ ∀ z:setvar, z ≡ z)
  (_ : x ≡ z) (z':setvar) : x ≡ z' := H.elim (λ _, rfl)

theorem ax_c14 {x y : setvar} (_ : ¬ ∀ z:setvar, z ≡ x) (_ : ¬ ∀ z:setvar, z ≡ y)
  (h : x ∈ y) (z':setvar) : x ∈ y := h

theorem ax_c16 {ph : setvar → wff} {y : setvar} (x : setvar)
  (H : ∀ x:setvar, x ≡ y) (h : ph x) (x') : ph x' :=
weq'.1 ((H x).trans (H x').symm) ▸ h

def weu : (setvar → wff) → wff := exists_unique
theorem df_eu {ph : setvar → wff} : (∃! x, ph x) ↔ (∃ y:setvar, ∀ x, ph x ↔ x ≡ y) :=
⟨λ ⟨x, hx, H⟩, ⟨x, λ y, ⟨λ h, weq'.2 (H _ h), λ e, weq'.1 e.symm ▸ hx⟩⟩,
 λ ⟨x, hx⟩, ⟨x, (hx _).2 rfl, λ y hy, weq'.1 ((hx _).1 hy)⟩⟩

def wmo (ph : setvar → wff) : wff := ∀ x y, ph x → ph y → x = y
notation `∃*` binders `, ` r:(scoped P, wmo P) := r

theorem df_mo {ph : setvar → wff} : (∃* x, ph x) ↔ ((∃ x, ph x) → (∃! x, ph x)) :=
⟨λ H ⟨x, hx⟩, ⟨x, hx, λ y hy, H _ _ hy hx⟩,
 λ H x y hx hy, let ⟨z, _, hz⟩ := H ⟨x, hx⟩ in
   (hz _ hx).trans (hz _ hy).symm⟩

theorem ax_7d {ph : setvar → setvar → wff} (H : ∀ x y:setvar, ph x y) (y x) : ph x y := H x y
def ax_8d := @ax_7
theorem ax_9d1 : ¬ ∀ x:setvar, ¬ x ≡ x := df_ex.1 ⟨∅, rfl⟩
def ax_9d2 := @ax_6
def ax_10d := @ax_c11n
def ax_11d := @ax_12

@[simp] theorem wel' {x y : setvar} : x ∈ y ↔ x ∈' y :=
(Class.mem_hom_left _ _).trans (Class.mem_hom_right _ _)

theorem ax_ext {x y : setvar} : (∀ z:setvar, z ∈ x ↔ z ∈ y) → x ≡ y :=
by simpa using @Set.ext x y

def cab (ph : setvar → wff) : «class» := {x | ph x}
local notation `{` binders ` | ` r:(scoped P, cab P) `}` := r

theorem df_clab {ph : setvar → wff} {x : setvar} : x ∈ {y | ph y} ↔ ph x :=
Class.mem_hom_left _ _

theorem df_clab_b {ph : setvar → wff} (y : setvar) : ↑y ∈ cab ph ↔ ph y := df_clab

theorem df_cleq {A B : setvar → setvar → «class»}
  (_ : ∀ y z:setvar, (∀ x:setvar, x ∈ y ↔ x ∈ z) → y ≡ z) (y z : setvar) :
  A y z = B y z ↔ ∀ x:setvar, x ∈ A y z ↔ x ∈ B y z :=
by simp; exact set.ext_iff (A y z) (B y z)

theorem df_clel {A B : «class»} : A ∈ B ↔ ∃ x:setvar, ↑x = A ∧ x ∈ B :=
by simp; refl

def wnfc (A : setvar → «class») : wff := ∀ x y, A x = A y

theorem df_nfc {A : setvar → «class»} : wnfc A ↔ ∀ y:setvar, wnf (λ x, y ∈ A x) :=
by simp; exact
⟨λ H y x hx x', by rw H x' x; exact hx,
 λ H x x', set.ext $ λ y, ⟨λ h, H _ _ h _, λ h, H _ _ h _⟩⟩

def wne : «class» → «class» → wff := (≠)
theorem df_ne {A B : «class»} : A ≠ B ↔ ¬ A = B := iff.rfl

def wnel : «class» → «class» → wff := (∉)
theorem df_nel {A B : «class»} : A ∉ B ↔ ¬ A ∈ B := iff.rfl

def wral (ph : setvar → wff) (A : setvar → «class») : wff := ∀ x:setvar, x ∈ A x → ph x
theorem df_ral {ph : setvar → wff} {A : setvar → «class»} :
  wral ph A ↔ (∀ x:setvar, x ∈ A x → ph x) := iff.rfl

def wrex (ph : setvar → wff) (A : setvar → «class») : wff := ∃ x:setvar, x ∈ A x ∧ ph x
theorem df_rex {ph : setvar → wff} {A : setvar → «class»} :
  wrex ph A ↔ (∃ x:setvar, x ∈ A x ∧ ph x) := iff.rfl

def wreu (ph : setvar → wff) (A : setvar → «class») : wff := ∃! x:setvar, x ∈ A x ∧ ph x
theorem df_reu {ph : setvar → wff} {A : setvar → «class»} :
  wreu ph A ↔ ∃! x:setvar, x ∈ A x ∧ ph x := iff.rfl

def wrmo (ph : setvar → wff) (A : setvar → «class») : wff := ∃* x:setvar, x ∈ A x ∧ ph x
theorem df_rmo {ph : setvar → wff} {A : setvar → «class»} :
  wrmo ph A ↔ ∃* x:setvar, x ∈ A x ∧ ph x := iff.rfl

def crab (ph : setvar → wff) (A : setvar → «class») : «class» := {x | x ∈ A x ∧ ph x}
theorem df_rab {ph : setvar → wff} {A : setvar → «class»} :
  crab ph A = {x | x ∈ A x ∧ ph x} := rfl

def cvv : «class» := set.univ
notation `V` := cvv
theorem df_v : V = {x | x ≡ x} := set.ext $ λ x, (iff_true_intro rfl).symm

def wcdeq (ph : wff) (x y : setvar) : wff := x ≡ y → ph
theorem df_cdeq {ph : wff} {x y : setvar} :
  wcdeq ph x y ↔ (x ≡ y → ph) := iff.rfl

def wsbc (ph : setvar → wff) (A : «class») : wff := A ∈ {x | ph x}
theorem df_sbc {ph : setvar → wff} {A : setvar → «class»} (x) :
  wsbc ph (A x) ↔ A x ∈ {x | ph x} := iff.rfl

def csb (A : «class») (B : setvar → «class») : «class» :=
{y | wsbc (λ x, y ∈ B x) A}
theorem df_csb {A B : setvar → «class»} (x) :
  csb (A x) B = {y | wsbc (λ x, y ∈ B x) (A x)} := rfl

def cdif : «class» → «class» → «class» := (\)

def cun : «class» → «class» → «class» := (∪)

def cin : «class» → «class» → «class» := (∩)

def wss : «class» → «class» → wff := (⊆)

def wpss : «class» → «class» → wff := (⊂)

theorem df_dif {A B : «class»} : A \ B = {x | x ∈ A ∧ ↑x ∉ B} := by simp; refl

theorem df_un {A B : «class»} : A ∪ B = {x | x ∈ A ∨ x ∈ B} := by simp; refl

theorem df_in {A B : «class»} : A ∩ B = {x | x ∈ A ∧ x ∈ B} := by simp; refl

theorem df_ss {A B : «class»} : A ⊆ B ↔ A ∩ B = A :=
⟨set.inter_eq_self_of_subset_left, λ h, h ▸ set.inter_subset_right _ _⟩

theorem df_pss {A B : «class»} : A ⊂ B ↔ A ⊆ B ∧ A ≠ B := iff.rfl

def c0 : «class» := ∅

theorem df_nul : ∅ = V \ V := set.diff_self.symm

def cif (ph : wff) (A B : «class») : «class» := {x | x ∈ A ∧ ph ∨ x ∈ B ∧ ¬ ph}

theorem df_if {ph : wff} {A B : «class»} :
  cif ph A B = {x | x ∈ A ∧ ph ∨ x ∈ B ∧ ¬ ph} := rfl

def cpw : «class» → «class» := Class.powerset
theorem df_pw {A : «class»} : cpw A = {x | ↑x ⊆ A} := rfl

def csn (A : «class») : «class» := {x | ↑x = A}
theorem df_sn {A : «class»} : csn A = {x | ↑x = A} := rfl

def cpr (A B : «class») : «class» := csn A ∪ csn B
theorem df_pr {A B : «class»} : cpr A B = csn A ∪ csn B := rfl

def ctp (A B C : «class») : «class» := csn A ∪ csn B ∪ csn C
theorem df_tp {A B C : «class»} : ctp A B C = cpr A B ∪ csn C := rfl

def cop (A B : «class») : «class» :=
{x | A ∈ V ∧ B ∈ V ∧ x ∈ cpr (csn A) (cpr A B)}
theorem df_op {A B : «class»} :
  cop A B = {x | A ∈ V ∧ B ∈ V ∧ x ∈ cpr (csn A) (cpr A B)} := rfl

def cotp (A B C : «class») : «class» := cop (cop A B) C
theorem df_ot {A B C : «class»} : cotp A B C = cop (cop A B) C := rfl

def cuni (A : «class») : «class» := {x | ∃ y:setvar, x ∈ y ∧ y ∈ A}
theorem df_uni {A : «class»} : cuni A = {x | ∃ y:setvar, x ∈ y ∧ y ∈ A} := rfl

def cint (A : «class») : «class» := {x | ∀ y:setvar, y ∈ A → x ∈ y}
theorem df_int {A : «class»} : cint A = {x | ∀ y:setvar, y ∈ A → x ∈ y} := rfl

def ciun (A B : setvar → «class») : «class» := {y | ∃ x:setvar, x ∈ A x ∧ y ∈ B x}
theorem df_iun {A B : setvar → «class»} :
  ciun A B = {y | ∃ x:setvar, x ∈ A x ∧ y ∈ B x} := rfl

def ciin (A B : setvar → «class») : «class» := {y | ∀ x:setvar, x ∈ A x → y ∈ B x}
theorem df_iin {A B : setvar → «class»} :
  ciin A B = {y | ∀ x:setvar, x ∈ A x → y ∈ B x} := rfl

def wdisj (A B : setvar → «class») : wff := ∀ y, ∃* x, x ∈ A x ∧ y ∈ B x
theorem df_disj {A B : setvar → «class»} :
  wdisj A B ↔ ∀ y, ∃* x, x ∈ A x ∧ y ∈ B x := iff.rfl

def wbr (A B R : «class») : wff := cop A B ∈ R
theorem df_br {A B R : «class»} : wbr A B R ↔ cop A B ∈ R := iff.rfl

def copab (ph : setvar → setvar → wff) : «class» :=
{z | ∃ x y:setvar, ↑z = cop x y ∧ ph x y}
theorem df_opab {ph : setvar → setvar → wff} :
  copab ph = {z | ∃ x y:setvar, ↑z = cop x y ∧ ph x y} := rfl

-- TODO: fix this properly by bundling copab; for now we will just assume
-- this isn't used
axiom df_opab_b {ph : setvar → wff} :
  copab (λ x x, ph x) = {z | ∃ x x':setvar, ↑z = cop x' x' ∧ ph x'}

def cmpt (A B : setvar → «class») : «class» := copab (λ x y, x ∈ A x ∧ ↑y = B x)
theorem df_mpt {A B : setvar → «class»} :
  cmpt A B = copab (λ x y, x ∈ A x ∧ ↑y = B x) := rfl

def wtr (A : «class») : wff := wss (cuni A) A

theorem df_tr {A : «class»} : ⊦ wb (wtr A) (wss (cuni A) A) := iff.rfl

theorem ax_rep {ph : ∀ y z w : setvar, wff} {x : setvar}
  (H : ∀ w:setvar, ∃ y:setvar, ∀ z, (∀ y, ph y z w) → z ≡ y) :
  ∃ y:setvar, ∀ z:setvar, z ∈ y ↔ ∃ w:setvar, w ∈ x ∧ (∀ y, ph y z w) :=
begin
  simp at *,
  choose f hf using classical.axiom_of_choice H, dsimp at f,
  haveI := @classical.all_definable 1 f,
  refine ⟨has_sep.sep (λ z, ∃ w, w ∈' x ∧ ∀ (y : setvar), ph y z w) (Set.image f x),
    λ z, Set.mem_sep.trans (and_iff_right_of_imp _)⟩,
  rintro ⟨w, wx, hw⟩,
  exact Set.mem_image.2 ⟨w, wx, (hf _ _ hw).symm⟩
end

theorem ax_sep {ph : setvar → wff} {z : setvar} :
  ∃ y:setvar, ∀ x:setvar, x ∈ y ↔ x ∈ z ∧ ph x :=
by simp; exact ⟨has_sep.sep ph z, λ x, Set.mem_sep⟩

theorem ax_nul : ∃ x:setvar, ∀ y:setvar, y ∉ x := ⟨∅, Set.mem_empty⟩

theorem ax_pow {x : setvar} :
  ∃ y:setvar, ∀ z:setvar, (∀ w:setvar, w ∈ z → w ∈ x) → z ∈ y :=
by simp; exact ⟨Set.powerset x, λ z, Set.mem_powerset.2⟩

theorem ax_pr {x y : setvar} : ∃ z:setvar, ∀ w:setvar, w ≡ x ∨ w ≡ y → w ∈ z :=
⟨has_insert.insert y (singleton x), by simp⟩

theorem ax_pr_b {x : setvar} : ∃ z:setvar, ∀ w:setvar, w ≡ x ∨ w ≡ x → w ∈ z := ax_pr

def cep : «class» := copab (∈')
theorem df_eprel : cep = copab (∈) := by simp; refl

def cid : «class» := copab (=)
theorem df_id : cid = copab (λ x y, x ≡ y) := by simp; refl

def wpo (A R : «class») : wff :=
wral (λ x, wral (λ y, wral (λ z, wa (wn (wbr (cv x) (cv x) R)) (wi (wa (wbr (cv x) (cv y) R) (wbr (cv y) (cv z) R)) (wbr (cv x) (cv z) R))) (λ z, A)) (λ y, A)) (λ x, A)
theorem df_po {A R : «class»} : wpo A R ↔
  wral (λ x, wral (λ y, wral (λ z, wa (wn (wbr (cv x) (cv x) R)) (wi (wa (wbr (cv x) (cv y) R) (wbr (cv y) (cv z) R)) (wbr (cv x) (cv z) R))) (λ z, A)) (λ y, A)) (λ x, A) := iff.rfl

def wor (A R : «class») : wff :=
wa (wpo A R) (wral (λ x, wral (λ y, w3o (wbr (cv x) (cv y) R) (wceq (cv x) (cv y)) (wbr (cv y) (cv x) R)) (λ y, A)) (λ x, A))
theorem df_so {A R : «class»} : wor A R ↔ (wa (wpo A R) (wral (λ x, wral (λ y, w3o (wbr (cv x) (cv y) R) (wceq (cv x) (cv y)) (wbr (cv y) (cv x) R)) (λ y, A)) (λ x, A))) := iff.rfl

def wfr (A R : «class») : wff := wal (λ x, wi (wa (wss (cv x) A) (wne (cv x) c0)) (wrex (λ y, wral (λ z, wn (wbr (cv z) (cv y) R)) (λ z, cv x)) (λ y, cv x)))
theorem df_fr {A R : «class»} : wfr A R ↔ (wal (λ x, wi (wa (wss (cv x) A) (wne (cv x) c0)) (wrex (λ y, wral (λ z, wn (wbr (cv z) (cv y) R)) (λ z, cv x)) (λ y, cv x)))) := iff.rfl

def wse (A R : «class») : wff := wral (λ x, wcel (crab (λ y, wbr (cv y) (cv x) R) (λ y, A)) V) (λ x, A)
theorem df_se {A R : «class»} : wse A R ↔ (wral (λ x, wcel (crab (λ y, wbr (cv y) (cv x) R) (λ y, A)) V) (λ x, A)) := iff.rfl

def wwe (A R : «class») : wff := wa (wfr A R) (wor A R)
theorem df_we {A R : «class»} : wwe A R ↔ (wa (wfr A R) (wor A R)) := iff.rfl

def word (A : «class») : wff := wa (wtr A) (wwe A cep)
theorem df_ord {A : «class»} : word A ↔ wa (wtr A) (wwe A cep) := iff.rfl

def con0 : «class» := cab (λ x, word (cv x))
theorem df_on : ⊦ wceq con0 (cab (λ x, word (cv x))) := eq.refl _

def wlim (A : «class») : wff := w3a (word A) (wne A c0) (wceq A (cuni A))
theorem df_lim {A : «class»} : wlim A ↔ w3a (word A) (wne A c0) (wceq A (cuni A)) := iff.rfl

def csuc (A : «class») : «class» := cun A (csn A)
theorem df_suc {A : «class»} : csuc A = cun A (csn A) := rfl

def cxp (A B : «class») : «class» := copab (λ x y, x ∈ A ∧ y ∈ B)
theorem df_xp {A B : «class»} : cxp A B = copab (λ x y, x ∈ A ∧ y ∈ B) := rfl

def ccnv (A : «class») : «class» := copab (λ x y, wbr y x A)
theorem df_cnv {A : «class»} : ccnv A = copab (λ x y, wbr y x A) := rfl

def cdm (A : «class») : «class» := {x | ∃ y:setvar, wbr (cv x) (cv y) A}
theorem df_dm {A : «class»} : cdm A = {x | ∃ y:setvar, wbr (cv x) (cv y) A} := rfl

def crn (A : «class») : «class» := cdm (ccnv A)
theorem df_rn {A : «class»} : crn A = cdm (ccnv A) := rfl

def cres (A B : «class») : «class» := cin A (cxp B V)
theorem df_res {A B : «class»} : cres A B = cin A (cxp B V) := rfl

def cima (A B : «class») : «class» := crn (cres A B)
theorem df_ima {A B : «class»} : cima A B = crn (cres A B) := rfl

def ccom (A B : «class») : «class» := copab (λ x y, wex (λ z, wa (wbr (cv x) (cv z) B) (wbr (cv z) (cv y) A)))
theorem df_co {A B : «class»} : ccom A B = copab (λ x y, wex (λ z, wa (wbr (cv x) (cv z) B) (wbr (cv z) (cv y) A))) := rfl

def wrel (A : «class») : wff := wss A (cxp V V)
theorem df_rel {A : «class»} : ⊦ wrel A ↔ wss A (cxp V V) := iff.rfl

def cio (ph : setvar → wff) : «class» := cuni (cab (λ y, wceq (cab (λ x, ph x)) (csn (cv y))))
theorem df_iota {ph : setvar → wff} : cio (λ x, ph x) = cuni (cab (λ y, wceq (cab (λ x, ph x)) (csn (cv y)))) := rfl

def wfun (A : «class») : wff := wa (wrel A) (wss (ccom A (ccnv A)) cid)
theorem df_fun {A : «class»} : wfun A ↔ wa (wrel A) (wss (ccom A (ccnv A)) cid) := iff.rfl

def wfn (A B : «class») : wff := wa (wfun A) (wceq (cdm A) B)
theorem df_fn {A B : «class»} : wfn A B ↔ wa (wfun A) (wceq (cdm A) B) := iff.rfl

def wf (A B F : «class») : wff := wa (wfn F A) (wss (crn F) B)
theorem df_f {A B F : «class»} : wf A B F ↔ wa (wfn F A) (wss (crn F) B) := iff.rfl

def wf1 (A B F : «class») : wff := wa (wf A B F) (wfun (ccnv F))
theorem df_f1 {A B F : «class»} : wf1 A B F ↔ wa (wf A B F) (wfun (ccnv F)) := iff.rfl

def wfo (A B F : «class») : wff := wa (wfn F A) (wceq (crn F) B)
theorem df_fo {A B F : «class»} : wfo A B F ↔ wa (wfn F A) (wceq (crn F) B) := iff.rfl

def wf1o (A B F : «class») : wff := wa (wf1 A B F) (wfo A B F)
theorem df_f1o {A B F : «class»} : wf1o A B F ↔ wa (wf1 A B F) (wfo A B F) := iff.rfl

def cfv (A F : «class») : «class» := cio (λ x, wbr A (cv x) F)
theorem df_fv {A F : «class»} : cfv A F = cio (λ x, wbr A (cv x) F) := rfl

def wiso (A B R S H : «class») : wff := wa (wf1o A B H) (wral (λ x, wral (λ y, wb (wbr (cv x) (cv y) R) (wbr (cfv (cv x) H) (cfv (cv y) H) S)) (λ y, A)) (λ x, A))
theorem df_isom {A B R S H : «class»} : wiso A B R S H ↔ wa (wf1o A B H) (wral (λ x, wral (λ y, wb (wbr (cv x) (cv y) R) (wbr (cfv (cv x) H) (cfv (cv y) H) S)) (λ y, A)) (λ x, A)) := iff.rfl

def crio (ph : setvar → wff) (A : setvar → «class») : «class» := cio (λ x, wa (wcel (cv x) (A x)) (ph x))
theorem df_riota {ph : setvar → wff} {A : setvar → «class»} : crio ph A = cio (λ x, wa (wcel (cv x) (A x)) (ph x)) := rfl

def co (A B F : «class») : «class» := cfv (cop A B) F
theorem df_ov {A B F : «class»} : co A B F = cfv (cop A B) F := rfl

def coprab (ph : ∀ x y z : setvar, wff) : «class» := cab (λ w, wex (λ x, wex (λ y, wex (λ z, wa (wceq (cv w) (cop (cop (cv x) (cv y)) (cv z))) (ph x y z)))))
theorem df_oprab {ph : ∀ x y z : setvar, wff} : coprab ph = cab (λ w, wex (λ x, wex (λ y, wex (λ z, wa (wceq (cv w) (cop (cop (cv x) (cv y)) (cv z))) (ph x y z))))) := rfl

def cmpt2 (A B C : setvar → setvar → «class») : «class» := coprab (λ x y z, wa (wa (wcel (cv x) (A x y)) (wcel (cv y) (B x y))) (wceq (cv z) (C x y)))
theorem df_mpt2 {A B C : setvar → setvar → «class»} : cmpt2 A B C = coprab (λ x y z, wa (wa (wcel (cv x) (A x y)) (wcel (cv y) (B x y))) (wceq (cv z) (C x y))) := rfl

def cof (R : «class») : «class» := cmpt2 (λ f1 g1, V) (λ f1 g1, V) (λ f1 g1, cmpt (λ x, cin (cdm (cv f1)) (cdm (cv g1))) (λ x, co (cfv (cv x) (cv f1)) (cfv (cv x) (cv g1)) R))
theorem df_of {R : «class»} : cof R = cmpt2 (λ f1 g1, V) (λ f1 g1, V) (λ f1 g1, cmpt (λ x, cin (cdm (cv f1)) (cdm (cv g1))) (λ x, co (cfv (cv x) (cv f1)) (cfv (cv x) (cv g1)) R)) := rfl

def cofr (R : «class») : «class» := copab (λ f1 g1, wral (λ x, wbr (cfv (cv x) (cv f1)) (cfv (cv x) (cv g1)) R) (λ x, cin (cdm (cv f1)) (cdm (cv g1))))
theorem df_ofr {R : «class»} : cofr R = copab (λ f1 g1, wral (λ x, wbr (cfv (cv x) (cv f1)) (cfv (cv x) (cv g1)) R) (λ x, cin (cdm (cv f1)) (cdm (cv g1)))) := rfl

def crpss : «class» := copab (λ x y, (x:«class») ⊂ y)
theorem df_rpss : crpss = copab (λ x y, wpss (cv x) (cv y)) := rfl

theorem ax_un {x : setvar} : ∃ y:setvar, ∀ z:setvar,
  (∃ w:setvar, z ∈ w ∧ w ∈ x) → z ∈ y :=
by simp; exact ⟨Set.Union x, λ z w zw wx, Set.mem_Union.2 ⟨w, wx, zw⟩⟩

def com : «class» := crab (λ x, wal (λ y, wi (wlim (cv y)) (wcel (cv x) (cv y)))) (λ x, con0)
theorem df_om : com = crab (λ x, wal (λ y, wi (wlim (cv y)) (wcel (cv x) (cv y)))) (λ x, con0) := rfl

def c1st : «class» := cmpt (λ x, V) (λ x, cuni (cdm (csn (cv x))))
theorem df_1st : c1st = cmpt (λ x, V) (λ x, cuni (cdm (csn (cv x)))) := rfl

def c2nd : «class» := cmpt (λ x, V) (λ x, cuni (crn (csn (cv x))))
theorem df_2nd : c2nd = cmpt (λ x, V) (λ x, cuni (crn (csn (cv x)))) := rfl

def ctpos (F : «class») : «class» := ccom F (cmpt (λ x, cun (ccnv (cdm F)) (csn c0)) (λ x, cuni (ccnv (csn (cv x)))))
theorem df_tpos {F : «class»} : ctpos F = ccom F (cmpt (λ x, cun (ccnv (cdm F)) (csn c0)) (λ x, cuni (ccnv (csn (cv x))))) := rfl

def ccur (F : «class») : «class» := cmpt (λ x, cdm (cdm F)) (λ x, copab (λ y z, wbr (cop (cv x) (cv y)) (cv z) F))
theorem df_cur {F : «class»} : ccur F = cmpt (λ x, cdm (cdm F)) (λ x, copab (λ y z, wbr (cop (cv x) (cv y)) (cv z) F)) := rfl

def cunc (F : «class») : «class» := coprab (λ x y z, wbr (cv y) (cv z) (cfv (cv x) F))
theorem df_unc {F : «class»} : cunc F = coprab (λ x y z, wbr (cv y) (cv z) (cfv (cv x) F)) := rfl

def cund : «class» := cmpt (λ s, V) (λ s, cpw (cuni (cv s)))
theorem df_undef : cund = cmpt (λ s, V) (λ s, cpw (cuni (cv s))) := rfl

def wsmo (A : «class») : wff := w3a (wf (cdm A) con0 A) (word (cdm A)) (wral (λ x, wral (λ y, wi (wcel (cv x) (cv y)) (wcel (cfv (cv x) A) (cfv (cv y) A))) (λ y, cdm A)) (λ x, cdm A))
theorem df_smo {A : «class»} : wsmo A ↔ w3a (wf (cdm A) con0 A) (word (cdm A)) (wral (λ x, wral (λ y, wi (wcel (cv x) (cv y)) (wcel (cfv (cv x) A) (cfv (cv y) A))) (λ y, cdm A)) (λ x, cdm A)) := iff.rfl

def crecs (F : «class») : «class» := cuni (cab (λ f1, wrex (λ x, wa (wfn (cv f1) (cv x)) (wral (λ y, wceq (cfv (cv y) (cv f1)) (cfv (cres (cv f1) (cv y)) F)) (λ y, cv x))) (λ x, con0)))
theorem df_recs {F : «class»} : crecs F = cuni (cab (λ f1, wrex (λ x, wa (wfn (cv f1) (cv x)) (wral (λ y, wceq (cfv (cv y) (cv f1)) (cfv (cres (cv f1) (cv y)) F)) (λ y, cv x))) (λ x, con0))) := rfl

def crdg (F I : «class») : «class» := crecs (cmpt (λ g1, V) (λ g1, cif (wceq (cv g1) c0) I (cif (wlim (cdm (cv g1))) (cuni (crn (cv g1))) (cfv (cfv (cuni (cdm (cv g1))) (cv g1)) F))))
theorem df_rdg {F I : «class»} : crdg F I = crecs (cmpt (λ g1, V) (λ g1, cif (wceq (cv g1) c0) I (cif (wlim (cdm (cv g1))) (cuni (crn (cv g1))) (cfv (cfv (cuni (cdm (cv g1))) (cv g1)) F)))) := rfl

def cseqom (F I : «class») : «class» := cima (crdg (cmpt2 (λ i v, com) (λ i v, V) (λ i v, cop (csuc (cv i)) (co (cv i) (cv v) F))) (cop c0 (cfv I cid))) com
theorem df_seqom {F I : «class»} : cseqom F I = cima (crdg (cmpt2 (λ i v, com) (λ i v, V) (λ i v, cop (csuc (cv i)) (co (cv i) (cv v) F))) (cop c0 (cfv I cid))) com := rfl

def c1o : «class» := csuc c0
theorem df_1o : c1o = csuc c0 := rfl

def c2o : «class» := csuc c1o
theorem df_2o : c2o = csuc c1o := rfl

def c3o : «class» := csuc c2o
theorem df_3o : c3o = csuc c2o := rfl

def c4o : «class» := csuc c3o
theorem df_4o : c4o = csuc c3o := rfl

def coa : «class» := cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cfv (cv y) (crdg (cmpt (λ z, V) (λ z, csuc (cv z))) (cv x)))
theorem df_oadd : coa = cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cfv (cv y) (crdg (cmpt (λ z, V) (λ z, csuc (cv z))) (cv x))) := rfl

def comu : «class» := cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cfv (cv y) (crdg (cmpt (λ z, V) (λ z, co (cv z) (cv x) coa)) c0))
theorem df_omul : comu = cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cfv (cv y) (crdg (cmpt (λ z, V) (λ z, co (cv z) (cv x) coa)) c0)) := rfl

def coe : «class» := cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cif (wceq (cv x) c0) (cdif c1o (cv y)) (cfv (cv y) (crdg (cmpt (λ z, V) (λ z, co (cv z) (cv x) comu)) c1o)))
theorem df_oexp : coe = cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cif (wceq (cv x) c0) (cdif c1o (cv y)) (cfv (cv y) (crdg (cmpt (λ z, V) (λ z, co (cv z) (cv x) comu)) c1o))) := rfl

def wer (A R : «class») : wff := w3a (wrel R) (wceq (cdm R) A) (wss (cun (ccnv R) (ccom R R)) R)
theorem df_er {A R : «class»} : wer A R ↔ w3a (wrel R) (wceq (cdm R) A) (wss (cun (ccnv R) (ccom R R)) R) := iff.rfl

def cec (A R : «class») : «class» := cima R (csn A)
theorem df_ec {A R : «class»} : cec A R = cima R (csn A) := rfl

def cqs (A R : «class») : «class» := cab (λ y, wrex (λ x, wceq (cv y) (cec (cv x) R)) (λ x, A))
theorem df_qs {A R : «class»} : cqs A R = cab (λ y, wrex (λ x, wceq (cv y) (cec (cv x) R)) (λ x, A)) := rfl

def cmap : «class» := cmpt2 (λ x y, V) (λ x y, V) (λ x y, cab (λ f1, wf (cv y) (cv x) (cv f1)))
theorem df_map : cmap = cmpt2 (λ x y, V) (λ x y, V) (λ x y, cab (λ f1, wf (cv y) (cv x) (cv f1))) := rfl

def cpm : «class» := cmpt2 (λ x y, V) (λ x y, V) (λ x y, crab (λ f1, wfun (cv f1)) (λ f1, cpw (cxp (cv y) (cv x))))
theorem df_pm : cpm = cmpt2 (λ x y, V) (λ x y, V) (λ x y, crab (λ f1, wfun (cv f1)) (λ f1, cpw (cxp (cv y) (cv x)))) := rfl

def cixp (A B : setvar → «class») : «class» := cab (λ f1, wa (wfn (cv f1) (cab (λ x, wcel (cv x) (A x)))) (wral (λ x, wcel (cfv (cv x) (cv f1)) (B x)) (λ x, A x)))
theorem df_ixp {A B : setvar → «class»} : cixp A B = cab (λ f1, wa (wfn (cv f1) (cab (λ x, wcel (cv x) (A x)))) (wral (λ x, wcel (cfv (cv x) (cv f1)) (B x)) (λ x, A x))) := rfl

def cen : «class» := copab (λ x y, wex (λ f1, wf1o (cv x) (cv y) (cv f1)))
theorem df_en : cen = copab (λ x y, wex (λ f1, wf1o (cv x) (cv y) (cv f1))) := rfl

def cdom : «class» := copab (λ x y, wex (λ f1, wf1 (cv x) (cv y) (cv f1)))
theorem df_dom : cdom = copab (λ x y, wex (λ f1, wf1 (cv x) (cv y) (cv f1))) := rfl

def csdm : «class» := cdif cdom cen
theorem df_sdom : csdm = cdif cdom cen := rfl

def cfn : «class» := cab (λ x, wrex (λ y, wbr (cv x) (cv y) cen) (λ y, com))
theorem df_fin : cfn = cab (λ x, wrex (λ y, wbr (cv x) (cv y) cen) (λ y, com)) := rfl

def cfi : «class» := cmpt (λ x, V) (λ x, cab (λ z, wrex (λ y, wceq (cv z) (cint (cv y))) (λ y, cin (cpw (cv x)) cfn)))
theorem df_fi : cfi = cmpt (λ x, V) (λ x, cab (λ z, wrex (λ y, wceq (cv z) (cint (cv y))) (λ y, cin (cpw (cv x)) cfn))) := rfl

def csup (A B R : «class») : «class» := cuni (crab (λ x, wa (wral (λ y, wn (wbr (cv x) (cv y) R)) (λ y, A)) (wral (λ y, wi (wbr (cv y) (cv x) R) (wrex (λ z, wbr (cv y) (cv z) R) (λ z, A))) (λ y, B))) (λ x, B))

theorem df_sup {A B R : «class»} : csup A B R = cuni (crab (λ x, wa (wral (λ y, wn (wbr (cv x) (cv y) R)) (λ y, A)) (wral (λ y, wi (wbr (cv y) (cv x) R) (wrex (λ z, wbr (cv y) (cv z) R) (λ z, A))) (λ y, B))) (λ x, B)) := rfl

def coi (A R : «class») : «class» := cif (wa (wwe A R) (wse A R)) (cres (crecs (cmpt (λ h, V) (λ h, crio (λ v, wral (λ u, wn (wbr (cv u) (cv v) R)) (λ u, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))) (λ v, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))))) (crab (λ x, wrex (λ t, wral (λ z, wbr (cv z) (cv t) R) (λ z, cima (crecs (cmpt (λ h, V) (λ h, crio (λ v, wral (λ u, wn (wbr (cv u) (cv v) R)) (λ u, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))) (λ v, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))))) (cv x))) (λ t, A)) (λ x, con0))) c0

theorem df_oi {A R : «class»} : coi A R = cif (wa (wwe A R) (wse A R)) (cres (crecs (cmpt (λ h, V) (λ h, crio (λ v, wral (λ u, wn (wbr (cv u) (cv v) R)) (λ u, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))) (λ v, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))))) (crab (λ x, wrex (λ t, wral (λ z, wbr (cv z) (cv t) R) (λ z, cima (crecs (cmpt (λ h, V) (λ h, crio (λ v, wral (λ u, wn (wbr (cv u) (cv v) R)) (λ u, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))) (λ v, crab (λ w, wral (λ j, wbr (cv j) (cv w) R) (λ j, crn (cv h))) (λ w, A))))) (cv x))) (λ t, A)) (λ x, con0))) c0 := rfl

def char : «class» := cmpt (λ x, V) (λ x, crab (λ y, wbr (cv y) (cv x) cdom) (λ y, con0))
theorem df_har : char = cmpt (λ x, V) (λ x, crab (λ y, wbr (cv y) (cv x) cdom) (λ y, con0)) := rfl

def cwdom : «class» := copab (λ x y, wo (wceq (cv x) c0) (wex (λ z, wfo (cv y) (cv x) (cv z))))
theorem df_wdom : cwdom = copab (λ x y, wo (wceq (cv x) c0) (wex (λ z, wfo (cv y) (cv x) (cv z)))) := rfl

theorem ax_reg {x : setvar} (H : ∃ y:setvar, y ∈ x) : ∃ y:setvar, y ∈ x ∧ ∀ z:setvar, z ∈ y → z ∉ x :=
begin
  simp at *,
  cases H with y hy,
  rcases Set.regularity x (λ h, (Set.eq_empty x).1 h _ hy) with ⟨w, xw, h⟩,
  simp [Set.eq_empty] at h,
  exact ⟨w, xw, λ z zy zx, h z zx zy⟩
end

def {u} ax_inf.aux (x : Set.{u}) : ℕ → Set.{u}
| 0 := x
| (n+1) := Set.insert (ax_inf.aux n) ∅

theorem ax_inf {x : setvar} : ∃ y:setvar, x ∈ y ∧
  ∀ z:setvar, z ∈ y → ∃ w:setvar, z ∈ w ∧ w ∈ y :=
⟨Set.range (ax_inf.aux x), begin
  simp,
  refine ⟨⟨0, rfl⟩, _⟩,
  rintro _ n rfl,
  exact ⟨_, Set.mem_insert.2 (or.inl rfl), n+1, rfl⟩
end⟩

theorem ax_inf2 : ∃ x:setvar,
  (∃ y:setvar, y ∈ x ∧ ∀ z:setvar, z ∉ y) ∧
  ∀ y:setvar, y ∈ x → ∃ z:setvar, z ∈ x ∧ ∀ w:setvar, w ∈ z ↔ w ∈ y ∨ w ≡ y :=
sorry

def ccnf : «class» := sorry

theorem df_cnf : ⊦ wceq ccnf (cmpt2 (λ x y, con0) (λ x y, con0) (λ x y, cmpt (λ f1, crab (λ g1, wcel (cima (ccnv (cv g1)) (cdif V c1o)) cfn) (λ g1, co (cv x) (cv y) cmap)) (λ f1, csb (λ h, coi (cima (ccnv (cv f1)) (cdif V c1o)) cep) (λ h, cfv (cdm (cv h)) (cseqom (cmpt2 (λ k z, V) (λ k z, V) (λ k z, co (co (co (cv x) (cfv (cv k) (cv h)) coe) (cfv (cfv (cv k) (cv h)) (cv f1)) comu) (cv z) coa)) c0))))) := sorry

def ctc : «class» := sorry

theorem df_tc : ⊦ wceq ctc (cmpt (λ x, V) (λ x, cint (cab (λ y, wa (wss (cv x) (cv y)) (wtr (cv y)))))) := sorry

def cr1 : «class» := sorry

def crnk : «class» := sorry

theorem df_r1 : ⊦ wceq cr1 (crdg (cmpt (λ x, V) (λ x, cpw (cv x))) c0) := sorry

theorem df_rank : ⊦ wceq crnk (cmpt (λ x, V) (λ x, cint (crab (λ y, wcel (cv x) (cfv (csuc (cv y)) cr1)) (λ y, con0)))) := sorry

def ccrd : «class» := sorry

def cale : «class» := sorry

def ccf : «class» := sorry

def wacn : «class» → «class» := sorry

theorem df_card : ⊦ wceq ccrd (cmpt (λ x, V) (λ x, cint (crab (λ y, wbr (cv y) (cv x) cen) (λ y, con0)))) := sorry

theorem df_aleph : ⊦ wceq cale (crdg char com) := sorry

theorem df_cf : ⊦ wceq ccf (cmpt (λ x, con0) (λ x, cint (cab (λ y, wex (λ z, wa (wceq (cv y) (cfv (cv z) ccrd)) (wa (wss (cv z) (cv x)) (wral (λ v, wrex (λ u,  wss (cv v) (cv u)) (λ u, cv z)) (λ v, cv x)))))))) := sorry

theorem df_acn {A : «class»} : ⊦ wceq (wacn A) (cab (λ x, wa (wcel A V) (wral (λ f1, wex (λ g1, wral (λ y, wcel (cfv (cv y) (cv g1)) (cfv (cv y) (cv f1)))  (λ y, A))) (λ f1, co (cdif (cpw (cv x)) (csn c0)) A cmap)))) := sorry

def wac : wff := sorry

theorem df_ac : ⊦ wb wac (wal (λ x, wex (λ f1, wa (wss (cv f1) (cv x)) (wfn (cv f1) (cdm (cv x)))))) := sorry

def ccda : «class» := sorry

theorem df_cda : ⊦ wceq ccda (cmpt2 (λ x y, V) (λ x y, V) (λ x y, cun (cxp (cv x) (csn c0)) (cxp (cv y) (csn c1o)))) := sorry
-/

end mm0
